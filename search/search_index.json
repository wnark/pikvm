{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PiKVM Handbook \u00b6 Welcome to the PiKVM Handbook - a complete documentation of Open and cheap DIY IP-KVM based on Raspberry Pi. Here you will find comprehensive information about all aspects of the operation of PiKVM, get answers to your most difficult questions and be able to solve the problems that have arisen. Where to start? \u00b6 Learn about the basics of working with PiKVM . If you are a happy PiKVM v3 HAT user then we have a special guide for you . Explore the features of PiKVM using the site's table of contents. If you encounter a problem , take a look at the FAQ , but if nothing helped, contact our Discord chat - experienced users and the PiKVM team will definitely help you. Links \u00b6 Official website: https://pikvm.org Our GitHub: https://github.com/pikvm Discord server: Subreddit:","title":"PiKVM Handbook"},{"location":"#pikvm-handbook","text":"Welcome to the PiKVM Handbook - a complete documentation of Open and cheap DIY IP-KVM based on Raspberry Pi. Here you will find comprehensive information about all aspects of the operation of PiKVM, get answers to your most difficult questions and be able to solve the problems that have arisen.","title":"PiKVM Handbook"},{"location":"#where-to-start","text":"Learn about the basics of working with PiKVM . If you are a happy PiKVM v3 HAT user then we have a special guide for you . Explore the features of PiKVM using the site's table of contents. If you encounter a problem , take a look at the FAQ , but if nothing helped, contact our Discord chat - experienced users and the PiKVM team will definitely help you.","title":"Where to start?"},{"location":"#links","text":"Official website: https://pikvm.org Our GitHub: https://github.com/pikvm Discord server: Subreddit:","title":"Links"},{"location":"3d_printing/","text":"Cases for 3D printing \u00b6 PiKVM V3 HAT cases \u00b6 v3.3 model (Kickstarter, Store) Unofficial but great v3.3 case mod for Noctua fan v3.2 model (Pre-release) DIY cases \u00b6 Model Notes https://www.thingiverse.com/thing:4799094 Case for the USB-C/PWR Splitter without Barrel jack https://www.thingiverse.com/thing:4931970 Case for the USB-C/PWR Splitter without Barrel jack https://www.thingiverse.com/thing:4862304 Case for PiKVM (LCD + ATX) https://www.thingiverse.com/thing:4868258 R4C3R - Low Profile PCIe bracket for PiKVM based on Raspberry Pi Zero + Lusya + ATX controls https://www.thingiverse.com/thing:4866005 R4C3R - Full Profile PCIe bracket for PiKVM based on Raspberry Pi Zero + Lusya + ATX controls https://www.thingiverse.com/thing:4832248 Case for the USB-C/PWR Splitter without Barrel jack and HDMI-CSI bridge https://www.thingiverse.com/thing:4916230 A very compact case without internal power splitter https://www.thingiverse.com/thing:4915627 ZeroW + CSI case https://www.thingiverse.com/thing:4950281 PiKVM RETRO Case for CSI-2 C779 Bridge w/ OLED Display Screen https://www.thingiverse.com/thing:4950280 USB Power Blocker Case https://www.thingiverse.com/thing:4642116 Conix's PI-KVM case for v2","title":"Cases for 3D printing"},{"location":"3d_printing/#cases-for-3d-printing","text":"","title":"Cases for 3D printing"},{"location":"3d_printing/#pikvm-v3-hat-cases","text":"v3.3 model (Kickstarter, Store) Unofficial but great v3.3 case mod for Noctua fan v3.2 model (Pre-release)","title":"PiKVM V3 HAT cases"},{"location":"3d_printing/#diy-cases","text":"Model Notes https://www.thingiverse.com/thing:4799094 Case for the USB-C/PWR Splitter without Barrel jack https://www.thingiverse.com/thing:4931970 Case for the USB-C/PWR Splitter without Barrel jack https://www.thingiverse.com/thing:4862304 Case for PiKVM (LCD + ATX) https://www.thingiverse.com/thing:4868258 R4C3R - Low Profile PCIe bracket for PiKVM based on Raspberry Pi Zero + Lusya + ATX controls https://www.thingiverse.com/thing:4866005 R4C3R - Full Profile PCIe bracket for PiKVM based on Raspberry Pi Zero + Lusya + ATX controls https://www.thingiverse.com/thing:4832248 Case for the USB-C/PWR Splitter without Barrel jack and HDMI-CSI bridge https://www.thingiverse.com/thing:4916230 A very compact case without internal power splitter https://www.thingiverse.com/thing:4915627 ZeroW + CSI case https://www.thingiverse.com/thing:4950281 PiKVM RETRO Case for CSI-2 C779 Bridge w/ OLED Display Screen https://www.thingiverse.com/thing:4950280 USB Power Blocker Case https://www.thingiverse.com/thing:4642116 Conix's PI-KVM case for v2","title":"DIY cases"},{"location":"api/","text":"API \u00b6 This document describes the PiKVM API. Since the system consists of microservices, here is a common API with a common entry point provided by Nginx. The examples above use curl and websocat with the -k option to disable SSL certificate verification, since the self-signed certificateis used in the default installation. Authorization \u00b6 All APIs are restricted to authorization. To make requests, you either need to authorize each request individually, or get a token and pass it as a cookie with each request. Single request auth \u00b6 There are two options here: Using X-headers. Just pass X-KVMD-User and X-KVMD-Passwd with the request: $ curl -k -H X-KVMD-User:admin -H X-KVMD-Passwd:admin https://<pikvm-ip>/api/auth/check Using HTTP Basic Auth. Please note: contrary to the standard, this method DOES NOT use the WWW-Authenticate header. HTTP Basic Auth in this implementation is intended only for compatibility with other systems, such as Prometheus . $ curl -k -u admin:admin https://<pikvm-ip>/api/auth/check Session-based cookie auth \u00b6 Authorize and get token for the user using POST /api/auth/login : $ curl -k -v -X POST --data user=admin --data passwd=admin https://pikvm/api/auth/login ... < Set-Cookie: auth_token=796cb83b11de4fcb749bc1bad14a91fb06dede84672b2f847fef1e988e6900de; Path=/ ... On success the cookie auth_token will be received with 200 OK . On invalid user or password you will get 403 Forbidden . The handle GET /api/auth/check can be used for check the auth status. Return of 200 OK will signal that user is authenticated. If the token or any of the single-request auth methods are missing, 401 Unauthorized will be returned. In case of incorrect credentials or token, 403 Forbidden will be returned. The handle POST /api/auth/logout can be used to invalidate session token. The response codes will be similar to the previous handle. WebSocket events \u00b6 Most of the data during the user's work with pikvm is transmitted over WebSocket. This includes mouse events, keyboard input, change the state of the various subsystems (such as ATX and Mass Storage Drive). Each event type will be described in the corresponding paragraph for its component. When connecting via WebSocket, the client receives current states as separate events. Then, as the states change, it will receive new events. In a normal situation, opening a socket session triggers the video streamer to start. The streamer works as long as there is at least one client connected via WebSocket. After the last connection is closed and the client timeout expires, the streamer will also be terminated. It is possible create a session that will not start the streamer and will not be counted when counting clients to stop the streamer. To do this, use the URL parameter stream=0 : $ websocat -k wss://<pikvm-ip>/api/ws?stream=0 -H X-KVMD-User:admin -H X-KVMD-Passwd:admin Output with initial events { \"event_type\" : \"gpio_model_state\" , \"event\" : { \"scheme\" : { \"inputs\" : { \"led1\" : { \"hw\" : { \"driver\" : \"__gpio__\" , \"pin\" : 19 }}, \"led2\" : { \"hw\" : { \"driver\" : \"__gpio__\" , \"pin\" : 16 }}}, \"outputs\" : { \"button1\" : { \"switch\" : false , \"pulse\" : { \"delay\" : 0.1 , \"min_delay\" : 0.1 , \"max_delay\" : 0.1 }, \"hw\" : { \"driver\" : \"__gpio__\" , \"pin\" : 26 }}, \"button2\" : { \"switch\" : false , \"pulse\" : { \"delay\" : 0.1 , \"min_delay\" : 0.1 , \"max_delay\" : 0.1 }, \"hw\" : { \"driver\" : \"__gpio__\" , \"pin\" : 20 }}, \"relay1\" : { \"switch\" : true , \"pulse\" : { \"delay\" : 0.1 , \"min_delay\" : 0.1 , \"max_delay\" : 0.1 }, \"hw\" : { \"driver\" : \"relay\" , \"pin\" : 0 }}, \"relay2\" : { \"switch\" : true , \"pulse\" : { \"delay\" : 2.0 , \"min_delay\" : 0.1 , \"max_delay\" : 5.0 }, \"hw\" : { \"driver\" : \"relay\" , \"pin\" : 1 }}}}, \"view\" : { \"header\" : { \"title\" : \"Switches\" }, \"table\" : [[{ \"type\" : \"label\" , \"text\" : \"Generic GPIO leds\" }], null , [{ \"type\" : \"label\" , \"text\" : \"Test 1:\" }, { \"type\" : \"input\" , \"channel\" : \"led1\" , \"color\" : \"green\" }, { \"type\" : \"output\" , \"channel\" : \"button1\" , \"text\" : \"Click\" }], [{ \"type\" : \"label\" , \"text\" : \"Test 2:\" }, { \"type\" : \"input\" , \"channel\" : \"led2\" , \"color\" : \"green\" }, { \"type\" : \"output\" , \"channel\" : \"button2\" , \"text\" : \"Click\" }], null , [{ \"type\" : \"label\" , \"text\" : \"HID Relays /dev/hidraw0\" }], null , [{ \"type\" : \"label\" , \"text\" : \"Relay #1:\" }, { \"type\" : \"output\" , \"channel\" : \"relay1\" , \"text\" : \"Boop 0.1\" }], [{ \"type\" : \"label\" , \"text\" : \"Relay #2:\" }, { \"type\" : \"output\" , \"channel\" : \"relay2\" , \"text\" : \"Boop 2.0\" }]]}}} { \"event_type\" : \"info_extras_state\" , \"event\" : { \"vnc\" : { \"name\" : \"VNC\" , \"description\" : \"Show VNC information\" , \"icon\" : \"share/svg/vnc.svg\" , \"path\" : \"vnc\" , \"keyboard_cap\" : false , \"daemon\" : \"kvmd-vnc\" , \"port\" : 5900 , \"place\" : 20 , \"enabled\" : true }, \"ipmi\" : { \"name\" : \"IPMI\" , \"description\" : \"Show IPMI information\" , \"icon\" : \"share/svg/ipmi.svg\" , \"path\" : \"ipmi\" , \"keyboard_cap\" : false , \"daemon\" : \"kvmd-ipmi\" , \"port\" : 623 , \"place\" : 21 , \"enabled\" : true }}} { \"event_type\" : \"info_hw_state\" , \"event\" : { \"platform\" : { \"type\" : \"rpi\" , \"base\" : \"Virtual Raspberry Pi\" }, \"health\" : { \"temp\" : { \"cpu\" : 36.511 , \"gpu\" : 35.0 }, \"throttling\" : { \"raw_flags\" : 0 , \"parsed_flags\" : { \"undervoltage\" : { \"now\" : false , \"past\" : false }, \"freq_capped\" : { \"now\" : false , \"past\" : false }, \"throttled\" : { \"now\" : false , \"past\" : false }}}}}} { \"event_type\" : \"info_meta_state\" , \"event\" : { \"server\" : { \"host\" : \"localhost.localdomain\" }, \"kvm\" : {}}} { \"event_type\" : \"info_system_state\" , \"event\" : { \"kvmd\" : { \"version\" : \"1.102\" }, \"streamer\" : { \"app\" : \"ustreamer\" , \"version\" : \"1.25\" , \"features\" : { \"WITH_OMX\" : false , \"WITH_GPIO\" : false , \"WITH_PTHREAD_NP\" : true , \"WITH_SETPROCTITLE\" : true , \"HAS_PDEATHSIG\" : true }}, \"kernel\" : { \"system\" : \"Linux\" , \"release\" : \"5.8.10-arch1-1\" , \"version\" : \"#1 SMP PREEMPT Thu, 17 Sep 2020 18:01:06 +0000\" , \"machine\" : \"x86_64\" }}} { \"event_type\" : \"wol_state\" , \"event\" : { \"enabled\" : false , \"target\" : { \"ip\" : \"255.255.255.255\" , \"port\" : 9 , \"mac\" : \"\" }}} { \"event_type\" : \"gpio_state\" , \"event\" : { \"inputs\" : { \"led1\" : { \"online\" : true , \"state\" : false }, \"led2\" : { \"online\" : true , \"state\" : false }}, \"outputs\" : { \"button1\" : { \"online\" : true , \"state\" : false , \"busy\" : false }, \"button2\" : { \"online\" : true , \"state\" : false , \"busy\" : false }, \"relay1\" : { \"online\" : false , \"state\" : false , \"busy\" : false }, \"relay2\" : { \"online\" : false , \"state\" : false , \"busy\" : false }}}} { \"event_type\" : \"hid_state\" , \"event\" : { \"online\" : true , \"keyboard\" : { \"online\" : true , \"leds\" : { \"caps\" : false , \"scroll\" : false , \"num\" : false }}, \"mouse\" : { \"online\" : true }}} { \"event_type\" : \"atx_state\" , \"event\" : { \"enabled\" : true , \"busy\" : false , \"leds\" : { \"power\" : false , \"hdd\" : false }}} { \"event_type\" : \"msd_state\" , \"event\" : { \"enabled\" : true , \"online\" : true , \"busy\" : false , \"storage\" : { \"size\" : 234950152192 , \"free\" : 23514271744 , \"images\" : {}, \"uploading\" : false }, \"drive\" : { \"image\" : null , \"connected\" : false , \"cdrom\" : true }, \"features\" : { \"multi\" : true , \"cdrom\" : true }}} { \"event_type\" : \"streamer_state\" , \"event\" : { \"limits\" : { \"max_fps\" : 40 }, \"params\" : { \"desired_fps\" : 30 , \"quality\" : 80 }, \"snapshot\" : { \"saved\" : null }, \"streamer\" : null , \"features\" : { \"quality\" : true , \"resolution\" : false }}} { \"event_type\" : \"loop\" , \"event\" : {}} After connecting the client receives a bundle of states of all KVMD subsystems. After the batch is completed, it sends a loop event, which means that the websocket has entered event loop mode. Now it will send new states and respond to client's requests. Another type of event is ping , which can be sent by the client: {\"event_type\": \"ping\", \"event\": {}} . If the server is running, it will respond with pong: {\"event_type\": \"pong\", \"event\": {}} . Sending key events using Python For keypresses, set event_type to key and fill in the event structure with key and state , where key is the key from mapping and state is boolean that determines if the key is pressed or released: # python, install websocket-client import websocket uri = \"wss://10.0.0.7/api/ws?stream=0\" headers = { \"X-KVMD-User\" : \"admin\" , \"X-KVMD-Passwd\" : \"admin\" } ws = websocket . WebSocket ( sslopt = { \"cert_reqs\" : ssl . CERT_NONE }) ws . connect ( uri , header = headers ) ws . send ( '{\"event_type\": \"key\", \"event\": {\"key\": \"Enter\", \"state\": true}}' ) time . sleep ( 0.05 ) ws . send ( '{\"event_type\": \"key\", \"event\": {\"key\": \"Enter\", \"state\": false}}' ) ws . close () System functions \u00b6 Get system info \u00b6 The GET /api/info handle returns the general information about the PiKVM device. Parameters: fields=... (optional) - Only specified categories will be returned, for example fields=system,hw . By default all categories will be displayed. $ curl -k -u admin:admin https://<pikvm-ip>/api/info Click to expand { \"ok\" : true , \"result\" : { \"extras\" : { // Installed applications; null on internal error \"ipmi\" : { \"daemon\" : \"kvmd-ipmi\" , \"description\" : \"Show IPMI information\" , \"enabled\" : true , \"icon\" : \"share/svg/ipmi.svg\" , \"keyboard_cap\" : false , \"name\" : \"IPMI\" , \"path\" : \"ipmi\" , \"place\" : 21 , \"port\" : 623 }, \"vnc\" : { \"daemon\" : \"kvmd-vnc\" , \"description\" : \"Show VNC information\" , \"enabled\" : true , \"icon\" : \"share/svg/vnc.svg\" , \"keyboard_cap\" : false , \"name\" : \"VNC\" , \"path\" : \"vnc\" , \"place\" : 20 , \"port\" : 5900 } }, \"hw\" : { // Hardware info \"health\" : { \"temp\" : { \"cpu\" : 36.511 , // /sys/class/thermal/thermal_zone0/temp / 1000; null on error \"gpu\" : 35.0 // vcgencmd measure_temp; null on error }, \"throttling\" : { // vcgencmd get_throttled; null on error \"parsed_flags\" : { \"freq_capped\" : { \"now\" : false , \"past\" : false }, \"throttled\" : { \"now\" : false , \"past\" : false }, \"undervoltage\" : { \"now\" : false , \"past\" : false } }, \"raw_flags\" : 0 } }, \"platform\" : { \"base\" : \"Raspberry Pi 4 Model B Rev 1.1\" , // /proc/device-tree/model; null on error \"type\" : \"rpi\" } }, \"meta\" : { // /etc/kvmd/meta.yaml; null on error \"kvm\" : {}, \"server\" : { \"host\" : \"localhost.localdomain\" } }, \"system\" : { \"kernel\" : { \"machine\" : \"x86_64\" , \"release\" : \"5.8.14-arch1-1\" , \"system\" : \"Linux\" , \"version\" : \"#1 SMP PREEMPT Wed, 07 Oct 2020 23:59:46 +0000\" }, \"kvmd\" : { \"version\" : \"2.1\" }, \"streamer\" : { \"app\" : \"ustreamer\" , \"features\" : { // {} on error \"HAS_PDEATHSIG\" : true , \"WITH_GPIO\" : false , \"WITH_OMX\" : false , \"WITH_PTHREAD_NP\" : true , \"WITH_SETPROCTITLE\" : true }, \"version\" : \"2.1\" // \"\" on error } } } } Each category is represented by its own event in the websocket ( info_hw_state , info_system_state , etc). The event content has the same format as the category content in API. Get system log \u00b6 The GET /api/log handle displays logs from all KVMD services as plain text. Parameters: follow=1 (optional) - Turns the request into long-polling mode and follow log messages in real time. seek=N (optional) - Runs the log for the specified time in seconds, for example seek=3600 will show the log for the last hour. $ curl -k -u admin:admin https://<pikvm-ip>/api/log ATX power management \u00b6 Get ATX state \u00b6 The GET /api/atx handle shows the current ATX state. $ curl -k -u admin:admin https://<pikvm-ip>/api/atx Click to expand { \"ok\" : true , \"result\" : { \"busy\" : false , // True if ATX is busy performing an operation and does not accept commands \"enabled\" : true , \"leds\" : { \"hdd\" : false , \"power\" : false } } } Set ATX power \u00b6 The POST /api/atx/power handle changes ATX power state to desired. Parameters: action=... - Describes desired state: on - Turn on (do nothing in case PSU is already on). off - Turn off (aka soft-off), emulates click on the power button. off_hard - Perform long press on the power button (5+ seconds). reset_hard - Emulates pressing reset button (hardware hot reset). wait=1 (optional) - Says if call should return immediately or just after finishing operation. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/atx/power?action=on Click ATX button \u00b6 The POST /api/atx/click handle sends the ATX button press event. Parameters: button=... - Specifies the desired PC case button: power - Short click on the power button. power_long - Long press on the power button (5+ seconds). reset - Short click on the reset button. wait=1 (Optional) - Says if call should return immediately or just after finishing operation. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/atx/click?button=power Mass Storage Drive \u00b6 Get MSD state \u00b6 The GET /api/msd handle shows the current MSD state. $ curl -k -u admin:admin https://<pikvm-ip>/api/msd Upload MSD image \u00b6 The POST /api/msd/write uploads an image to MSD. Parameters: image=... - Specifies the name of the image. Binary data should be passed to the POST body. $ # create a test image $ dd if=/dev/zero of=test.iso bs=1M count=1 $ # upload it to pikvm $ curl -v -X POST --data-binary @test.iso -k -u admin:admin https://<pikvm-ip>/api/msd/write?image=test.iso Upload MSD image by URL \u00b6 The POST /api/msd/write_remote handle downloads an image from HTTP(S) URL to the MSD. Parameters: url=... - Image URL. image=... (optional) - Image name. timeout=N (optional) - Remote request timeout, 10 seconds by default. Note This is a long-polling request. Do not interrupt the request until the download is complete, otherwise the download will stop. $ # create test image $ dd if=/dev/zero of=test.iso bs=1M count=1 $ # upload it to pikvm $ curl -v -X POST -k -u admin:admin https://<pikvm-ip>/api/msd/write_remote?url=http://example.com/test.iso Set MSD parameters \u00b6 The POST /api/msd/set_params handle changes the current image and/or set drive parameters Parameters: image=... (optional) - Change the current image. cdrom=1|0 (optional) - Change the media type to the CD-ROM on 1 , otherwise to the Flash. $ curl -X POST -k -u admin:admin \"https://<pikvm-ip>/api/msd/set_params?image=test.iso&cdrom=1\" Control MSD \u00b6 The POST /api/msd/set_connected connects or disconnect the MSD to the host. Parameters: connected=1|0 - Change the state. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/msd/set_connected?connected=1 Remove MSD image \u00b6 The POST /api/msd/remove handle removes the specified image. Parameters: image=... - The image name. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/msd/remove?image=test.iso Reset MSD \u00b6 The POST /api/msd/reset handle resets the drive. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/msd/reset GPIO \u00b6 Get GPIO state \u00b6 The GET /api/gpio handle shows the current GPIO state. $ curl -k -u admin:admin https://<pikvm-ip>/api/gpio Switch GPIO channel \u00b6 The POST /api/gpio/switch handle interacts with selected GPIO driver channel in switch mode. Parameters: channel=... - The GPIO driver channel. state=1|0 - The new switch state. wait=1 (optional) - Says if call should return immediately or just after finishing operation. Pulse GPIO channel \u00b6 The POST /api/gpio/pulse handle interacts with selected GPIO driver channel in pulse mode. Parameters: channel=... - The GPIO driver channel. delay=N.N (optional) - The pulse time in seconds (float), 0 for default delay. wait=1 (optional) - Says if call should return immediately or just after finishing operation. Misc \u00b6 Get Prometheus metrics \u00b6 The GET /api/export/prometheus/metrics handle returns the Prometheus metrics. Also see here for details. $ curl -k -u admin:admin https://<pikvm-ip>/api/export/prometheus/metrics To be continued ===> \u00b6 You can find all existing APIs in the KVMD source tree . We would appreciate your help with documentation.","title":"HTTP API reference"},{"location":"api/#api","text":"This document describes the PiKVM API. Since the system consists of microservices, here is a common API with a common entry point provided by Nginx. The examples above use curl and websocat with the -k option to disable SSL certificate verification, since the self-signed certificateis used in the default installation.","title":"API"},{"location":"api/#authorization","text":"All APIs are restricted to authorization. To make requests, you either need to authorize each request individually, or get a token and pass it as a cookie with each request.","title":"Authorization"},{"location":"api/#single-request-auth","text":"There are two options here: Using X-headers. Just pass X-KVMD-User and X-KVMD-Passwd with the request: $ curl -k -H X-KVMD-User:admin -H X-KVMD-Passwd:admin https://<pikvm-ip>/api/auth/check Using HTTP Basic Auth. Please note: contrary to the standard, this method DOES NOT use the WWW-Authenticate header. HTTP Basic Auth in this implementation is intended only for compatibility with other systems, such as Prometheus . $ curl -k -u admin:admin https://<pikvm-ip>/api/auth/check","title":"Single request auth"},{"location":"api/#session-based-cookie-auth","text":"Authorize and get token for the user using POST /api/auth/login : $ curl -k -v -X POST --data user=admin --data passwd=admin https://pikvm/api/auth/login ... < Set-Cookie: auth_token=796cb83b11de4fcb749bc1bad14a91fb06dede84672b2f847fef1e988e6900de; Path=/ ... On success the cookie auth_token will be received with 200 OK . On invalid user or password you will get 403 Forbidden . The handle GET /api/auth/check can be used for check the auth status. Return of 200 OK will signal that user is authenticated. If the token or any of the single-request auth methods are missing, 401 Unauthorized will be returned. In case of incorrect credentials or token, 403 Forbidden will be returned. The handle POST /api/auth/logout can be used to invalidate session token. The response codes will be similar to the previous handle.","title":"Session-based cookie auth"},{"location":"api/#websocket-events","text":"Most of the data during the user's work with pikvm is transmitted over WebSocket. This includes mouse events, keyboard input, change the state of the various subsystems (such as ATX and Mass Storage Drive). Each event type will be described in the corresponding paragraph for its component. When connecting via WebSocket, the client receives current states as separate events. Then, as the states change, it will receive new events. In a normal situation, opening a socket session triggers the video streamer to start. The streamer works as long as there is at least one client connected via WebSocket. After the last connection is closed and the client timeout expires, the streamer will also be terminated. It is possible create a session that will not start the streamer and will not be counted when counting clients to stop the streamer. To do this, use the URL parameter stream=0 : $ websocat -k wss://<pikvm-ip>/api/ws?stream=0 -H X-KVMD-User:admin -H X-KVMD-Passwd:admin Output with initial events { \"event_type\" : \"gpio_model_state\" , \"event\" : { \"scheme\" : { \"inputs\" : { \"led1\" : { \"hw\" : { \"driver\" : \"__gpio__\" , \"pin\" : 19 }}, \"led2\" : { \"hw\" : { \"driver\" : \"__gpio__\" , \"pin\" : 16 }}}, \"outputs\" : { \"button1\" : { \"switch\" : false , \"pulse\" : { \"delay\" : 0.1 , \"min_delay\" : 0.1 , \"max_delay\" : 0.1 }, \"hw\" : { \"driver\" : \"__gpio__\" , \"pin\" : 26 }}, \"button2\" : { \"switch\" : false , \"pulse\" : { \"delay\" : 0.1 , \"min_delay\" : 0.1 , \"max_delay\" : 0.1 }, \"hw\" : { \"driver\" : \"__gpio__\" , \"pin\" : 20 }}, \"relay1\" : { \"switch\" : true , \"pulse\" : { \"delay\" : 0.1 , \"min_delay\" : 0.1 , \"max_delay\" : 0.1 }, \"hw\" : { \"driver\" : \"relay\" , \"pin\" : 0 }}, \"relay2\" : { \"switch\" : true , \"pulse\" : { \"delay\" : 2.0 , \"min_delay\" : 0.1 , \"max_delay\" : 5.0 }, \"hw\" : { \"driver\" : \"relay\" , \"pin\" : 1 }}}}, \"view\" : { \"header\" : { \"title\" : \"Switches\" }, \"table\" : [[{ \"type\" : \"label\" , \"text\" : \"Generic GPIO leds\" }], null , [{ \"type\" : \"label\" , \"text\" : \"Test 1:\" }, { \"type\" : \"input\" , \"channel\" : \"led1\" , \"color\" : \"green\" }, { \"type\" : \"output\" , \"channel\" : \"button1\" , \"text\" : \"Click\" }], [{ \"type\" : \"label\" , \"text\" : \"Test 2:\" }, { \"type\" : \"input\" , \"channel\" : \"led2\" , \"color\" : \"green\" }, { \"type\" : \"output\" , \"channel\" : \"button2\" , \"text\" : \"Click\" }], null , [{ \"type\" : \"label\" , \"text\" : \"HID Relays /dev/hidraw0\" }], null , [{ \"type\" : \"label\" , \"text\" : \"Relay #1:\" }, { \"type\" : \"output\" , \"channel\" : \"relay1\" , \"text\" : \"Boop 0.1\" }], [{ \"type\" : \"label\" , \"text\" : \"Relay #2:\" }, { \"type\" : \"output\" , \"channel\" : \"relay2\" , \"text\" : \"Boop 2.0\" }]]}}} { \"event_type\" : \"info_extras_state\" , \"event\" : { \"vnc\" : { \"name\" : \"VNC\" , \"description\" : \"Show VNC information\" , \"icon\" : \"share/svg/vnc.svg\" , \"path\" : \"vnc\" , \"keyboard_cap\" : false , \"daemon\" : \"kvmd-vnc\" , \"port\" : 5900 , \"place\" : 20 , \"enabled\" : true }, \"ipmi\" : { \"name\" : \"IPMI\" , \"description\" : \"Show IPMI information\" , \"icon\" : \"share/svg/ipmi.svg\" , \"path\" : \"ipmi\" , \"keyboard_cap\" : false , \"daemon\" : \"kvmd-ipmi\" , \"port\" : 623 , \"place\" : 21 , \"enabled\" : true }}} { \"event_type\" : \"info_hw_state\" , \"event\" : { \"platform\" : { \"type\" : \"rpi\" , \"base\" : \"Virtual Raspberry Pi\" }, \"health\" : { \"temp\" : { \"cpu\" : 36.511 , \"gpu\" : 35.0 }, \"throttling\" : { \"raw_flags\" : 0 , \"parsed_flags\" : { \"undervoltage\" : { \"now\" : false , \"past\" : false }, \"freq_capped\" : { \"now\" : false , \"past\" : false }, \"throttled\" : { \"now\" : false , \"past\" : false }}}}}} { \"event_type\" : \"info_meta_state\" , \"event\" : { \"server\" : { \"host\" : \"localhost.localdomain\" }, \"kvm\" : {}}} { \"event_type\" : \"info_system_state\" , \"event\" : { \"kvmd\" : { \"version\" : \"1.102\" }, \"streamer\" : { \"app\" : \"ustreamer\" , \"version\" : \"1.25\" , \"features\" : { \"WITH_OMX\" : false , \"WITH_GPIO\" : false , \"WITH_PTHREAD_NP\" : true , \"WITH_SETPROCTITLE\" : true , \"HAS_PDEATHSIG\" : true }}, \"kernel\" : { \"system\" : \"Linux\" , \"release\" : \"5.8.10-arch1-1\" , \"version\" : \"#1 SMP PREEMPT Thu, 17 Sep 2020 18:01:06 +0000\" , \"machine\" : \"x86_64\" }}} { \"event_type\" : \"wol_state\" , \"event\" : { \"enabled\" : false , \"target\" : { \"ip\" : \"255.255.255.255\" , \"port\" : 9 , \"mac\" : \"\" }}} { \"event_type\" : \"gpio_state\" , \"event\" : { \"inputs\" : { \"led1\" : { \"online\" : true , \"state\" : false }, \"led2\" : { \"online\" : true , \"state\" : false }}, \"outputs\" : { \"button1\" : { \"online\" : true , \"state\" : false , \"busy\" : false }, \"button2\" : { \"online\" : true , \"state\" : false , \"busy\" : false }, \"relay1\" : { \"online\" : false , \"state\" : false , \"busy\" : false }, \"relay2\" : { \"online\" : false , \"state\" : false , \"busy\" : false }}}} { \"event_type\" : \"hid_state\" , \"event\" : { \"online\" : true , \"keyboard\" : { \"online\" : true , \"leds\" : { \"caps\" : false , \"scroll\" : false , \"num\" : false }}, \"mouse\" : { \"online\" : true }}} { \"event_type\" : \"atx_state\" , \"event\" : { \"enabled\" : true , \"busy\" : false , \"leds\" : { \"power\" : false , \"hdd\" : false }}} { \"event_type\" : \"msd_state\" , \"event\" : { \"enabled\" : true , \"online\" : true , \"busy\" : false , \"storage\" : { \"size\" : 234950152192 , \"free\" : 23514271744 , \"images\" : {}, \"uploading\" : false }, \"drive\" : { \"image\" : null , \"connected\" : false , \"cdrom\" : true }, \"features\" : { \"multi\" : true , \"cdrom\" : true }}} { \"event_type\" : \"streamer_state\" , \"event\" : { \"limits\" : { \"max_fps\" : 40 }, \"params\" : { \"desired_fps\" : 30 , \"quality\" : 80 }, \"snapshot\" : { \"saved\" : null }, \"streamer\" : null , \"features\" : { \"quality\" : true , \"resolution\" : false }}} { \"event_type\" : \"loop\" , \"event\" : {}} After connecting the client receives a bundle of states of all KVMD subsystems. After the batch is completed, it sends a loop event, which means that the websocket has entered event loop mode. Now it will send new states and respond to client's requests. Another type of event is ping , which can be sent by the client: {\"event_type\": \"ping\", \"event\": {}} . If the server is running, it will respond with pong: {\"event_type\": \"pong\", \"event\": {}} . Sending key events using Python For keypresses, set event_type to key and fill in the event structure with key and state , where key is the key from mapping and state is boolean that determines if the key is pressed or released: # python, install websocket-client import websocket uri = \"wss://10.0.0.7/api/ws?stream=0\" headers = { \"X-KVMD-User\" : \"admin\" , \"X-KVMD-Passwd\" : \"admin\" } ws = websocket . WebSocket ( sslopt = { \"cert_reqs\" : ssl . CERT_NONE }) ws . connect ( uri , header = headers ) ws . send ( '{\"event_type\": \"key\", \"event\": {\"key\": \"Enter\", \"state\": true}}' ) time . sleep ( 0.05 ) ws . send ( '{\"event_type\": \"key\", \"event\": {\"key\": \"Enter\", \"state\": false}}' ) ws . close ()","title":"WebSocket events"},{"location":"api/#system-functions","text":"","title":"System functions"},{"location":"api/#get-system-info","text":"The GET /api/info handle returns the general information about the PiKVM device. Parameters: fields=... (optional) - Only specified categories will be returned, for example fields=system,hw . By default all categories will be displayed. $ curl -k -u admin:admin https://<pikvm-ip>/api/info Click to expand { \"ok\" : true , \"result\" : { \"extras\" : { // Installed applications; null on internal error \"ipmi\" : { \"daemon\" : \"kvmd-ipmi\" , \"description\" : \"Show IPMI information\" , \"enabled\" : true , \"icon\" : \"share/svg/ipmi.svg\" , \"keyboard_cap\" : false , \"name\" : \"IPMI\" , \"path\" : \"ipmi\" , \"place\" : 21 , \"port\" : 623 }, \"vnc\" : { \"daemon\" : \"kvmd-vnc\" , \"description\" : \"Show VNC information\" , \"enabled\" : true , \"icon\" : \"share/svg/vnc.svg\" , \"keyboard_cap\" : false , \"name\" : \"VNC\" , \"path\" : \"vnc\" , \"place\" : 20 , \"port\" : 5900 } }, \"hw\" : { // Hardware info \"health\" : { \"temp\" : { \"cpu\" : 36.511 , // /sys/class/thermal/thermal_zone0/temp / 1000; null on error \"gpu\" : 35.0 // vcgencmd measure_temp; null on error }, \"throttling\" : { // vcgencmd get_throttled; null on error \"parsed_flags\" : { \"freq_capped\" : { \"now\" : false , \"past\" : false }, \"throttled\" : { \"now\" : false , \"past\" : false }, \"undervoltage\" : { \"now\" : false , \"past\" : false } }, \"raw_flags\" : 0 } }, \"platform\" : { \"base\" : \"Raspberry Pi 4 Model B Rev 1.1\" , // /proc/device-tree/model; null on error \"type\" : \"rpi\" } }, \"meta\" : { // /etc/kvmd/meta.yaml; null on error \"kvm\" : {}, \"server\" : { \"host\" : \"localhost.localdomain\" } }, \"system\" : { \"kernel\" : { \"machine\" : \"x86_64\" , \"release\" : \"5.8.14-arch1-1\" , \"system\" : \"Linux\" , \"version\" : \"#1 SMP PREEMPT Wed, 07 Oct 2020 23:59:46 +0000\" }, \"kvmd\" : { \"version\" : \"2.1\" }, \"streamer\" : { \"app\" : \"ustreamer\" , \"features\" : { // {} on error \"HAS_PDEATHSIG\" : true , \"WITH_GPIO\" : false , \"WITH_OMX\" : false , \"WITH_PTHREAD_NP\" : true , \"WITH_SETPROCTITLE\" : true }, \"version\" : \"2.1\" // \"\" on error } } } } Each category is represented by its own event in the websocket ( info_hw_state , info_system_state , etc). The event content has the same format as the category content in API.","title":"Get system info"},{"location":"api/#get-system-log","text":"The GET /api/log handle displays logs from all KVMD services as plain text. Parameters: follow=1 (optional) - Turns the request into long-polling mode and follow log messages in real time. seek=N (optional) - Runs the log for the specified time in seconds, for example seek=3600 will show the log for the last hour. $ curl -k -u admin:admin https://<pikvm-ip>/api/log","title":"Get system log"},{"location":"api/#atx-power-management","text":"","title":"ATX power management"},{"location":"api/#get-atx-state","text":"The GET /api/atx handle shows the current ATX state. $ curl -k -u admin:admin https://<pikvm-ip>/api/atx Click to expand { \"ok\" : true , \"result\" : { \"busy\" : false , // True if ATX is busy performing an operation and does not accept commands \"enabled\" : true , \"leds\" : { \"hdd\" : false , \"power\" : false } } }","title":"Get ATX state"},{"location":"api/#set-atx-power","text":"The POST /api/atx/power handle changes ATX power state to desired. Parameters: action=... - Describes desired state: on - Turn on (do nothing in case PSU is already on). off - Turn off (aka soft-off), emulates click on the power button. off_hard - Perform long press on the power button (5+ seconds). reset_hard - Emulates pressing reset button (hardware hot reset). wait=1 (optional) - Says if call should return immediately or just after finishing operation. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/atx/power?action=on","title":"Set ATX power"},{"location":"api/#click-atx-button","text":"The POST /api/atx/click handle sends the ATX button press event. Parameters: button=... - Specifies the desired PC case button: power - Short click on the power button. power_long - Long press on the power button (5+ seconds). reset - Short click on the reset button. wait=1 (Optional) - Says if call should return immediately or just after finishing operation. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/atx/click?button=power","title":"Click ATX button"},{"location":"api/#mass-storage-drive","text":"","title":"Mass Storage Drive"},{"location":"api/#get-msd-state","text":"The GET /api/msd handle shows the current MSD state. $ curl -k -u admin:admin https://<pikvm-ip>/api/msd","title":"Get MSD state"},{"location":"api/#upload-msd-image","text":"The POST /api/msd/write uploads an image to MSD. Parameters: image=... - Specifies the name of the image. Binary data should be passed to the POST body. $ # create a test image $ dd if=/dev/zero of=test.iso bs=1M count=1 $ # upload it to pikvm $ curl -v -X POST --data-binary @test.iso -k -u admin:admin https://<pikvm-ip>/api/msd/write?image=test.iso","title":"Upload MSD image"},{"location":"api/#upload-msd-image-by-url","text":"The POST /api/msd/write_remote handle downloads an image from HTTP(S) URL to the MSD. Parameters: url=... - Image URL. image=... (optional) - Image name. timeout=N (optional) - Remote request timeout, 10 seconds by default. Note This is a long-polling request. Do not interrupt the request until the download is complete, otherwise the download will stop. $ # create test image $ dd if=/dev/zero of=test.iso bs=1M count=1 $ # upload it to pikvm $ curl -v -X POST -k -u admin:admin https://<pikvm-ip>/api/msd/write_remote?url=http://example.com/test.iso","title":"Upload MSD image by URL"},{"location":"api/#set-msd-parameters","text":"The POST /api/msd/set_params handle changes the current image and/or set drive parameters Parameters: image=... (optional) - Change the current image. cdrom=1|0 (optional) - Change the media type to the CD-ROM on 1 , otherwise to the Flash. $ curl -X POST -k -u admin:admin \"https://<pikvm-ip>/api/msd/set_params?image=test.iso&cdrom=1\"","title":"Set MSD parameters"},{"location":"api/#control-msd","text":"The POST /api/msd/set_connected connects or disconnect the MSD to the host. Parameters: connected=1|0 - Change the state. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/msd/set_connected?connected=1","title":"Control MSD"},{"location":"api/#remove-msd-image","text":"The POST /api/msd/remove handle removes the specified image. Parameters: image=... - The image name. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/msd/remove?image=test.iso","title":"Remove MSD image"},{"location":"api/#reset-msd","text":"The POST /api/msd/reset handle resets the drive. $ curl -X POST -k -u admin:admin https://<pikvm-ip>/api/msd/reset","title":"Reset MSD"},{"location":"api/#gpio","text":"","title":"GPIO"},{"location":"api/#get-gpio-state","text":"The GET /api/gpio handle shows the current GPIO state. $ curl -k -u admin:admin https://<pikvm-ip>/api/gpio","title":"Get GPIO state"},{"location":"api/#switch-gpio-channel","text":"The POST /api/gpio/switch handle interacts with selected GPIO driver channel in switch mode. Parameters: channel=... - The GPIO driver channel. state=1|0 - The new switch state. wait=1 (optional) - Says if call should return immediately or just after finishing operation.","title":"Switch GPIO channel"},{"location":"api/#pulse-gpio-channel","text":"The POST /api/gpio/pulse handle interacts with selected GPIO driver channel in pulse mode. Parameters: channel=... - The GPIO driver channel. delay=N.N (optional) - The pulse time in seconds (float), 0 for default delay. wait=1 (optional) - Says if call should return immediately or just after finishing operation.","title":"Pulse GPIO channel"},{"location":"api/#misc","text":"","title":"Misc"},{"location":"api/#get-prometheus-metrics","text":"The GET /api/export/prometheus/metrics handle returns the Prometheus metrics. Also see here for details. $ curl -k -u admin:admin https://<pikvm-ip>/api/export/prometheus/metrics","title":"Get Prometheus metrics"},{"location":"api/#to-be-continued","text":"You can find all existing APIs in the KVMD source tree . We would appreciate your help with documentation.","title":"To be continued ===&gt;"},{"location":"arduino_hid/","text":"Using Arduino HID on non-v0 platform \u00b6 This is useful if you need a simple and primitive keyboard/mouse emulator device. For example when used with a hardware KVM switch which does not recognize composite HID . You can also use the Arduino HID to emulate the PS/2 keyboard. Serial HID \u00b6 PiKVM v3 HAT note Don't use it, use SPI HID for v3. Otherwise, you won't be able to use the Serial console. USB keyboard and mouse \u00b6 Get some parts Arduino Pro Micro (based on an ATMega32u4). Logic level shifter . 1x NPN transistor (almost any NPN transistor: 2n2222 or similar). 1x 390 Ohm resistor. A breadboard and wires. Build the Arduino HID according to the scheme Power up PiKVM and switch it to RW-mode using command rw . Add these lines to /etc/kvmd/override.yaml : kvmd : hid : type : serial reset_pin : 4 device : /dev/kvmd-hid Create file /etc/udev/rules.d/99-kvmd-extra.rules : KERNEL==\"ttyAMA0\", SYMLINK+=\"kvmd-hid\" Run systemctl disable getty@ttyAMA0.service . Remove console=ttyAMA0,115200 or console=serial0,115200 and kgdboc=ttyAMA0,115200 or kgdboc=serial0,115200 from /boot/cmdline.txt . Flash the Arduino HID . Perform reboot . PS/2 keyboard \u00b6 Using the PS/2 firmware currently have some limitations: The possibility of using the switchable USB HID is excluded. PS/2 mouse is not supported right now (but it will). Both of these problems will be solved in the nearest future and the two different firmware versions will be combined into one universal one. To select the PS/2 firmware, follow the instructions for the USB , but with one exception: Before make you will need to edit file platformio.ini Open the file and find these lines: [_common] build_flags = -DHID_PS2_KBD_CLOCK_PIN = 7 -DHID_PS2_KBD_DATA_PIN = 5 -DHID_USB_CHECK_ENDPOINT # ----- The default config with dynamic switching ----- -DHID_DYNAMIC -DHID_WITH_USB -DHID_SET_USB_KBD -DHID_SET_USB_MOUSE_ABS # ----- PS2 keyboard only ----- # -DHID_WITH_PS2 # -DHID_SET_PS2_KBD # ----- PS2 keyboard + USB absolute mouse ----- # -DHID_WITH_USB # -DHID_WITH_PS2 # -DHID_SET_PS2_KBD # -DHID_SET_USB_MOUSE_ABS # ----- PS2 keyboard + USB relative mouse ----- # -DHID_WITH_USB # -DHID_WITH_PS2 # -DHID_SET_PS2_KBD # -DHID_SET_USB_MOUSE_REL By default, the firmware works with USB HID and supports dynamic mode switching. You can choose one of the other modes by commenting some lines and uncommenting others. This example to use a USB mouse and PS/2 keyboard: ... # ----- The default config with dynamic switching ----- # -DHID_DYNAMIC # -DHID_WITH_USB # -DHID_SET_USB_KBD # -DHID_SET_USB_MOUSE_ABS # ----- PS2 keyboard only ----- ... # ----- PS2 keyboard + USB absolute mouse ----- -DHID_WITH_USB -DHID_WITH_PS2 -DHID_SET_PS2_KBD -DHID_SET_USB_MOUSE_ABS # ----- PS2 keyboard + USB relative mouse ----- ... Next, connect Arduino pins to the female PS/2 port of your motherboard. Choose the purple port. If your motherboard only have one port, it's probably universal and can be used either for the keyboard or for the mouse. Most likely, it is painted in two colors: green and purple. You can use it either. Follow the diagram Female PS/2 port (front view) Pinout Arduino pin 7 <-> PS/2 CLOCK Arduino pin 5 <-> PS/2 DATA Arduino GND pin <-> PS/2 GND Warning Connect VIN pin of Arduino to any Raspberry's 5v pin for PS/2 only device. But you don't need to connect the Arduino VIN pin if you connected USB (Arduino will get power through it). SPI HID \u00b6 Using an SPI connection, an Arduino Micro (not Pro) or compatible can be flashed from the Pi and used as an HID keyboard and mouse. Unlike UART, SPI does not share pins with Bluetooth on the Raspberry Pi so the Bluetooth radio does not need to be disabled. Before powering either device, double-check the connections. The following should be wired from the Pi to either the level shifter or the Arduino. While the Arduino tolerates 3.3V logic input, 5V outputs from the Arduino can damage or destroy the Raspberry Pi and must not be connected directly to 3.3V GPIO pins directly. Parts list \u00b6 There are very few parts needed besides the Raspberry Pi to build the solution. Some parts may be purchased with or without headers, if headers are not pre-soldered, it may be necessary to order some breakaway header strips and solder them to the boards prior to assembly unless the wires will be soldered directly to the boards. Raspberry Pi Zero W or Pi 4 are the most popular boards for this solution, pre-soldered headers recommended Arduino Micro (or compatible) microcontroller board with pre-soldered headers recommended Logic Level Converter. This may be RX/TX, Bidirectional, or Single Supply Dupont wires (female to male pin) recommended for breadboard or other suitable means of making the connections Optional: Breakaway headers for the logic level converter Optional: Breadboard large enough to accomodate the parts Optional: Header pins for connection to a breadboard Note A smaller \"Pro Micro\" board is available in a 3.3V model but the SS connection (RX_LED) is not available as a separate pin or solderable hole. If using this board, a jumper wire can be soldered to the resistor for the RX_LED but there is risk of burning the resistor, the LED, the board, or other components in the process. Advantages of this board include not requiring a logic level converter and reduced breadboard or board space for building the solution. List of connections to be made \u00b6 For the primary functionality, most connections are made using a 4-channel bidirectional level shifter Pi 3v3 to LV on the level shifter Pi Ground to LV GND Arduino GND to HV GND GPIO10 (MOSI) via the level shifter to MOSI on the Arduino GPIO9 (MISO) via the level shifter to MISO on the Arduino GPIO11 (SPIO_SCLK) via the level shifter to SCK on the Arduino GPIO7 (SPIO_CE1_N) via the level shifter to SS (or RX_LED) on the Arduino An additional circuit is used with a transistor to reset the HID for mode changes and for SPI programming as follows: GPIO25 to PNP base on transistor PNP emitter to ground PNP collector to RST on the Arduino Pictures of this setup are also available in full resolution for download to assist for both the Raspberry Pi and the Arduino board. A smaller version of the images has been included on this page and can be downloaded. Raspberry Pi Closeup Breadboard with Arduino Programming assumes the Arduino is powered via USB, either from the connected host or the Pi itself. If the USB is not connected, 5 V may be provided by the Raspberry Pi GPIO but should be disconnected prior to connecting USB to the Arduino's USB port. The Raspberry Pi does not have backcurrent protection, a circuit using one or more Schottky diodes can be built to OR power from multiple sources but it's easier and more cost effective to avoid conflict and voltage differences between power supplies by leaving the 5 V wire disconnected. Preparing the installation for SPI devices and programming \u00b6 As of the latest package release, the kdmd service supports SPI. It should be sufficient to ensure the packages are up-to-date with the latest release, the programmer is installed, and the SPI device overlay is loaded at boot. Switch the filesystem to read-write mode with rw Update the system with pacman -Syu for the latest packages Install the avrdude programmer with pacman -S avrdude-svn Add dtoverlay=spi0-1cs to /boot/config.txt Reboot with reboot or systemctl reboot Flashing the Arduino \u00b6 Instructions on flashing the Arduino can be found on the page Flash the Arduino HID . If programming fails, ensure the Arduino is powered and check the wiring again. If there is a misconfiguration, power off the Pi and the Arduino, correct the wiring, and try again. Note it is not recommended or required to supply 5V power from the Raspberry Pi if the Arduino is USB powered, if the issue appears to be power related it may be removed from the solution and replaced with a powered USB connection if it will aid in troubleshooting but check all other wires first to ensure there are no shorts. Wiring problems are a common issue but there could be other reasons for programming not to complete. While it is not possible to list every possible problem and solution here, there is an active user community in our Discord with others familiar with the solution and willing to help. Enable the SPI configuration and restart kvmd \u00b6 Once the installation has completed, all that should remain is to add the following configuration to /etc/kvmd/override.yaml and restart the kvmd service. If the first line exists due to existing overrides, omit that line and either add or update the hid section as appropriate. kvmd : hid : type : spi chip : 0 bus : 0 sw_cs_pin : 7 reset_pin : 25 reset_inverted : true After saving the changes to /etc/kvmd/override.yaml , restart kvmd and clear your browser cache. The command to restart kvmd is # systemctl restart kvmd If your device is still in read-write mode, ro will put the SD back in read-only mode. Fixing the USB absolute mouse on Windows 98 \u00b6 Due to an ancient buggy driver, the USB absolute mouse on Windows 98 moves only within the upper-left quarter of the screen. To fix this, just recompile the firmware with uncommented flag -DHID_WITH_USB_WIN98 in platformio.ini .","title":"Arduino HID (USB, PS/2)"},{"location":"arduino_hid/#using-arduino-hid-on-non-v0-platform","text":"This is useful if you need a simple and primitive keyboard/mouse emulator device. For example when used with a hardware KVM switch which does not recognize composite HID . You can also use the Arduino HID to emulate the PS/2 keyboard.","title":"Using Arduino HID on non-v0 platform"},{"location":"arduino_hid/#serial-hid","text":"PiKVM v3 HAT note Don't use it, use SPI HID for v3. Otherwise, you won't be able to use the Serial console.","title":"Serial HID"},{"location":"arduino_hid/#usb-keyboard-and-mouse","text":"Get some parts Arduino Pro Micro (based on an ATMega32u4). Logic level shifter . 1x NPN transistor (almost any NPN transistor: 2n2222 or similar). 1x 390 Ohm resistor. A breadboard and wires. Build the Arduino HID according to the scheme Power up PiKVM and switch it to RW-mode using command rw . Add these lines to /etc/kvmd/override.yaml : kvmd : hid : type : serial reset_pin : 4 device : /dev/kvmd-hid Create file /etc/udev/rules.d/99-kvmd-extra.rules : KERNEL==\"ttyAMA0\", SYMLINK+=\"kvmd-hid\" Run systemctl disable getty@ttyAMA0.service . Remove console=ttyAMA0,115200 or console=serial0,115200 and kgdboc=ttyAMA0,115200 or kgdboc=serial0,115200 from /boot/cmdline.txt . Flash the Arduino HID . Perform reboot .","title":"USB keyboard and mouse"},{"location":"arduino_hid/#ps2-keyboard","text":"Using the PS/2 firmware currently have some limitations: The possibility of using the switchable USB HID is excluded. PS/2 mouse is not supported right now (but it will). Both of these problems will be solved in the nearest future and the two different firmware versions will be combined into one universal one. To select the PS/2 firmware, follow the instructions for the USB , but with one exception: Before make you will need to edit file platformio.ini Open the file and find these lines: [_common] build_flags = -DHID_PS2_KBD_CLOCK_PIN = 7 -DHID_PS2_KBD_DATA_PIN = 5 -DHID_USB_CHECK_ENDPOINT # ----- The default config with dynamic switching ----- -DHID_DYNAMIC -DHID_WITH_USB -DHID_SET_USB_KBD -DHID_SET_USB_MOUSE_ABS # ----- PS2 keyboard only ----- # -DHID_WITH_PS2 # -DHID_SET_PS2_KBD # ----- PS2 keyboard + USB absolute mouse ----- # -DHID_WITH_USB # -DHID_WITH_PS2 # -DHID_SET_PS2_KBD # -DHID_SET_USB_MOUSE_ABS # ----- PS2 keyboard + USB relative mouse ----- # -DHID_WITH_USB # -DHID_WITH_PS2 # -DHID_SET_PS2_KBD # -DHID_SET_USB_MOUSE_REL By default, the firmware works with USB HID and supports dynamic mode switching. You can choose one of the other modes by commenting some lines and uncommenting others. This example to use a USB mouse and PS/2 keyboard: ... # ----- The default config with dynamic switching ----- # -DHID_DYNAMIC # -DHID_WITH_USB # -DHID_SET_USB_KBD # -DHID_SET_USB_MOUSE_ABS # ----- PS2 keyboard only ----- ... # ----- PS2 keyboard + USB absolute mouse ----- -DHID_WITH_USB -DHID_WITH_PS2 -DHID_SET_PS2_KBD -DHID_SET_USB_MOUSE_ABS # ----- PS2 keyboard + USB relative mouse ----- ... Next, connect Arduino pins to the female PS/2 port of your motherboard. Choose the purple port. If your motherboard only have one port, it's probably universal and can be used either for the keyboard or for the mouse. Most likely, it is painted in two colors: green and purple. You can use it either. Follow the diagram Female PS/2 port (front view) Pinout Arduino pin 7 <-> PS/2 CLOCK Arduino pin 5 <-> PS/2 DATA Arduino GND pin <-> PS/2 GND Warning Connect VIN pin of Arduino to any Raspberry's 5v pin for PS/2 only device. But you don't need to connect the Arduino VIN pin if you connected USB (Arduino will get power through it).","title":"PS/2 keyboard"},{"location":"arduino_hid/#spi-hid","text":"Using an SPI connection, an Arduino Micro (not Pro) or compatible can be flashed from the Pi and used as an HID keyboard and mouse. Unlike UART, SPI does not share pins with Bluetooth on the Raspberry Pi so the Bluetooth radio does not need to be disabled. Before powering either device, double-check the connections. The following should be wired from the Pi to either the level shifter or the Arduino. While the Arduino tolerates 3.3V logic input, 5V outputs from the Arduino can damage or destroy the Raspberry Pi and must not be connected directly to 3.3V GPIO pins directly.","title":"SPI HID"},{"location":"arduino_hid/#parts-list","text":"There are very few parts needed besides the Raspberry Pi to build the solution. Some parts may be purchased with or without headers, if headers are not pre-soldered, it may be necessary to order some breakaway header strips and solder them to the boards prior to assembly unless the wires will be soldered directly to the boards. Raspberry Pi Zero W or Pi 4 are the most popular boards for this solution, pre-soldered headers recommended Arduino Micro (or compatible) microcontroller board with pre-soldered headers recommended Logic Level Converter. This may be RX/TX, Bidirectional, or Single Supply Dupont wires (female to male pin) recommended for breadboard or other suitable means of making the connections Optional: Breakaway headers for the logic level converter Optional: Breadboard large enough to accomodate the parts Optional: Header pins for connection to a breadboard Note A smaller \"Pro Micro\" board is available in a 3.3V model but the SS connection (RX_LED) is not available as a separate pin or solderable hole. If using this board, a jumper wire can be soldered to the resistor for the RX_LED but there is risk of burning the resistor, the LED, the board, or other components in the process. Advantages of this board include not requiring a logic level converter and reduced breadboard or board space for building the solution.","title":"Parts list"},{"location":"arduino_hid/#list-of-connections-to-be-made","text":"For the primary functionality, most connections are made using a 4-channel bidirectional level shifter Pi 3v3 to LV on the level shifter Pi Ground to LV GND Arduino GND to HV GND GPIO10 (MOSI) via the level shifter to MOSI on the Arduino GPIO9 (MISO) via the level shifter to MISO on the Arduino GPIO11 (SPIO_SCLK) via the level shifter to SCK on the Arduino GPIO7 (SPIO_CE1_N) via the level shifter to SS (or RX_LED) on the Arduino An additional circuit is used with a transistor to reset the HID for mode changes and for SPI programming as follows: GPIO25 to PNP base on transistor PNP emitter to ground PNP collector to RST on the Arduino Pictures of this setup are also available in full resolution for download to assist for both the Raspberry Pi and the Arduino board. A smaller version of the images has been included on this page and can be downloaded. Raspberry Pi Closeup Breadboard with Arduino Programming assumes the Arduino is powered via USB, either from the connected host or the Pi itself. If the USB is not connected, 5 V may be provided by the Raspberry Pi GPIO but should be disconnected prior to connecting USB to the Arduino's USB port. The Raspberry Pi does not have backcurrent protection, a circuit using one or more Schottky diodes can be built to OR power from multiple sources but it's easier and more cost effective to avoid conflict and voltage differences between power supplies by leaving the 5 V wire disconnected.","title":"List of connections to be made"},{"location":"arduino_hid/#preparing-the-installation-for-spi-devices-and-programming","text":"As of the latest package release, the kdmd service supports SPI. It should be sufficient to ensure the packages are up-to-date with the latest release, the programmer is installed, and the SPI device overlay is loaded at boot. Switch the filesystem to read-write mode with rw Update the system with pacman -Syu for the latest packages Install the avrdude programmer with pacman -S avrdude-svn Add dtoverlay=spi0-1cs to /boot/config.txt Reboot with reboot or systemctl reboot","title":"Preparing the installation for SPI devices and programming"},{"location":"arduino_hid/#flashing-the-arduino","text":"Instructions on flashing the Arduino can be found on the page Flash the Arduino HID . If programming fails, ensure the Arduino is powered and check the wiring again. If there is a misconfiguration, power off the Pi and the Arduino, correct the wiring, and try again. Note it is not recommended or required to supply 5V power from the Raspberry Pi if the Arduino is USB powered, if the issue appears to be power related it may be removed from the solution and replaced with a powered USB connection if it will aid in troubleshooting but check all other wires first to ensure there are no shorts. Wiring problems are a common issue but there could be other reasons for programming not to complete. While it is not possible to list every possible problem and solution here, there is an active user community in our Discord with others familiar with the solution and willing to help.","title":"Flashing the Arduino"},{"location":"arduino_hid/#enable-the-spi-configuration-and-restart-kvmd","text":"Once the installation has completed, all that should remain is to add the following configuration to /etc/kvmd/override.yaml and restart the kvmd service. If the first line exists due to existing overrides, omit that line and either add or update the hid section as appropriate. kvmd : hid : type : spi chip : 0 bus : 0 sw_cs_pin : 7 reset_pin : 25 reset_inverted : true After saving the changes to /etc/kvmd/override.yaml , restart kvmd and clear your browser cache. The command to restart kvmd is # systemctl restart kvmd If your device is still in read-write mode, ro will put the SD back in read-only mode.","title":"Enable the SPI configuration and restart kvmd"},{"location":"arduino_hid/#fixing-the-usb-absolute-mouse-on-windows-98","text":"Due to an ancient buggy driver, the USB absolute mouse on Windows 98 moves only within the upper-left quarter of the screen. To fix this, just recompile the firmware with uncommented flag -DHID_WITH_USB_WIN98 in platformio.ini .","title":"Fixing the USB absolute mouse on Windows 98"},{"location":"audio/","text":"PiKVM V3 Audio \u00b6 This feature allows you to receive audio over an HDMI cable and transmit it to the browser in WebRTC mode. Warning This is only supported by PiKVM V3 devices right now. This may or may not work on other CSI devices as most have a hw defect. Please note the feature is experimental. Nothing will explode for you, but something may not work. Please report about problems here (preferred) or here . KVM switches may or may not work, we currently do not have a list of what works due to the feature being new/experimental. MIC support is not supported at this time, it may be supported in the future. Preparing \u00b6 Make sure that you have not removed the jumpers related to audio (4) on the V3 board and have not deleted or commented out the dtoverlay=tc358743-audio line in /boot/config.txt . Return everything as it was, if you changed it. Update the OS: # rw # pacman -Syu Edit /etc/kvmd/janus/janus.plugin.ustreamer.jcfg and add the following lines at the end: audio: { device = \"hw:0,0\" tc358743 = \"/dev/kvmd-video\" } Enable the basic audio in the EDID: # kvmd-edidconf --set-audio=yes Reboot the device: # reboot Your host will detect the possibility of audio output via HDMI. Mac OS usually connects automatically, Windows requires manual indication, Linux will require a ritual shamanic dance. In any case, make sure that the audio is output via HDMI on your host. PiKVM supports stereo mode with any standard bits and frequencies like 32/44.1/48 kHz with 16/24 bit. Open the PiKVM Web UI. Click the System menu and switch the video mode to H.264 / WebRTC . After that, the volume slider will appear under the switch. Increase it to the maximum and have fun. Warning After the page is reloaded, the audio slider will be reset. This is a technical limitation in all browsers to avoid annoying audio ads. If something doesn't work, check the log: journalctl -u kvmd-janus . Try a different browser, try and clear browser cache before reporting issues. Please report about problems here (preferred) or here .","title":"HDMI audio"},{"location":"audio/#pikvm-v3-audio","text":"This feature allows you to receive audio over an HDMI cable and transmit it to the browser in WebRTC mode. Warning This is only supported by PiKVM V3 devices right now. This may or may not work on other CSI devices as most have a hw defect. Please note the feature is experimental. Nothing will explode for you, but something may not work. Please report about problems here (preferred) or here . KVM switches may or may not work, we currently do not have a list of what works due to the feature being new/experimental. MIC support is not supported at this time, it may be supported in the future.","title":"PiKVM V3 Audio"},{"location":"audio/#preparing","text":"Make sure that you have not removed the jumpers related to audio (4) on the V3 board and have not deleted or commented out the dtoverlay=tc358743-audio line in /boot/config.txt . Return everything as it was, if you changed it. Update the OS: # rw # pacman -Syu Edit /etc/kvmd/janus/janus.plugin.ustreamer.jcfg and add the following lines at the end: audio: { device = \"hw:0,0\" tc358743 = \"/dev/kvmd-video\" } Enable the basic audio in the EDID: # kvmd-edidconf --set-audio=yes Reboot the device: # reboot Your host will detect the possibility of audio output via HDMI. Mac OS usually connects automatically, Windows requires manual indication, Linux will require a ritual shamanic dance. In any case, make sure that the audio is output via HDMI on your host. PiKVM supports stereo mode with any standard bits and frequencies like 32/44.1/48 kHz with 16/24 bit. Open the PiKVM Web UI. Click the System menu and switch the video mode to H.264 / WebRTC . After that, the volume slider will appear under the switch. Increase it to the maximum and have fun. Warning After the page is reloaded, the audio slider will be reset. This is a technical limitation in all browsers to avoid annoying audio ads. If something doesn't work, check the log: journalctl -u kvmd-janus . Try a different browser, try and clear browser cache before reporting issues. Please report about problems here (preferred) or here .","title":"Preparing"},{"location":"bluetooth_hid/","text":"Bluetooth HID \u00b6 PiKVM is able to emulate a Bluetooth keyboard & mouse. This is not the main case of using PiKVM since you still need it to pair with a remote host, but can be used for something like mobile KVM. Warning Using Bluetooth HID requires additional configuration of the operating system. For v2+, this means losing the UART port, since it will be used by Bluetooth. Also, Bluetooth operation was tested only on RPi4 and v2+ platform. Other boards may require different system service settings. Making the required changes for BT to work will also disable normal KB/MOUSE functionality therefor this will need to be disabled before normal operation can occur. Note Bluetooth mouse can work only in relative mode . The reason is that many Bluetooth host drivers do not correctly implement HID descriptors. Horizontal scrolling is not supported for the same reason. Configuring the OS \u00b6 Switch filesystem to RW-mode, perform update and install some packages: # rw # pacman -Syu # pacman -S bluez bluez-utils raspberrypi-bluetooth Edit /boot/config.txt and comment these lines: #enable_uart=1 #dtoverlay=disable-bt Create an empty directory /var/lib/bluetooth and add mountpoint to /etc/fstab : # mkdir /var/lib/bluetooth # echo 'tmpfs /var/lib/bluetooth tmpfs nodev,nosuid,mode=0755 0 0' >> /etc/fstab Override and enable the services: # mkdir /etc/systemd/system/bluetooth.service.d # cat << EOF > /etc/systemd/system/bluetooth.service.d/override.conf [Service] ExecStart= ExecStart=/usr/lib/bluetooth/bluetoothd --noplugin=* EOF # systemctl enable bluetooth # systemctl enable raspberrypi-btuart Override kvmd service: # mkdir /etc/systemd/system/kvmd.service.d # cat << EOF > /etc/systemd/system/kvmd.service.d/override.conf [Service] AmbientCapabilities=CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SETUID CAP_SETGID CAP_CHOWN CapabilityBoundingSet=CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SETUID CAP_SETGID CAP_CHOWN EOF Add following lines to /etc/kvmd/override.yaml : kvmd : hid : type : bt Perform reboot . To reverse, uncomment lines from Step 2 and remove lines in Step 6, and reboot . Using Bluetooth HID \u00b6 After a reboot, the PiKVM will be ready for detection and pairing with no auth. You will see the PiKVM HID device. Once the server is connected, PiKVM will no longer be discoverable and pairable to other clients until you unpair the server. If something went wrong, use the web menu System -> Reset keyboard & mouse . This will cause unpair the device and switch the PiKVM to public mode before the first client is connected.","title":"Bluetooth HID"},{"location":"bluetooth_hid/#bluetooth-hid","text":"PiKVM is able to emulate a Bluetooth keyboard & mouse. This is not the main case of using PiKVM since you still need it to pair with a remote host, but can be used for something like mobile KVM. Warning Using Bluetooth HID requires additional configuration of the operating system. For v2+, this means losing the UART port, since it will be used by Bluetooth. Also, Bluetooth operation was tested only on RPi4 and v2+ platform. Other boards may require different system service settings. Making the required changes for BT to work will also disable normal KB/MOUSE functionality therefor this will need to be disabled before normal operation can occur. Note Bluetooth mouse can work only in relative mode . The reason is that many Bluetooth host drivers do not correctly implement HID descriptors. Horizontal scrolling is not supported for the same reason.","title":"Bluetooth HID"},{"location":"bluetooth_hid/#configuring-the-os","text":"Switch filesystem to RW-mode, perform update and install some packages: # rw # pacman -Syu # pacman -S bluez bluez-utils raspberrypi-bluetooth Edit /boot/config.txt and comment these lines: #enable_uart=1 #dtoverlay=disable-bt Create an empty directory /var/lib/bluetooth and add mountpoint to /etc/fstab : # mkdir /var/lib/bluetooth # echo 'tmpfs /var/lib/bluetooth tmpfs nodev,nosuid,mode=0755 0 0' >> /etc/fstab Override and enable the services: # mkdir /etc/systemd/system/bluetooth.service.d # cat << EOF > /etc/systemd/system/bluetooth.service.d/override.conf [Service] ExecStart= ExecStart=/usr/lib/bluetooth/bluetoothd --noplugin=* EOF # systemctl enable bluetooth # systemctl enable raspberrypi-btuart Override kvmd service: # mkdir /etc/systemd/system/kvmd.service.d # cat << EOF > /etc/systemd/system/kvmd.service.d/override.conf [Service] AmbientCapabilities=CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SETUID CAP_SETGID CAP_CHOWN CapabilityBoundingSet=CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SETUID CAP_SETGID CAP_CHOWN EOF Add following lines to /etc/kvmd/override.yaml : kvmd : hid : type : bt Perform reboot . To reverse, uncomment lines from Step 2 and remove lines in Step 6, and reboot .","title":"Configuring the OS"},{"location":"bluetooth_hid/#using-bluetooth-hid","text":"After a reboot, the PiKVM will be ready for detection and pairing with no auth. You will see the PiKVM HID device. Once the server is connected, PiKVM will no longer be discoverable and pairable to other clients until you unpair the server. If something went wrong, use the web menu System -> Reset keyboard & mouse . This will cause unpair the device and switch the PiKVM to public mode before the first client is connected.","title":"Using Bluetooth HID"},{"location":"building_os/","text":"Building the OS \u00b6 !!! warning \"ZeroW reached EOL and is no longer supported, the last image it can be found here \u201d The PiKVM OS is based on Arch Linux ARM and contains all the required packages and configs for it to work. To build the OS you will need x86_64 Linux machine with: kernel >= 5.8 glibc >= 2.33 docker >= 19.03.13 Docker must be enabled in privileged mode. When starting with a clean OS you need to install and configure docker (after adding your user to the docker group you must log out and log back in), as well as git and make. An example for Ubuntu: [ user@localhost ~ ] $ sudo apt-get install git make curl binutils -y [ user@localhost ~ ] $ curl -fsSL https://get.docker.com -o get-docker.sh [ user@localhost ~ ] $ sudo sh get-docker.sh [ user@localhost ~ ] $ sudo usermod -aG docker $USER Re-login to apply the changes. Git checkout the build toolchain: [ user@localhost ~ ] $ git clone --depth = 1 https://github.com/pikvm/os [ user@localhost ~ ] $ cd os Determine the target hardware configuration (platform): Choose the board: BOARD=rpi4 for Raspberry Pi 4 or BOARD=zerow , BOARD=rpi2 , BOARD=rpi3 for other options. Choose the platform: PLATFORM=v3-hdmi for RPi4 and PiKVM v3 HAT. PLATFORM=v2-hdmi for RPi3a+/RPi4 or Zero2W with HDMI-CSI bridge. PLATFORM=v2-hdmiusb for RPi4 with HDMI-USB dongle. PLATFORM=v0-hdmi for RPi2 or 3b+ with HDMI-CSI bridge and Arduino HID. PLATFORM=v0-hdmiusb for RPi2 or 3b+ with HDMI-USB dongle and Arduino HID. Other options are for legacy or specialized PiKVM boards (WIP). Create the config file config.mk for the target system. You must specify the path to the SD card on your local computer (this will be used to format and install the system) and the version of your Raspberry Pi and platform. You can change other parameters as you wish. Please note: if your password contains the # character, you must escape it using a backslash like ROOT_PASSWD = pass\\#word . [user@localhost os]$ cat config.mk # rpi3 for Raspberry Pi 3; rpi2 for the version 2, zero2w for Zero2W BOARD = rpi4 # Hardware configuration PLATFORM = v2-hdmi # Target hostname HOSTNAME = pikvm # ru_RU, etc. UTF-8 only LOCALE = en_US # See /usr/share/zoneinfo TIMEZONE = Europe/Moscow # For SSH root user ROOT_PASSWD = root # Web UI credentials: user=admin, password=<this> WEBUI_ADMIN_PASSWD = admin # IPMI credentials: user=admin, password=<this> IPMI_ADMIN_PASSWD = admin # SD card device CARD = /dev/mmcblk0 Build the OS. It may take about one hour depending on your Internet connection: [ user@localhost os ] $ make os If you get an error about failing to retriving a file, please edit the Makefile and remove \"de3.\" from the repo path One of two actions: Put SD card into card reader and install OS ( you should disable automounting beforehand : systemctl stop udisk2 or something like that): [ user@localhost os ] $ make install Make the image to copy elsewhere and burn on to SD card: [ user@localhost os ] $ make image Image is then available as a bziped file in images/ .","title":"Building PiKVM OS"},{"location":"building_os/#building-the-os","text":"!!! warning \"ZeroW reached EOL and is no longer supported, the last image it can be found here \u201d The PiKVM OS is based on Arch Linux ARM and contains all the required packages and configs for it to work. To build the OS you will need x86_64 Linux machine with: kernel >= 5.8 glibc >= 2.33 docker >= 19.03.13 Docker must be enabled in privileged mode. When starting with a clean OS you need to install and configure docker (after adding your user to the docker group you must log out and log back in), as well as git and make. An example for Ubuntu: [ user@localhost ~ ] $ sudo apt-get install git make curl binutils -y [ user@localhost ~ ] $ curl -fsSL https://get.docker.com -o get-docker.sh [ user@localhost ~ ] $ sudo sh get-docker.sh [ user@localhost ~ ] $ sudo usermod -aG docker $USER Re-login to apply the changes. Git checkout the build toolchain: [ user@localhost ~ ] $ git clone --depth = 1 https://github.com/pikvm/os [ user@localhost ~ ] $ cd os Determine the target hardware configuration (platform): Choose the board: BOARD=rpi4 for Raspberry Pi 4 or BOARD=zerow , BOARD=rpi2 , BOARD=rpi3 for other options. Choose the platform: PLATFORM=v3-hdmi for RPi4 and PiKVM v3 HAT. PLATFORM=v2-hdmi for RPi3a+/RPi4 or Zero2W with HDMI-CSI bridge. PLATFORM=v2-hdmiusb for RPi4 with HDMI-USB dongle. PLATFORM=v0-hdmi for RPi2 or 3b+ with HDMI-CSI bridge and Arduino HID. PLATFORM=v0-hdmiusb for RPi2 or 3b+ with HDMI-USB dongle and Arduino HID. Other options are for legacy or specialized PiKVM boards (WIP). Create the config file config.mk for the target system. You must specify the path to the SD card on your local computer (this will be used to format and install the system) and the version of your Raspberry Pi and platform. You can change other parameters as you wish. Please note: if your password contains the # character, you must escape it using a backslash like ROOT_PASSWD = pass\\#word . [user@localhost os]$ cat config.mk # rpi3 for Raspberry Pi 3; rpi2 for the version 2, zero2w for Zero2W BOARD = rpi4 # Hardware configuration PLATFORM = v2-hdmi # Target hostname HOSTNAME = pikvm # ru_RU, etc. UTF-8 only LOCALE = en_US # See /usr/share/zoneinfo TIMEZONE = Europe/Moscow # For SSH root user ROOT_PASSWD = root # Web UI credentials: user=admin, password=<this> WEBUI_ADMIN_PASSWD = admin # IPMI credentials: user=admin, password=<this> IPMI_ADMIN_PASSWD = admin # SD card device CARD = /dev/mmcblk0 Build the OS. It may take about one hour depending on your Internet connection: [ user@localhost os ] $ make os If you get an error about failing to retriving a file, please edit the Makefile and remove \"de3.\" from the repo path One of two actions: Put SD card into card reader and install OS ( you should disable automounting beforehand : systemctl stop udisk2 or something like that): [ user@localhost os ] $ make install Make the image to copy elsewhere and burn on to SD card: [ user@localhost os ] $ make image Image is then available as a bziped file in images/ .","title":"Building the OS"},{"location":"community_faq/","text":"I can't get the KVM KB to work on my ZeroW! \u00b6 Make sure that you did NOT modify your config.txt file, this is the default: # See /boot/overlays/README for all available options initramfs initramfs-linux.img followkernel hdmi_force_hotplug=1 gpu_mem=64 enable_uart=1 dtoverlay=tc358743,i2c_pins_28_29=1 dtoverlay=disable-bt dtoverlay=dwc2,dr_mode=peripheral Ensure that you have the cable(Needs to support both power/data) plugged into the right port, the one closest to the mini HDMI is the correct port Can I use a KB on my ZeroW? \u00b6 Yes but kb/mouse passthrough will not work. Its one or the other - This is especially true if you use an addon that requires the below to change. edit /boot/config.txt Host mode - Comment out dtoverlay=dwc2 Passthrough mode - Uncomment out dtoverlay=dwc2 Can you have the pikvm(RPi4) connected along with a monitor? \u00b6 A community member has had success with the following: https://www.amazon.com/gp/product/B08DQWLXF1 Some Alternitives If you have two outputs, you may be able to use screen mirroring from the OS but not BIOS If you have one output or need access from both a local monitor or PiKVM at boot time, one of the following options may work: Passthrough HDMI capture devices (sometimes referred to as a loop capture device). The Elgato and Avermedia devices DO NOT WORK! Look for Linux OS support when choosing a device, the expected price range is about $35-$70 US. Depending on your capture device, an HDMI splitter may work but will need what is called an EDID (Extended Device ID) generator, the monitor and capture device both generate EDID so the splitter must produce its own separate EDID for the host. Look for HDMI splitters - although there have been reports that these are not stable Please use the search function in Discord, some users have had sucess in getting this to work but your mileage may vary The better solution is to capture the stream in a dir and then use VLC to stream to that capture on another computer. This will result in fps loss. Wouldn't it be good to have different hostnames for your multitude of pikvms? \u00b6 Yes! And it's easy to do! Using a SSH session or the web terminal: - Make sure you're root , if you're not root use the su command to become root - Enter read write mode of the PiKVM by executing the rw command - Execute: hostnamectl set-hostname yournewhostname.domain - Optional: Edit /etc/kvmd/meta.yaml to alter the displayed hostname in the web UI - Reboot the pikvm I want to do something not related to PiKVM \u00b6 It's recommended that you review Arch documents related to what you want to do, while there are several folks in discord who can help, there is no obligation...they do it for the feels. So if you don't get an answer within the time frame you are looking for, it's advised you start google searching for what you want. Can this be used in any other distro\u2019s like Rasbian? Run this in a Docker? \u00b6 Officially, no. Unofficially yes and totally #unsupported. Please DM @srepac on discord for the directions. Docker image is available, search the docker hub but this is #unsupported and #unofficial and not updated. Can you switch from USB to CSI or from CSI to USB? \u00b6 Officially, no. You would be advised to make 2 seperate SD cards and swap them when needed. Unofficially yes and totally NOT supported. Please DM @srepac on discord for the script and directions. Help! I ran out of space aka room! What now? \u00b6 (This ONLY applies to the older flashed images and is no longer nessessary as the newer images had the main partition increased, as a result, the MSD partition was shrunk) - You\u2019ve cached package updates you no longer need. - Enter read/write mode by executing rw as root - Execute the following as root to clear the package cache rm -rf /var/cache/pacman/pkg/* - Exit read/write mode by executing ro as root - You can also use gparted to resize partitions without \"losing data\", although there is a chance this may delete all of your data Can you connect a camera to this and still make pikvm functional? \u00b6 Yes, any cheapo webcam can be used in place of the usb dongle, please use the usb image A PiCam will NOT work HELP!! Something isn't working!! \u00b6 What was the last thing or most recent thing you did? Did you undo it? Did you change a file? Did you back it up before changing it? Did you hook this to anything else? If not why not? Did you try different cables? Things to do after initial install: \u00b6 Fix date: 'timedatectl list-timezones' then 'timedatectl set-timezone America/Los_Angeles' (Change to your location) Update PiKVM, follow #news on Discord for instructions Setup a NFS share to give read/write storage on the read only pikvm Note: this does assume you already have an NFS server on your network and accessible to pikvm Source https://linuxhint.com/install_configure_nfs/ pacman -S nfs-utils showmount -e 192.168.1.XXX mount -t nfs 192.168.1.XXX:/volume1/Data /mnt/Data nano /etc/fstab Add To the bottom of the file 192.168.1.XXX:/volume1/Data /mnt/Data nfs auto,rw,soft 0 0 Troubleshooting \u00b6 :exclamation: It is expected that you are aware of basic networking while working on this project and that you have read up on the project prior to going to Discord :exclamation: Do you know the IP? Can you ping the IP? Did you swap cables? Did you swap the eth port to a known working eth port? Do you have access to another router or switch? Did you change ports on the router/switch? RPi4 - Did you hook up a monitor? Once logged in, can you ping to your gateway? Other IP's on the same network? Did you connect a monitor to the target? Does it work? Did you connect the PIKVM to the target directly? Does it work? Reboot target Try default image, do not update and test -copy/paste into a file, call it pi-info.sh, chmod +x pi-info.sh, ./pi-info.sh Same script is located here #!/bin/bash uptime TMPFILE=\"/tmp/pacmanquery\"; /bin/rm -f $TMPFILE pacman -Q | awk '{print $2, $1}' > $TMPFILE chmod go+w $TMPFILE pistat && echo printf \"%-18s\\t%s\\n\" \"Version\" \"Package-Name\" \"----------------------\" \"-----------------------------\" PACKAGES=\"firmware bootloader kvmd ustreamer nginx wpa wireless\" for PKG in $( echo $PACKAGES ); do printf \"%-18s\\t%s\\n\" $(grep $PKG $TMPFILE | sed 's/-[1-9]//g') done dmesg | grep tc35 - CSI dmesg | egrep '1-1.[245]|uvc' - USB systemctl status kvmd systemctl status kvmd-otg hint: look at kvmd-platform line of the output... make sure it matches the image they expect for the capture device and platform Keyboard/Mouse icons orange? Try a different cable (ALLOT are power only), try a different usb port Should see the following if everything is in place ls -l /dev/kvmd lrwxrwxrwx 1 root root 5 Apr 5 21:33 /dev/kvmd-hid-keyboard -> hidg0 lrwxrwxrwx 1 root root 5 Apr 5 21:33 /dev/kvmd-hid-mouse -> hidg1 lrwxrwxrwx 1 root root 6 Mar 15 09:07 /dev/kvmd-video -> video0 Common Commands for troubleshooting PiKVM \u00b6 journalctl -u kvmd journalctl -u kvmd-vnc journalctl -u kvmd-ipmi Bootup/power issues \u00b6 PiKVM won\u2019t boot past \u201crainbow\u201d screen Are you plugged into the right HDMI port? Needs to be the one next to the power for RPI4 Have you reflashed your SD card? USB Video Capture Issues \u00b6 Make sure this is a capture card and not an adapter (HDMI->USB) HDMI-CSI Capture issues \u00b6 Have you reset the Target PC? Are you sure it's a bridge and not an extender? There is a difference Did you make sure it's plugged into the right port? It needs to say Camera NOT Display Did you try another ribbon cable? Did you reseat the ribbon cable? Is the ribbon cable facing the right way? Needs to be towards the PCB (Green or Black) If you are getting snow looking screen, you need to make sure you select 50hz OR select anything below 1080p, like 720p60 If you are getting an Indian looking screen, please clear the browser cache or use private/incog window Misc stuff \u00b6 Fully working example of a Pi4 USB-HDMI KVM attached to AIMOS 4-port HDMI KVM switch (8 port is on AliExpress), with keyboard hotkey switching between inputs, and mass storage media emulation on a Pi Zero W PiKVM that mitigates HDMI backpower and requires no splitter board here VERY useful scripts that enhance the PiKVM's functionality - Please DM @srepac on discord to gain access Useful links \u00b6 https://www.tomshardware.com/how-to/kvm-over-ip-raspberry-pi - Very good article on PIKVM setup As of March 2021, Below are frequently out of Stock or hard to get items, all have exceptionally LONG shipping dates Ezcoo KVM - Goes out of stock frequently CSI2-HDMI bridge w/ TC358743XBG chip - Goes out of stock freqently Alternative names for the same devices: Tiamu Sling Yazan Ningwang Essenc Geekworm Fauge Haudang AKAT Docoop Katigan Lyusa (recommended by mdevaev) LNIMI cherrypop Lopbinte Uang Tuneway Mustwell Facibom Binchil Cobeky Ctzrzyt Davitu Community recommended USB capture card Community recommended Loop device that allows Monitor+PiKVM","title":"Community faq"},{"location":"community_faq/#i-cant-get-the-kvm-kb-to-work-on-my-zerow","text":"Make sure that you did NOT modify your config.txt file, this is the default: # See /boot/overlays/README for all available options initramfs initramfs-linux.img followkernel hdmi_force_hotplug=1 gpu_mem=64 enable_uart=1 dtoverlay=tc358743,i2c_pins_28_29=1 dtoverlay=disable-bt dtoverlay=dwc2,dr_mode=peripheral Ensure that you have the cable(Needs to support both power/data) plugged into the right port, the one closest to the mini HDMI is the correct port","title":"I can't get the KVM KB to work on my ZeroW!"},{"location":"community_faq/#can-i-use-a-kb-on-my-zerow","text":"Yes but kb/mouse passthrough will not work. Its one or the other - This is especially true if you use an addon that requires the below to change. edit /boot/config.txt Host mode - Comment out dtoverlay=dwc2 Passthrough mode - Uncomment out dtoverlay=dwc2","title":"Can I use a KB on my ZeroW?"},{"location":"community_faq/#can-you-have-the-pikvmrpi4-connected-along-with-a-monitor","text":"A community member has had success with the following: https://www.amazon.com/gp/product/B08DQWLXF1 Some Alternitives If you have two outputs, you may be able to use screen mirroring from the OS but not BIOS If you have one output or need access from both a local monitor or PiKVM at boot time, one of the following options may work: Passthrough HDMI capture devices (sometimes referred to as a loop capture device). The Elgato and Avermedia devices DO NOT WORK! Look for Linux OS support when choosing a device, the expected price range is about $35-$70 US. Depending on your capture device, an HDMI splitter may work but will need what is called an EDID (Extended Device ID) generator, the monitor and capture device both generate EDID so the splitter must produce its own separate EDID for the host. Look for HDMI splitters - although there have been reports that these are not stable Please use the search function in Discord, some users have had sucess in getting this to work but your mileage may vary The better solution is to capture the stream in a dir and then use VLC to stream to that capture on another computer. This will result in fps loss.","title":"Can you have the pikvm(RPi4) connected along with a monitor?"},{"location":"community_faq/#wouldnt-it-be-good-to-have-different-hostnames-for-your-multitude-of-pikvms","text":"Yes! And it's easy to do! Using a SSH session or the web terminal: - Make sure you're root , if you're not root use the su command to become root - Enter read write mode of the PiKVM by executing the rw command - Execute: hostnamectl set-hostname yournewhostname.domain - Optional: Edit /etc/kvmd/meta.yaml to alter the displayed hostname in the web UI - Reboot the pikvm","title":"Wouldn't it be good to have different hostnames for your multitude of pikvms?"},{"location":"community_faq/#i-want-to-do-something-not-related-to-pikvm","text":"It's recommended that you review Arch documents related to what you want to do, while there are several folks in discord who can help, there is no obligation...they do it for the feels. So if you don't get an answer within the time frame you are looking for, it's advised you start google searching for what you want.","title":"I want to do something not related to PiKVM"},{"location":"community_faq/#can-this-be-used-in-any-other-distros-like-rasbian-run-this-in-a-docker","text":"Officially, no. Unofficially yes and totally #unsupported. Please DM @srepac on discord for the directions. Docker image is available, search the docker hub but this is #unsupported and #unofficial and not updated.","title":"Can this be used in any other distro\u2019s like Rasbian? Run this in a Docker?"},{"location":"community_faq/#can-you-switch-from-usb-to-csi-or-from-csi-to-usb","text":"Officially, no. You would be advised to make 2 seperate SD cards and swap them when needed. Unofficially yes and totally NOT supported. Please DM @srepac on discord for the script and directions.","title":"Can you switch from USB to CSI or from CSI to USB?"},{"location":"community_faq/#help-i-ran-out-of-space-aka-room-what-now","text":"(This ONLY applies to the older flashed images and is no longer nessessary as the newer images had the main partition increased, as a result, the MSD partition was shrunk) - You\u2019ve cached package updates you no longer need. - Enter read/write mode by executing rw as root - Execute the following as root to clear the package cache rm -rf /var/cache/pacman/pkg/* - Exit read/write mode by executing ro as root - You can also use gparted to resize partitions without \"losing data\", although there is a chance this may delete all of your data","title":"Help! I ran out of space aka room! What now?"},{"location":"community_faq/#can-you-connect-a-camera-to-this-and-still-make-pikvm-functional","text":"Yes, any cheapo webcam can be used in place of the usb dongle, please use the usb image A PiCam will NOT work","title":"Can you connect a camera to this and still make pikvm functional?"},{"location":"community_faq/#help-something-isnt-working","text":"What was the last thing or most recent thing you did? Did you undo it? Did you change a file? Did you back it up before changing it? Did you hook this to anything else? If not why not? Did you try different cables?","title":"HELP!! Something isn't working!!"},{"location":"community_faq/#things-to-do-after-initial-install","text":"Fix date: 'timedatectl list-timezones' then 'timedatectl set-timezone America/Los_Angeles' (Change to your location) Update PiKVM, follow #news on Discord for instructions Setup a NFS share to give read/write storage on the read only pikvm Note: this does assume you already have an NFS server on your network and accessible to pikvm Source https://linuxhint.com/install_configure_nfs/ pacman -S nfs-utils showmount -e 192.168.1.XXX mount -t nfs 192.168.1.XXX:/volume1/Data /mnt/Data nano /etc/fstab Add To the bottom of the file 192.168.1.XXX:/volume1/Data /mnt/Data nfs auto,rw,soft 0 0","title":"Things to do after initial install:"},{"location":"community_faq/#troubleshooting","text":":exclamation: It is expected that you are aware of basic networking while working on this project and that you have read up on the project prior to going to Discord :exclamation: Do you know the IP? Can you ping the IP? Did you swap cables? Did you swap the eth port to a known working eth port? Do you have access to another router or switch? Did you change ports on the router/switch? RPi4 - Did you hook up a monitor? Once logged in, can you ping to your gateway? Other IP's on the same network? Did you connect a monitor to the target? Does it work? Did you connect the PIKVM to the target directly? Does it work? Reboot target Try default image, do not update and test -copy/paste into a file, call it pi-info.sh, chmod +x pi-info.sh, ./pi-info.sh Same script is located here #!/bin/bash uptime TMPFILE=\"/tmp/pacmanquery\"; /bin/rm -f $TMPFILE pacman -Q | awk '{print $2, $1}' > $TMPFILE chmod go+w $TMPFILE pistat && echo printf \"%-18s\\t%s\\n\" \"Version\" \"Package-Name\" \"----------------------\" \"-----------------------------\" PACKAGES=\"firmware bootloader kvmd ustreamer nginx wpa wireless\" for PKG in $( echo $PACKAGES ); do printf \"%-18s\\t%s\\n\" $(grep $PKG $TMPFILE | sed 's/-[1-9]//g') done dmesg | grep tc35 - CSI dmesg | egrep '1-1.[245]|uvc' - USB systemctl status kvmd systemctl status kvmd-otg hint: look at kvmd-platform line of the output... make sure it matches the image they expect for the capture device and platform Keyboard/Mouse icons orange? Try a different cable (ALLOT are power only), try a different usb port Should see the following if everything is in place ls -l /dev/kvmd lrwxrwxrwx 1 root root 5 Apr 5 21:33 /dev/kvmd-hid-keyboard -> hidg0 lrwxrwxrwx 1 root root 5 Apr 5 21:33 /dev/kvmd-hid-mouse -> hidg1 lrwxrwxrwx 1 root root 6 Mar 15 09:07 /dev/kvmd-video -> video0","title":"Troubleshooting"},{"location":"community_faq/#common-commands-for-troubleshooting-pikvm","text":"journalctl -u kvmd journalctl -u kvmd-vnc journalctl -u kvmd-ipmi","title":"Common Commands for troubleshooting PiKVM"},{"location":"community_faq/#bootuppower-issues","text":"PiKVM won\u2019t boot past \u201crainbow\u201d screen Are you plugged into the right HDMI port? Needs to be the one next to the power for RPI4 Have you reflashed your SD card?","title":"Bootup/power issues"},{"location":"community_faq/#usb-video-capture-issues","text":"Make sure this is a capture card and not an adapter (HDMI->USB)","title":"USB Video Capture Issues"},{"location":"community_faq/#hdmi-csi-capture-issues","text":"Have you reset the Target PC? Are you sure it's a bridge and not an extender? There is a difference Did you make sure it's plugged into the right port? It needs to say Camera NOT Display Did you try another ribbon cable? Did you reseat the ribbon cable? Is the ribbon cable facing the right way? Needs to be towards the PCB (Green or Black) If you are getting snow looking screen, you need to make sure you select 50hz OR select anything below 1080p, like 720p60 If you are getting an Indian looking screen, please clear the browser cache or use private/incog window","title":"HDMI-CSI Capture issues"},{"location":"community_faq/#misc-stuff","text":"Fully working example of a Pi4 USB-HDMI KVM attached to AIMOS 4-port HDMI KVM switch (8 port is on AliExpress), with keyboard hotkey switching between inputs, and mass storage media emulation on a Pi Zero W PiKVM that mitigates HDMI backpower and requires no splitter board here VERY useful scripts that enhance the PiKVM's functionality - Please DM @srepac on discord to gain access","title":"Misc stuff"},{"location":"community_faq/#useful-links","text":"https://www.tomshardware.com/how-to/kvm-over-ip-raspberry-pi - Very good article on PIKVM setup As of March 2021, Below are frequently out of Stock or hard to get items, all have exceptionally LONG shipping dates Ezcoo KVM - Goes out of stock frequently CSI2-HDMI bridge w/ TC358743XBG chip - Goes out of stock freqently Alternative names for the same devices: Tiamu Sling Yazan Ningwang Essenc Geekworm Fauge Haudang AKAT Docoop Katigan Lyusa (recommended by mdevaev) LNIMI cherrypop Lopbinte Uang Tuneway Mustwell Facibom Binchil Cobeky Ctzrzyt Davitu Community recommended USB capture card Community recommended Loop device that allows Monitor+PiKVM","title":"Useful links"},{"location":"edid/","text":"EDID \u00b6 Warning This will only apply to the CSI/v3 models, USB is not compatable. Modifing the EDID may or may not work in some instances where a \"no signal\" might be a result of outside factors. EDID is information about the video modes supported by the video capture device. In the case of PiKVM, this is an HDMI CSI bridge. Usually, you don't need to change this, since the default configuration is quite flexible, but sometimes, for example for strange UEFIs/BIOSes, this may be necessary (the story ). The EDID is stored on the PiKVM in the file /etc/kvmd/tc358743-edid.hex . If you write new data there, it will be applied after rebooting. You can also apply the new EDID without rebooting to make sure it works: Switch filesystem to RW-mode: rw . Create the new EDID file /root/edid.hex (examples of file contents are shown below). Apply EDID using the command kvmd-edidconf --edid=/root/edid.hex --apply . DO NOT REBOOT the PiKVM. Just your PC. Check the UEFI/BIOS. If everything works, you can write the same data to /etc/kvmd/tc358743-edid.hex . Switch filesystem to RO-mode: ro . The examples below are tested on these devices, but they are also suitable for others. To edit or create EDID you can use AW EDID Editor . Editing EDID \u00b6 To edit EDID, it is best to use third-party utilities, such as the recommended advanced AW EDID Editor for Windows (it's working great in wine) or wxEDID . Both editors work with the binary EDID format, but you can easily import and export it to PiKVM using the kvmd-edidconf utility. So, to tune EDID on PiKVM, use the following steps: Switch filesystem to RW-mode: rw . Export the system edid to the binary file myedid.bin : # kvmd-edidconf --export-bin=/root/myedid.bin Copy this file to your PC with the editor. Use SCP, Putty or something like that. Open this binary file in the editor and change the necessary parameters. Edit, save and copy it back to PiKVM. Convert the binary file to the HEX and test it: # kvmd-edidconf --import=/root/myedid.bin --edid=/root/myedid.hex --apply If everything works fine, install the new EDID file into the system: # cp /root/myedid.hex /etc/kvmd/tc358743-edid.hex Alternative to step (4) and (5): if you are confident in your abilities, you can immediately install the new myedit.bin into the system and apply it instantly, without the need to use the temporary myedid.hex : # kvmd-edidconf --import=/root/myedid.bin --apply Switch filesystem to RO-mode: ro . The kvmd-edidconfig utility has the ability to change some simple parameters without using an external editor. For example you can change the vendor, model name and enable HDMI audio on the PiKVM virtual display: # kvmd-edidconf --set-mfc-id=LNX --set-monitor-name=PiKVM --set-audio=1 # reboot Note Windows cache's drivers and registry settings so changing the monitor name is not enough, you will also need to change the product ID and/or the serial number along with the monitor name: # kvmd-edidconf --set-monitor-name=TOSHIBA --set-mfc-id=TTP --set-product-id=34953 --set-serial=2290649089 --apply Custom EDIDs \u00b6 1280x1024 as preferred. Useful for Gigabyte GA-H77-DS3H 00FFFFFFFFFFFF005262888800888888 1C150103800000780AEE91A3544C9926 0F505425400001000100010001000100 010001010101D51B0050500019400820 B80080001000001EEC2C80A070381A40 3020350040442100001E000000FC0050 492D4B564D20566964656F0A000000FD 00323D0F2E0F0000000000000000014D 02030400DE0D20A03058122030203400 F0B400000018E01500A0400016303020 3400000000000018B41400A050D01120 3020350080D810000018AB22A0A05084 1A3030203600B00E1100001800000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000045 1920x1080 as preferred. Useful for Gigabyte GA-H77-DS3H, Intel NUC or ASRock H670 PG Riptide 00FFFFFFFFFFFF005262888800888888 1C150103800000780AEE91A3544C9926 0F505425400001000100010001000100 010001010101D32C80A070381A403020 350040442100001E7E1D00A050001940 3020370080001000001E000000FC0050 492D4B564D20566964656F0A000000FD 00323D0F2E0F000000000000000001C4 02030400DE0D20A03058122030203400 F0B400000018E01500A0400016303020 3400000000000018B41400A050D01120 3020350080D810000018AB22A0A05084 1A3030203600B00E1100001800000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000045 1280x1024 as preferred, disabled 1080p at all. This may be necessary in extremely rare cases if the BIOS is completely buggy. In the future, we will provide a way to dynamically switch EDID 00FFFFFFFFFFFF005262888800888888 1C150103800000780AEE91A3544C9926 0F50542FCF0001000100010001000100 0100010101018C2300A050001E403020 370080001000001E000000FC0050492D 4B564D20566964656F0A000000FD0032 3D0F2E0F000000000000000000000010 0000000000000000000000000000016B 02030400DE0D20A03058122030203400 F0B400000018E01500A0400016303020 3400000000000018B41400A050D01120 3020350080D810000018AB22A0A05084 1A3030203600B00E1100001800000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000045 Default EDID \u00b6 If for some reason you need to go back to the default EDID (changing attached device etc), you can find it locally on the Pi at /usr/share/kvmd/configs.default/kvmd/tc358743-edid.hex : # cp /usr/share/kvmd/configs.default/kvmd/tc358743-edid.hex /etc/kvmd/tc358743-edid.hex ... or in the kvmd repo .","title":"Tuning HDMI EDID"},{"location":"edid/#edid","text":"Warning This will only apply to the CSI/v3 models, USB is not compatable. Modifing the EDID may or may not work in some instances where a \"no signal\" might be a result of outside factors. EDID is information about the video modes supported by the video capture device. In the case of PiKVM, this is an HDMI CSI bridge. Usually, you don't need to change this, since the default configuration is quite flexible, but sometimes, for example for strange UEFIs/BIOSes, this may be necessary (the story ). The EDID is stored on the PiKVM in the file /etc/kvmd/tc358743-edid.hex . If you write new data there, it will be applied after rebooting. You can also apply the new EDID without rebooting to make sure it works: Switch filesystem to RW-mode: rw . Create the new EDID file /root/edid.hex (examples of file contents are shown below). Apply EDID using the command kvmd-edidconf --edid=/root/edid.hex --apply . DO NOT REBOOT the PiKVM. Just your PC. Check the UEFI/BIOS. If everything works, you can write the same data to /etc/kvmd/tc358743-edid.hex . Switch filesystem to RO-mode: ro . The examples below are tested on these devices, but they are also suitable for others. To edit or create EDID you can use AW EDID Editor .","title":"EDID"},{"location":"edid/#editing-edid","text":"To edit EDID, it is best to use third-party utilities, such as the recommended advanced AW EDID Editor for Windows (it's working great in wine) or wxEDID . Both editors work with the binary EDID format, but you can easily import and export it to PiKVM using the kvmd-edidconf utility. So, to tune EDID on PiKVM, use the following steps: Switch filesystem to RW-mode: rw . Export the system edid to the binary file myedid.bin : # kvmd-edidconf --export-bin=/root/myedid.bin Copy this file to your PC with the editor. Use SCP, Putty or something like that. Open this binary file in the editor and change the necessary parameters. Edit, save and copy it back to PiKVM. Convert the binary file to the HEX and test it: # kvmd-edidconf --import=/root/myedid.bin --edid=/root/myedid.hex --apply If everything works fine, install the new EDID file into the system: # cp /root/myedid.hex /etc/kvmd/tc358743-edid.hex Alternative to step (4) and (5): if you are confident in your abilities, you can immediately install the new myedit.bin into the system and apply it instantly, without the need to use the temporary myedid.hex : # kvmd-edidconf --import=/root/myedid.bin --apply Switch filesystem to RO-mode: ro . The kvmd-edidconfig utility has the ability to change some simple parameters without using an external editor. For example you can change the vendor, model name and enable HDMI audio on the PiKVM virtual display: # kvmd-edidconf --set-mfc-id=LNX --set-monitor-name=PiKVM --set-audio=1 # reboot Note Windows cache's drivers and registry settings so changing the monitor name is not enough, you will also need to change the product ID and/or the serial number along with the monitor name: # kvmd-edidconf --set-monitor-name=TOSHIBA --set-mfc-id=TTP --set-product-id=34953 --set-serial=2290649089 --apply","title":"Editing EDID"},{"location":"edid/#custom-edids","text":"1280x1024 as preferred. Useful for Gigabyte GA-H77-DS3H 00FFFFFFFFFFFF005262888800888888 1C150103800000780AEE91A3544C9926 0F505425400001000100010001000100 010001010101D51B0050500019400820 B80080001000001EEC2C80A070381A40 3020350040442100001E000000FC0050 492D4B564D20566964656F0A000000FD 00323D0F2E0F0000000000000000014D 02030400DE0D20A03058122030203400 F0B400000018E01500A0400016303020 3400000000000018B41400A050D01120 3020350080D810000018AB22A0A05084 1A3030203600B00E1100001800000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000045 1920x1080 as preferred. Useful for Gigabyte GA-H77-DS3H, Intel NUC or ASRock H670 PG Riptide 00FFFFFFFFFFFF005262888800888888 1C150103800000780AEE91A3544C9926 0F505425400001000100010001000100 010001010101D32C80A070381A403020 350040442100001E7E1D00A050001940 3020370080001000001E000000FC0050 492D4B564D20566964656F0A000000FD 00323D0F2E0F000000000000000001C4 02030400DE0D20A03058122030203400 F0B400000018E01500A0400016303020 3400000000000018B41400A050D01120 3020350080D810000018AB22A0A05084 1A3030203600B00E1100001800000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000045 1280x1024 as preferred, disabled 1080p at all. This may be necessary in extremely rare cases if the BIOS is completely buggy. In the future, we will provide a way to dynamically switch EDID 00FFFFFFFFFFFF005262888800888888 1C150103800000780AEE91A3544C9926 0F50542FCF0001000100010001000100 0100010101018C2300A050001E403020 370080001000001E000000FC0050492D 4B564D20566964656F0A000000FD0032 3D0F2E0F000000000000000000000010 0000000000000000000000000000016B 02030400DE0D20A03058122030203400 F0B400000018E01500A0400016303020 3400000000000018B41400A050D01120 3020350080D810000018AB22A0A05084 1A3030203600B00E1100001800000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000045","title":"Custom EDIDs"},{"location":"edid/#default-edid","text":"If for some reason you need to go back to the default EDID (changing attached device etc), you can find it locally on the Pi at /usr/share/kvmd/configs.default/kvmd/tc358743-edid.hex : # cp /usr/share/kvmd/configs.default/kvmd/tc358743-edid.hex /etc/kvmd/tc358743-edid.hex ... or in the kvmd repo .","title":"Default EDID"},{"location":"ezcoo/","text":"ezCoo managed multiport KVM switch \u00b6 The ezCoo managed switch can be controlled by PiKVM to allow it to connect to multiple hosts. A typical scenario is a single PiKVM device which can control and switch between multiple hosts or servers using the ezCoo switch. UI elements can be added to the GPIO dropdown to allow switching between hosts from the PiKVM webpage. The instructions here were tested with the ezCoo SW41HA HDMI 4x1 switch ezCoo EZ-SW41HA-KVMU3L 4x1 switch . Both older USB2.0 and newer USB3.0 variants are supported. The following was testing on a Raspberry Pi 4 but should also work on the Pi 2 and 3. This document was createdy using the contributions from multiple users in our Discord and the author appreciates their efforts. Info While most images of the switch do not show the sides, there is a Micro USB port on the side of the ezCoo switch. This is the management port, which is controlled via COM port on the ezCoo KVM. When plugged into the Raspberry Pi, it appears as /dev/ttyUSB0 . Info Audio was not tested, it is assumed to be non-functional. Connections \u00b6 Please review the item description and manual before deploying. From a high level, the ezCoo switch uses standard connections to the host machines (USB-A to USB-B and HDMI for USB2 version, USB-A to USB-A for the USB3 version). The Raspberry Pi OTG connector (the one coming from the USB-C port on a Pi 4 via the custom splitter cable or device) should be connected to the USB 3 port on the ezCoo switch. There is an additional USB cable connected to the managed port on the switch. Connect the USB-C cable from the Raspberry Pi OTG port to ezCoo switch USB 3 port on the front or USB 1 port on the back of the switch. Note : If this cable is connected to the keyboard port (USB 2) of the ezCoo switch, the mouse will not be present. Connect the HDMI out from the ezCoo switch to the Raspberry Pi CSI-2 to HDMI input. Other users have reported HDMI encoder USB dongles as working. Connect a USB-A to Micro USB cable from the Raspberry Pi to the management port on the side of the ezCoo switch. Connect host USB and HDMI cables from the ezCoo switch to the machines to be managed per the switch instructions. At this point the KVM switch should be present as a device on the PiKVM. SSH into PiKVM and ensure a device like /dev/ttyUSB0 is present. The following instructions assume this is the KVM switch. Info There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi CSI2-HDMI encoder. These limitations apply equally when using the ezCoo KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the ezCoo switch before powering the hosts on. Adding UI elements to control the KVM switch \u00b6 The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected. The instructions below will make these available in the PiKVM UI after clicking the \"GPIO\" menu button in the KVM view. Enable read-write mode on the SD card via rw Edit the file: nano /etc/kvmd/override.yaml and include the following. Note the assumption that the KVM switch is present on /dev/ttyUSB0 : kvmd : gpio : drivers : ez : type : ezcoo device : /dev/ttyUSB0 scheme : ch0_led : driver : ez pin : 0 mode : input ch1_led : driver : ez pin : 1 mode : input ch2_led : driver : ez pin : 2 mode : input ch3_led : driver : ez pin : 3 mode : input ch0_button : driver : ez pin : 0 mode : output switch : false ch1_button : driver : ez pin : 1 mode : output switch : false ch2_button : driver : ez pin : 2 mode : output switch : false ch3_button : driver : ez pin : 3 mode : output switch : false view : table : - [ \"#Input 1\" , ch0_led , ch0_button ] - [ \"#Input 2\" , ch1_led , ch1_button ] - [ \"#Input 3\" , ch2_led , ch2_button ] - [ \"#Input 4\" , ch3_led , ch3_button ] Editing '#Input X' will change the table name in the GUI drop down, if you want a different name, name it something else and restart kvmd. This now only applies to older images, newer images do not have this issue. Make sure to notate the spaces for each line, needs to be a total of 4 spaces added per line (NOT tabs): For example: parent: 0 spaces (kvmd:) child: 4 spaces (gpio:) sub-child: 8 spaces (drivers:) sub-sub-child: 12 spaces (ez:) Return to read-only mode for the sd card via ro . Restart the kvmd service: systemctl restart kvmd . If you are still not getting KB output, issue a ls -la /dev/tty* | grep USB , if no output change cables (Alot of cables are power only) Switching between hosts in the UI \u00b6 To switch between hosts, enter the KVM UI and click the \"GPIO\" menu. You should see 4 inputs, one of which will have a green circle indicating it is currently selected. Click the other inputs to change the selected host. Additional step for the USB 3.0 version \u00b6 Please add protocol: 2 to the override.yaml under the type: ezcoo at the same level: kvmd : gpio : drivers : ez : type : ezcoo protocol : 2 device : /dev/ttyUSB0 Developer info \u00b6 The official protocol version 1 reference Differences between protocols 1 and 2 =============================================================================================================================== =********************************************************Systems HELP*********************************************************= =-----------------------------------------------------------------------------------------------------------------------------= = System Address = 00 F/W Version : 1.20 = = Azz : All Commands start by Prefix System Address zz, if [01-99] = =-----------------------------------------------------------------------------------------------------------------------------= = EZH : Help = = EZSTA : Show Global System Status = = EZS RST : Reset to Factory Defaults = = EZS ADDR xx : Set System Address to xx {xx=[00~99](00=Single)} = = EZS CAS EN/DIS : Set Cascade Mode Enable/Disable = = EZS OUTx VS INy : Set Output x To Input y{x=[0~2](0=ALL), y=[1~4]} = = EZS IR SYS xx.yy : Set IR Custom Code{xx=[00-FFH],yy=[00-FFH]} = = EZS IR OUTx INy CODE zz : Set IR Data Code{x=[1~2],y=[1~4],zz=[00-FFH]} = = EZG ADDR : Get System Address = = EZG STA : Get System System Status = = EZG CAS : Get Cascade Mode Status = = EZG OUTx VS : Get Output x Video Route{x=[0~2](0=ALL)} = = EZG IR SYS : Get IR Custom Code = = EZG IR OUTx INy CODE : Get IR Data Code{x=[1~2],y=[1~4]} = = EZS OUTx VIDEOy : Set Output VIDEO Mode = = {x=[1~2], y=[1~2](1=BYPASS,2=4K->2K)} = =-----------------------------------------------------------------------------------------------------------------------------= =Input Setup Commands:(Note:input number(x)=HDMI(x),x=1) = = EZS INx EDID y : Set Input x EDID{x=[0~4](0=ALL), y=[0~15]} = = 0:EDID_BYPASS 1:1080P_2CH_HDR 2:1080P_6CH_HDR 3:1080P_8CH_HDR = = 4:1080P_3D_2CH_HDR 5:1080P_3D_6CH_HDR 6:1080P_3D_8CH_HDR = = 7:4K30HZ_3D_2CH_HDR 8:4K30HZ_3D_6CH_HDR 9:4K30HZ_3D_8CH_HDR = = 10:4K60HzY420_3D_2CH_HDR 11:4K60HzY420_3D_6CH_HDR 12:4K60HzY420_3D_8CH_HDR = = 13:4K60HZ_3D_2CH_HDR 14:4K60HZ_3D_6CH_HDR 15:4K60HZ_3D_8CH_HDR = = 16:H4K_DOLBY_VISION_ATMOS = = EZG INx EDID : Get Input x EDID Index{x=[0~4](0=ALL)} = =-----------------------------------------------------------------------------------------------------------------------------= =*****************************************************************************************************************************= =============================================================================================================================== Simple troubleshooting steps to perform \u00b6 Video Issues: Hook a monitor to the output and test Reseat the cables Change out the cables Switching issues: SSH or open a web terminal to your PiKVM `ls -la /dev/ttyUSB*` - This should give you an output. If not, try a different cable till an output is displayed. EZCOO Wiring example can be found here","title":"ezCoo managed multiport KVM switch"},{"location":"ezcoo/#ezcoo-managed-multiport-kvm-switch","text":"The ezCoo managed switch can be controlled by PiKVM to allow it to connect to multiple hosts. A typical scenario is a single PiKVM device which can control and switch between multiple hosts or servers using the ezCoo switch. UI elements can be added to the GPIO dropdown to allow switching between hosts from the PiKVM webpage. The instructions here were tested with the ezCoo SW41HA HDMI 4x1 switch ezCoo EZ-SW41HA-KVMU3L 4x1 switch . Both older USB2.0 and newer USB3.0 variants are supported. The following was testing on a Raspberry Pi 4 but should also work on the Pi 2 and 3. This document was createdy using the contributions from multiple users in our Discord and the author appreciates their efforts. Info While most images of the switch do not show the sides, there is a Micro USB port on the side of the ezCoo switch. This is the management port, which is controlled via COM port on the ezCoo KVM. When plugged into the Raspberry Pi, it appears as /dev/ttyUSB0 . Info Audio was not tested, it is assumed to be non-functional.","title":"ezCoo managed multiport KVM switch"},{"location":"ezcoo/#connections","text":"Please review the item description and manual before deploying. From a high level, the ezCoo switch uses standard connections to the host machines (USB-A to USB-B and HDMI for USB2 version, USB-A to USB-A for the USB3 version). The Raspberry Pi OTG connector (the one coming from the USB-C port on a Pi 4 via the custom splitter cable or device) should be connected to the USB 3 port on the ezCoo switch. There is an additional USB cable connected to the managed port on the switch. Connect the USB-C cable from the Raspberry Pi OTG port to ezCoo switch USB 3 port on the front or USB 1 port on the back of the switch. Note : If this cable is connected to the keyboard port (USB 2) of the ezCoo switch, the mouse will not be present. Connect the HDMI out from the ezCoo switch to the Raspberry Pi CSI-2 to HDMI input. Other users have reported HDMI encoder USB dongles as working. Connect a USB-A to Micro USB cable from the Raspberry Pi to the management port on the side of the ezCoo switch. Connect host USB and HDMI cables from the ezCoo switch to the machines to be managed per the switch instructions. At this point the KVM switch should be present as a device on the PiKVM. SSH into PiKVM and ensure a device like /dev/ttyUSB0 is present. The following instructions assume this is the KVM switch. Info There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi CSI2-HDMI encoder. These limitations apply equally when using the ezCoo KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the ezCoo switch before powering the hosts on.","title":"Connections"},{"location":"ezcoo/#adding-ui-elements-to-control-the-kvm-switch","text":"The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected. The instructions below will make these available in the PiKVM UI after clicking the \"GPIO\" menu button in the KVM view. Enable read-write mode on the SD card via rw Edit the file: nano /etc/kvmd/override.yaml and include the following. Note the assumption that the KVM switch is present on /dev/ttyUSB0 : kvmd : gpio : drivers : ez : type : ezcoo device : /dev/ttyUSB0 scheme : ch0_led : driver : ez pin : 0 mode : input ch1_led : driver : ez pin : 1 mode : input ch2_led : driver : ez pin : 2 mode : input ch3_led : driver : ez pin : 3 mode : input ch0_button : driver : ez pin : 0 mode : output switch : false ch1_button : driver : ez pin : 1 mode : output switch : false ch2_button : driver : ez pin : 2 mode : output switch : false ch3_button : driver : ez pin : 3 mode : output switch : false view : table : - [ \"#Input 1\" , ch0_led , ch0_button ] - [ \"#Input 2\" , ch1_led , ch1_button ] - [ \"#Input 3\" , ch2_led , ch2_button ] - [ \"#Input 4\" , ch3_led , ch3_button ] Editing '#Input X' will change the table name in the GUI drop down, if you want a different name, name it something else and restart kvmd. This now only applies to older images, newer images do not have this issue. Make sure to notate the spaces for each line, needs to be a total of 4 spaces added per line (NOT tabs): For example: parent: 0 spaces (kvmd:) child: 4 spaces (gpio:) sub-child: 8 spaces (drivers:) sub-sub-child: 12 spaces (ez:) Return to read-only mode for the sd card via ro . Restart the kvmd service: systemctl restart kvmd . If you are still not getting KB output, issue a ls -la /dev/tty* | grep USB , if no output change cables (Alot of cables are power only)","title":"Adding UI elements to control the KVM switch"},{"location":"ezcoo/#switching-between-hosts-in-the-ui","text":"To switch between hosts, enter the KVM UI and click the \"GPIO\" menu. You should see 4 inputs, one of which will have a green circle indicating it is currently selected. Click the other inputs to change the selected host.","title":"Switching between hosts in the UI"},{"location":"ezcoo/#additional-step-for-the-usb-30-version","text":"Please add protocol: 2 to the override.yaml under the type: ezcoo at the same level: kvmd : gpio : drivers : ez : type : ezcoo protocol : 2 device : /dev/ttyUSB0","title":"Additional step for the USB 3.0 version"},{"location":"ezcoo/#developer-info","text":"The official protocol version 1 reference Differences between protocols 1 and 2 =============================================================================================================================== =********************************************************Systems HELP*********************************************************= =-----------------------------------------------------------------------------------------------------------------------------= = System Address = 00 F/W Version : 1.20 = = Azz : All Commands start by Prefix System Address zz, if [01-99] = =-----------------------------------------------------------------------------------------------------------------------------= = EZH : Help = = EZSTA : Show Global System Status = = EZS RST : Reset to Factory Defaults = = EZS ADDR xx : Set System Address to xx {xx=[00~99](00=Single)} = = EZS CAS EN/DIS : Set Cascade Mode Enable/Disable = = EZS OUTx VS INy : Set Output x To Input y{x=[0~2](0=ALL), y=[1~4]} = = EZS IR SYS xx.yy : Set IR Custom Code{xx=[00-FFH],yy=[00-FFH]} = = EZS IR OUTx INy CODE zz : Set IR Data Code{x=[1~2],y=[1~4],zz=[00-FFH]} = = EZG ADDR : Get System Address = = EZG STA : Get System System Status = = EZG CAS : Get Cascade Mode Status = = EZG OUTx VS : Get Output x Video Route{x=[0~2](0=ALL)} = = EZG IR SYS : Get IR Custom Code = = EZG IR OUTx INy CODE : Get IR Data Code{x=[1~2],y=[1~4]} = = EZS OUTx VIDEOy : Set Output VIDEO Mode = = {x=[1~2], y=[1~2](1=BYPASS,2=4K->2K)} = =-----------------------------------------------------------------------------------------------------------------------------= =Input Setup Commands:(Note:input number(x)=HDMI(x),x=1) = = EZS INx EDID y : Set Input x EDID{x=[0~4](0=ALL), y=[0~15]} = = 0:EDID_BYPASS 1:1080P_2CH_HDR 2:1080P_6CH_HDR 3:1080P_8CH_HDR = = 4:1080P_3D_2CH_HDR 5:1080P_3D_6CH_HDR 6:1080P_3D_8CH_HDR = = 7:4K30HZ_3D_2CH_HDR 8:4K30HZ_3D_6CH_HDR 9:4K30HZ_3D_8CH_HDR = = 10:4K60HzY420_3D_2CH_HDR 11:4K60HzY420_3D_6CH_HDR 12:4K60HzY420_3D_8CH_HDR = = 13:4K60HZ_3D_2CH_HDR 14:4K60HZ_3D_6CH_HDR 15:4K60HZ_3D_8CH_HDR = = 16:H4K_DOLBY_VISION_ATMOS = = EZG INx EDID : Get Input x EDID Index{x=[0~4](0=ALL)} = =-----------------------------------------------------------------------------------------------------------------------------= =*****************************************************************************************************************************= ===============================================================================================================================","title":"Developer info"},{"location":"ezcoo/#simple-troubleshooting-steps-to-perform","text":"Video Issues: Hook a monitor to the output and test Reseat the cables Change out the cables Switching issues: SSH or open a web terminal to your PiKVM `ls -la /dev/ttyUSB*` - This should give you an output. If not, try a different cable till an output is displayed. EZCOO Wiring example can be found here","title":"Simple troubleshooting steps to perform"},{"location":"faq/","text":"FAQ & Troubleshooting \u00b6 As a first step, we recommend carefully reading our documentation on GitHub . Most steps to successfully set up your PiKVM are already described there. If you run into any issues you can check this page which will list common errors. If that still doesn't help you you're welcome to raise an issue ticket or join our Discord for further help. Tip If you can't find an answer to your question here, try the Community FAQ . It will be merged with this page in the future. Common questions \u00b6 Can I connect multiple servers to a single PiKVM? Yes, but it requires additional work to set up. See this page . How can I get the access to PiKVM in my local network over Internet? You can use port forwarding for port 443 on your router if it has an external IP address. In all other cases, you can use the excellent free VPN service Tailscale , which can be configured on PiKVM with a few simple commands . Can I assign a static IP to a PiKVM Edit file /etc/systemd/network/eth0.network for Ethernet or wlan0.network for Wi-Fi and edit the [Network] section: [Network] Address = 192.168.x.x/24 Gateway = 192.168.x.x DNS = 192.168.x.x DNS = 192.168.x.x If you're using Wi-Fi but you don't have /etc/systemd/network/wlan0.network file, then first you will need to migrate the Wi-Fi settings from netctl to systemd-networkd` . Can I use PiKVM for gaming? No, because: For HDMI-CSI bridge, bus bandwidth is not enough to transmit more than 1080p50. For HDMI-USB dongle, high latency and low video quality. General hardware video capture differs from software streaming and introduces additional latency. Can PiKVM do 4K video? For HDMI-CSI bridge, no. There is not enough bandwidth in the CSI bus for that much data. 1080p50 will max out the bandwidth. For the USB capture devices: technically yes, they will downsample to something smaller to meet the USB 2.0 bandwidth limitations, so the source may be 4k, but the stream will not. The 4K real-time video will not fit through the network anyway. Where does the cursor/video latency come from? Here is the chain of transferring an image to your browser or VNC client. Capture device -> Compression -> Network -> Decompression -> Rendering 100-200ms is very, very fast for this. But we are working to speed things up even more. Does PiKVM support sound? Yes but the only officially supported version is the v3 Pre-Assembled or HAT's, v2 we will attempt best effort but ultimatly we do not support CSI modules or USB. Can I power the Pi via PoE? Yes! But you still need to ensure you isolate the 5v connection between the Raspberry Pi and host PC to prevent backpower issues that can cause instability or damage to either the host PC or the Pi. Power/Data cable + USB power blocker would work. Do I need a power splitter? Why do I need one? Yes for RPi4 - Please see the main readme for splitter types listed under V2 Hardware Yes for Zero W and Zero W 2, if using dedicated power you still need to split the power from the data towards the target. If using the target for power, this is not needed. This is not needed if you have a v3 HAT, as the HAT splits power and signal on the board. Can I use PiKVM with non-Raspberry Pi boards (Orange, Nano, etc)? Yes, but you will have to prepare the operating system yourself. For the PiKVM software, you will need to replace some config files (such as UDEV rules). If you are a developer or an experienced system administrator, you will not have any problems with this. In addition, we are open to patches. If you need help with this, please contact us via Discord . Is PiKVM OS its own custom distro? No. PiKVM OS is an Arch Linux ARM with our own repository for KVM-related packages. We distribute OS images (that is, our Arch Linux ARM build) to simplify installation, since PiKVM requires some tuning of the OS and special partitioning of the memory card. Why is PiKVM OS based on Arch Linux ARM and not Raspbian / Raspberry Pi OS? There are several reasons: Several years ago, when PiKVM was just starting out, Raspbian didn't have a minimalistic image and the transition to systemd was in full swing, which is why the distribution was not too stable. Raspbian did not have all the necessary packages in the repositories to satisfy most software dependencies. PiKVM was born as a pet project, and the founder likes Arch the most. However, we plan to provide an alternative OS image based on Raspbian in the future - now it is quite stable. Can I use an iPad on PiKVM? Yes, with the correct hardware you can control an iPad. In the opposite sense - yes, use VNC and use JUMP app (fully-featured but more expensive), or bVNC (cheap). RealVNC does NOT work. How do I add my own SSL cert? If you have a certificate (making a cert falls outside the scope of PiKVM - please reference OpenSSL documentation or use Let's Encrypt ), replace keys in /etc/kvmd/nginx/ssl , edit /etc/kvmd/nginx/ssl.conf if necessary and restart kvmd-nginx service. How do I emulate various USB devices on the target machine? By default this is what is set: otg : manufacturer : PiKVM product : Composite KVM Device vendor_id : 0x1D6B product_id : 0x0104 serial : CAFEBABE You can change how this is displayed with the following example for /etc/kvmd/override.yaml file: otg : manufacturer : Corsair product : Corsair Gaming RGB vendor_id : 0x6940 product_id : 0x6973 serial : Use the following USB database to get the desired devices: https://the-sz.com/products/usbid or https://devicehunt.com . Can I run a desktop on PiKVM? Yes, but it's strongly not recommended OR supported as this OS should be used in read-only mode and it will need read-write enabled all of the time. Instructions here . How do I blank the oled screen? Please run the following: /usr/bin/kvmd-oled --height=32 --interval=5 --clear-on-exit --text=\"turn off in 5s\" systemctl disable --now kvmd-oled kvmd-oled-reboot kvmd-oled-shutdown I am getting a 500/503 error when I try and access the main KVM page! The latest images take care of these issues, please reflash and edit, otherwise follow the below. This is due to your recent changes in your yaml file; you have to use spaces and NOT tabs. Undo what you just did, then, systemctl restart kvmd , does it work again? Review what you added and take care of YAML syntax . For future edits there are some steps you can do to prevent this from happening again. Make a .nanorc file and populate it with the following: set tabsize 4 set tabstospaces Now re-edit your /etc/kvmd/override.yaml file and just use tab to get the right spacing, you might need to delete the current leading \"spaces\" to ensure proper formatting. How can I use the serial console to access to access other devices you need to stop the service which listens on the ttyAMA0: rw systemctl stop serial-getty@ttyAMA0.service If you want this change permanent (not starting again after reboot), you can disable this service, ('enable' to reverse this decision): systemctl disable serial-getty@ttyAMA0.service Note Only USB OR the RJ-45 serial connector will work, you can't use them together! If you disable the service permanently, you can't recover your device via serial console if you need this. There are some reports, that you need to remove \"ttyAMA0\" from /boot/cmdline.txt, but this is not needed on new installations. First steps \u00b6 I can't find the PiKVM IP address in my network Follow this guide . What is the default password? How do I change it? There are two types of accounts: OS and PiKVM (web interface) accounts. The system account root can be used for SSH/UART access and has the password root . The web interface account is called admin and has the password admin . The PiKVM account cannot be used for SSH access and vice versa. To change passwords, use the following commands (under root): su - # If you're in the webterm rw # Switch filesystem to read-write mode passwd root # Change OS root password kvmd-htpasswd set admin # Change web ui admin password ro # Back to read-only How do I get root access in the web terminal? The web terminal works with the account kvmd-webterm . This is a regular user with no administrator privileges. In addition, sudo and login are disabled for this user for security reasons. To get root access, you need to use the su - command (minus is important) and enter the root password . Where is the PiKVM configuration located? Almost all KVMD (the main daemon controlling PiKVM) configuration files are located in /etc/kvmd . You can also find nginx configs and SSL certificates there. KVMD configs use YAML syntax. The specific platform parameters can be found in the file /etc/kvmd/main.yaml and you should never edit it . Use /etc/kvmd/override.yaml to redefine the system parameters. Files that are not recommended for editing have read-only permissions. If you edit any of these files, you will need to manually make changes to them when you upgrade your system. You can view the current configuration and all available KVMD parameters using the command kvmd -m . I can't edit any file on PiKVM. Why is the system in read-only mode? The PiKVM file system is always mounted in read-only mode. This measure prevents it from being damaged by a sudden power outage. To change the configuration you must first switch the filesystem to write mode using the command rw from root. After the changes, be sure to run the command ro to switch it back to read-only. If you get a message that the file system is busy, then the easiest way is to perform a reboot . I want to get read-write filesystem all of the time DON'T DO THIS DON'T DO THIS DON'T DO THIS Seriously, DON'T . Read-only mode increases the life of the memory card and protects the filesystem from power loss failures. See the question above ^ ^ ^ You can turn it off, but don't say you weren't warned. DON'T OPEN THIS SPOILER AND DON'T DO THIS Okay, fine. Edit /boot/cmdline.txt and change option ro to rw . Do the same in /etc/fstab for the /boot partition. Comment tmpfs lines in /etc/fstab for /var/lib and /var/log . But again: DON'T DO THIS How do I install or remove packages in PiKVM OS? PiKVM OS is based on Arch Linux ARM and uses the pacman package manager. Switch filesystem to RW-mode: rw . Update the package cache: pacman -Syy . Find some packages ( emacs for example): pacman -Ss emacs . Install it: pacman -S emacs . Remove it: pacman -R emacs . Switch filesystem to RO-mode: ro . How do I update PiKVM with the latest software? This is ONLY recommended if you need a feature, otherwise this should ONLY be done if you are physically at the device and can reflash the sd card as a means of recovery. PiKVM OS is based on Arch Linux ARM and is fully updated from the repository by a regular package manager. Connect to your PiKVM via ssh and run: # rw # pacman -Syu # reboot Pacman saves all installed packages in a compressed format so that you can roll back to the old version if something goes wrong. After you've updated and made sure everything works, it makes sense to clear the package cache so that it doesn't take up space on the SD card: rw; rm -rf /var/cache/pacman/pkg; ro . I don't need ATX functions. How do I disable this in the Web UI? If you don't need ATX power control you can disable the relevant Web UI menu in /etc/kvmd/override.yaml : kvmd : atx : type : disabled ... then restart kvmd : # systemctl restart kvmd How do I disable the web terminal? # systemctl disable --now kvmd-webterm How do I completely disable authorization in PiKVM? Edit the file /etc/kvmd/override.yaml : kvmd : auth : enabled : false ... then restart kvmd : [root@pikvm ~]# systemctl restart kvmd Can I have different hostnames for each of my PiKVMs? Yes! And it's easy to do! Using a SSH session or the web terminal: * Make sure you are root, run rw then run hostnamectl set-hostname yournewhostname.domain . * Optional: edit /etc/kvmd/meta.yaml to alter the displayed hostname in the web UI. * Run ro and reboot . Video problems \u00b6 I can see the video but I can't see the WebRTC switch WebRTC is an alternative mode for the default MJPEG and it's only supported on v2+ platforms with the CSI video capture device. See this page to solve any problems with WebRTC. PiKVM does not show the video from the computer at all Double-check that the video capture device is connected correctly. For the CSI bridge , this should be exactly the camera port; for the USB dongle , strictly the port indicated in the picture. Some laptops do not output any signal until you switch the output (usually via the FN + and an F5 key on the keyboard). Your computer may have turned on sleep mode for the monitor. Move the mouse to turn it off. For windows you might need to check for the active signal resolution. To change the active signal resolution you have to go to Settings>System>Display>Advanced display settings>Display adapter properties then, click \"List All Models\" and choose the one you want. Keep trying different Hz settings. The video works in the booted OS, but not in the BIOS/UEFI This problem appears on Intel NUC, GA-H77-DS3H, and some other devices when using a CSI bridge. All you need to do is change the EDID data . This is the information about supported resolutions that the CSI bridge reports to your computer. Glitchy or wrong BIOS/UEFI resolution On some motherboards, the BIOS may be displayed at a lower resolution, or with some rendering issues/glitches, specially on newer ASUS ones. Like this: This can be solved by enabling the Compatibility Support Module (CSM) in your BIOS, usually under the Boot options. If you can't or don't want to enable the CSM, you can try connecting a DisplayPort (DP) monitor, or a dummy plug . If you remove the DP cable/adapter the bug will reappear. If none of this works, try connecting the DP cable first, boot into the BIOS, disable the CSM and shutdown (do not restart) your PC. Then, boot into the BIOS and enable the CSM before shutting down your PC. Then connect the HDMI and turn your PC on again. Why does the CSI bridge does not work with official Raspberry Pi PoE HAT? Details here . The reason is that the official HAT has a built-in fan controller that conflicts with the TC358743 chip of the bridge. The solution is to disable the fan control and connect the fan to the power line so that it works continuously. To turn off the controller you need to add the line disable_poe_fan=1 to /boot/config.txt . The video freezes a few seconds after the start, restarting the Web UI or VNC does not help The story is here . Very very rarely, Raspberry Pi boards can have a hardware defect that causes some of the chip blocks to be unstable under normal power. The solution is to slightly increase the power supply, as you would when overclocking. Add over_voltage=1 (or over_voltage=2 if previous doesn't help) to /boot/config.txt and perform reboot . To make sure that you are facing this particular problem, first perform a diagnostic: Boot the PiKVM without the specified options. Open Web-UI and wait for freezing. Click System -> Reset Stream . Click System -> Open log and make sure that the log contains messages like H264: Can't wait for the VCOS semaphore . Make sure that the last message from ustreamer was H264: Configuring MMAL encoder (not counting messages about connecting and disconnecting stream clients). No image from computer with Linux + Awesome WM Sometimes Awesome WM on Linux can't recognize a video output change on a cable. That is, if the cable was first inserted into the monitor, and then you reconnected it to PiKVM - it may happen that you will not see the image. It seems that the problem is Awesome WM, since for example with KDE, it is not reproducable. If you turn on your workstation with PiKVM already connected, everything will work fine. Windows shows limited Available Resolutions This is due to a driver issue. A possible resolution can be found here . USB problems (keyboard, mouse, mass storage, etc) \u00b6 My computer does not recognize USB of PiKVM v2+ at all Make sure that you have used the correct USB cable with DATA lines to connect the OTG port for the Raspberry to the computer. You may have decided to use a USB hub instead of a Y-cable and it won't work . Use good cables and follow the instructions :) In rare cases, some very buggy BIOSes do not like HID and Mass Storage in one USB device. You can either disable Mass Storage , or use an Arduino HID to physically separate them. BIOS/UEFI does not recognize USB of v2+, but computer does If you are using a USB hub or USB PCI controller, this may not be handled by your BIOS. Try to use another USB port. Some ports may have a built-in hub on the motherboard and a buggy BIOS that can't handle it. My keyboard works in BIOS/UEFI, but my mouse does not The BIOS does not support absolute mouse mode, which is preferred by PiKVM. In this case, you can enable relative or dual positioning mode . I can't wake up suspended computer on v2+ This feature is experimental and requires manual activation. Perform a full system update, edit /etc/kvmd/override.yaml , and reboot. After that, you can use remote wakeup by pressing any keyboard key or mouse button. otg : remote_wakeup : true My mass storage drive works (I can boot an image from PiKVM v2+), but my keyboard/mouse does not In rare cases, some very buggy BIOSes does not like HID and Mass Storage in one USB device. You can either disable Mass Storage , or use an Arduino HID to physically separate them. Buggy absolute mouse on Windows 98 as managed server How to fix: v2+/OTG . Arduino HID . There's big mouse latency on another Raspberry Pi as managed server Unusual case: RPi4 is used as a PiKVM to control RPi3. In this case, the mouse delay may be several seconds. To fix it, append usbhid.mousepoll=0 to the boot line in /boot/cmdline.txt on the managed server (i.e. RPI3 in our case) and reboot it. Source. What speed is the USB OTG port? Per the official RPI documentation, this is a limitation of the SoC. The OTG port is only USB2.0, so is limited to 455 Mbit/s. Web UI problems \u00b6 Chrome reports a Certificate Issue when I try to access the PiKVM web interface The latest versions of Chrome do not allow access to the page with a self signed certificate, so if you see the following screen when loading the PiKVM website: You can proceed by typing thisisunsafe and Chrome will then load the page. Also see Let's Encrypt page. Pressing ESC in full screen mode causes the PiKVM page to close Your browser does not support keyboard lock . Right now (January 2022), only Chromium implements this, so it works on Chrome, Edge, and Opera. I can't use the PiKVM web interface on iOS: the Web UI network indicator flashes yellow Safari on iOS contains an old bug that prevents a web application from connecting over a web socket if you use a self-signed certificate on the server (the default for PiKVM). There are two solutions: Install a valid SSL certificate for PiKVM host to /etc/kvmd/nginx/ssl . Disable HTTPS at all in /etc/kvmd/nginx/nginx.conf . To do this, comment some lines like in this file and restart web server: systemctl restart kvmd-nginx . Danger Don't do this for insecure networks or the Internet. Your passwords and what you type on the keyboard will be transmitted in unencrypted form. The Web UI doesn't work properly in Firefox while it works fine in Chrome This might be related to your specific hardware combination or browser hardware acceleration. Try disabling hardware acceleration in Firefox or updating your GPU and chipset drivers. Unexpected interruption while loading the image for Mass storage drive If problems occur when uploading even a small disk image it may be due to unstable network operation or antivirus software. It is well known that Kaspersky antivirus cuts off PiKVM connections during uploading, so you should add the PiKVM website to Kaspersky's list of exceptions or not filter web requests with the antivirus. Antivirus programs can also affect the performance of certain interface elements, for example the quality slider. For Kaspersky, the steps to add the network address of PiKVM's website to the exclusion list is: Protection -> Private browsing -> Categories and exclusions -> Exclusions . Hardware problems (Wi-Fi, ATX, etc) \u00b6 I can't connect to Wi-Fi on a Raspberry Pi Zero W Some Zeros contain a defective Wi-Fi chip. You can either return the device to the store, or try the software workaround . I can't connect to Wi-Fi at all! If your device is unable to connect to the Wi-Fi network that you have set up, check the 2.4 GHz Wi-Fi channel used by your Wi-Fi access point. If channels 12 to 14 are used (some countries have banned these channels) try to use a channel between 1 and 11. LEDs/Switches do not work in ATX control Double check your wiring as per the documentation . Make sure you placed the relays (G3VM-61A1) in the correct orientation. The relays for switches (Power, Reset) have a different orientation than the ones for LEDs. My PiKVM keeps disconnecting from the Wi-Fi network Try to edit /etc/conf.d/wireless-regdom and look for your region and uncomment it. For example: WIRELESS_REGDOM=\"US\" . PiKVM complains about low power warnings Are you using a \"proper\" power supply? Not one you hacked together? Some USB power bricks advertise 5V 2.1A or higher, but can't deliver consistent 5V. Best to use Raspberry Pi Foundation recommended power supplies. PiKVM complains about a RTC low voltage detected, date/time is not reliable This is mearly a warning that can be ignored however, the following resolves the issue: Leave plugged in for 24+ hours and or Connect to the internet using the eth cable, the internal NTP service will set the time accordlingly Force a time sync: rw && hwclock --systohc\" or \"rw && hwclock -w\" Set date and time manually can be found here.","title":"FAQ"},{"location":"faq/#faq-troubleshooting","text":"As a first step, we recommend carefully reading our documentation on GitHub . Most steps to successfully set up your PiKVM are already described there. If you run into any issues you can check this page which will list common errors. If that still doesn't help you you're welcome to raise an issue ticket or join our Discord for further help. Tip If you can't find an answer to your question here, try the Community FAQ . It will be merged with this page in the future.","title":"FAQ &amp; Troubleshooting"},{"location":"faq/#common-questions","text":"Can I connect multiple servers to a single PiKVM? Yes, but it requires additional work to set up. See this page . How can I get the access to PiKVM in my local network over Internet? You can use port forwarding for port 443 on your router if it has an external IP address. In all other cases, you can use the excellent free VPN service Tailscale , which can be configured on PiKVM with a few simple commands . Can I assign a static IP to a PiKVM Edit file /etc/systemd/network/eth0.network for Ethernet or wlan0.network for Wi-Fi and edit the [Network] section: [Network] Address = 192.168.x.x/24 Gateway = 192.168.x.x DNS = 192.168.x.x DNS = 192.168.x.x If you're using Wi-Fi but you don't have /etc/systemd/network/wlan0.network file, then first you will need to migrate the Wi-Fi settings from netctl to systemd-networkd` . Can I use PiKVM for gaming? No, because: For HDMI-CSI bridge, bus bandwidth is not enough to transmit more than 1080p50. For HDMI-USB dongle, high latency and low video quality. General hardware video capture differs from software streaming and introduces additional latency. Can PiKVM do 4K video? For HDMI-CSI bridge, no. There is not enough bandwidth in the CSI bus for that much data. 1080p50 will max out the bandwidth. For the USB capture devices: technically yes, they will downsample to something smaller to meet the USB 2.0 bandwidth limitations, so the source may be 4k, but the stream will not. The 4K real-time video will not fit through the network anyway. Where does the cursor/video latency come from? Here is the chain of transferring an image to your browser or VNC client. Capture device -> Compression -> Network -> Decompression -> Rendering 100-200ms is very, very fast for this. But we are working to speed things up even more. Does PiKVM support sound? Yes but the only officially supported version is the v3 Pre-Assembled or HAT's, v2 we will attempt best effort but ultimatly we do not support CSI modules or USB. Can I power the Pi via PoE? Yes! But you still need to ensure you isolate the 5v connection between the Raspberry Pi and host PC to prevent backpower issues that can cause instability or damage to either the host PC or the Pi. Power/Data cable + USB power blocker would work. Do I need a power splitter? Why do I need one? Yes for RPi4 - Please see the main readme for splitter types listed under V2 Hardware Yes for Zero W and Zero W 2, if using dedicated power you still need to split the power from the data towards the target. If using the target for power, this is not needed. This is not needed if you have a v3 HAT, as the HAT splits power and signal on the board. Can I use PiKVM with non-Raspberry Pi boards (Orange, Nano, etc)? Yes, but you will have to prepare the operating system yourself. For the PiKVM software, you will need to replace some config files (such as UDEV rules). If you are a developer or an experienced system administrator, you will not have any problems with this. In addition, we are open to patches. If you need help with this, please contact us via Discord . Is PiKVM OS its own custom distro? No. PiKVM OS is an Arch Linux ARM with our own repository for KVM-related packages. We distribute OS images (that is, our Arch Linux ARM build) to simplify installation, since PiKVM requires some tuning of the OS and special partitioning of the memory card. Why is PiKVM OS based on Arch Linux ARM and not Raspbian / Raspberry Pi OS? There are several reasons: Several years ago, when PiKVM was just starting out, Raspbian didn't have a minimalistic image and the transition to systemd was in full swing, which is why the distribution was not too stable. Raspbian did not have all the necessary packages in the repositories to satisfy most software dependencies. PiKVM was born as a pet project, and the founder likes Arch the most. However, we plan to provide an alternative OS image based on Raspbian in the future - now it is quite stable. Can I use an iPad on PiKVM? Yes, with the correct hardware you can control an iPad. In the opposite sense - yes, use VNC and use JUMP app (fully-featured but more expensive), or bVNC (cheap). RealVNC does NOT work. How do I add my own SSL cert? If you have a certificate (making a cert falls outside the scope of PiKVM - please reference OpenSSL documentation or use Let's Encrypt ), replace keys in /etc/kvmd/nginx/ssl , edit /etc/kvmd/nginx/ssl.conf if necessary and restart kvmd-nginx service. How do I emulate various USB devices on the target machine? By default this is what is set: otg : manufacturer : PiKVM product : Composite KVM Device vendor_id : 0x1D6B product_id : 0x0104 serial : CAFEBABE You can change how this is displayed with the following example for /etc/kvmd/override.yaml file: otg : manufacturer : Corsair product : Corsair Gaming RGB vendor_id : 0x6940 product_id : 0x6973 serial : Use the following USB database to get the desired devices: https://the-sz.com/products/usbid or https://devicehunt.com . Can I run a desktop on PiKVM? Yes, but it's strongly not recommended OR supported as this OS should be used in read-only mode and it will need read-write enabled all of the time. Instructions here . How do I blank the oled screen? Please run the following: /usr/bin/kvmd-oled --height=32 --interval=5 --clear-on-exit --text=\"turn off in 5s\" systemctl disable --now kvmd-oled kvmd-oled-reboot kvmd-oled-shutdown I am getting a 500/503 error when I try and access the main KVM page! The latest images take care of these issues, please reflash and edit, otherwise follow the below. This is due to your recent changes in your yaml file; you have to use spaces and NOT tabs. Undo what you just did, then, systemctl restart kvmd , does it work again? Review what you added and take care of YAML syntax . For future edits there are some steps you can do to prevent this from happening again. Make a .nanorc file and populate it with the following: set tabsize 4 set tabstospaces Now re-edit your /etc/kvmd/override.yaml file and just use tab to get the right spacing, you might need to delete the current leading \"spaces\" to ensure proper formatting. How can I use the serial console to access to access other devices you need to stop the service which listens on the ttyAMA0: rw systemctl stop serial-getty@ttyAMA0.service If you want this change permanent (not starting again after reboot), you can disable this service, ('enable' to reverse this decision): systemctl disable serial-getty@ttyAMA0.service Note Only USB OR the RJ-45 serial connector will work, you can't use them together! If you disable the service permanently, you can't recover your device via serial console if you need this. There are some reports, that you need to remove \"ttyAMA0\" from /boot/cmdline.txt, but this is not needed on new installations.","title":"Common questions"},{"location":"faq/#first-steps","text":"I can't find the PiKVM IP address in my network Follow this guide . What is the default password? How do I change it? There are two types of accounts: OS and PiKVM (web interface) accounts. The system account root can be used for SSH/UART access and has the password root . The web interface account is called admin and has the password admin . The PiKVM account cannot be used for SSH access and vice versa. To change passwords, use the following commands (under root): su - # If you're in the webterm rw # Switch filesystem to read-write mode passwd root # Change OS root password kvmd-htpasswd set admin # Change web ui admin password ro # Back to read-only How do I get root access in the web terminal? The web terminal works with the account kvmd-webterm . This is a regular user with no administrator privileges. In addition, sudo and login are disabled for this user for security reasons. To get root access, you need to use the su - command (minus is important) and enter the root password . Where is the PiKVM configuration located? Almost all KVMD (the main daemon controlling PiKVM) configuration files are located in /etc/kvmd . You can also find nginx configs and SSL certificates there. KVMD configs use YAML syntax. The specific platform parameters can be found in the file /etc/kvmd/main.yaml and you should never edit it . Use /etc/kvmd/override.yaml to redefine the system parameters. Files that are not recommended for editing have read-only permissions. If you edit any of these files, you will need to manually make changes to them when you upgrade your system. You can view the current configuration and all available KVMD parameters using the command kvmd -m . I can't edit any file on PiKVM. Why is the system in read-only mode? The PiKVM file system is always mounted in read-only mode. This measure prevents it from being damaged by a sudden power outage. To change the configuration you must first switch the filesystem to write mode using the command rw from root. After the changes, be sure to run the command ro to switch it back to read-only. If you get a message that the file system is busy, then the easiest way is to perform a reboot . I want to get read-write filesystem all of the time DON'T DO THIS DON'T DO THIS DON'T DO THIS Seriously, DON'T . Read-only mode increases the life of the memory card and protects the filesystem from power loss failures. See the question above ^ ^ ^ You can turn it off, but don't say you weren't warned. DON'T OPEN THIS SPOILER AND DON'T DO THIS Okay, fine. Edit /boot/cmdline.txt and change option ro to rw . Do the same in /etc/fstab for the /boot partition. Comment tmpfs lines in /etc/fstab for /var/lib and /var/log . But again: DON'T DO THIS How do I install or remove packages in PiKVM OS? PiKVM OS is based on Arch Linux ARM and uses the pacman package manager. Switch filesystem to RW-mode: rw . Update the package cache: pacman -Syy . Find some packages ( emacs for example): pacman -Ss emacs . Install it: pacman -S emacs . Remove it: pacman -R emacs . Switch filesystem to RO-mode: ro . How do I update PiKVM with the latest software? This is ONLY recommended if you need a feature, otherwise this should ONLY be done if you are physically at the device and can reflash the sd card as a means of recovery. PiKVM OS is based on Arch Linux ARM and is fully updated from the repository by a regular package manager. Connect to your PiKVM via ssh and run: # rw # pacman -Syu # reboot Pacman saves all installed packages in a compressed format so that you can roll back to the old version if something goes wrong. After you've updated and made sure everything works, it makes sense to clear the package cache so that it doesn't take up space on the SD card: rw; rm -rf /var/cache/pacman/pkg; ro . I don't need ATX functions. How do I disable this in the Web UI? If you don't need ATX power control you can disable the relevant Web UI menu in /etc/kvmd/override.yaml : kvmd : atx : type : disabled ... then restart kvmd : # systemctl restart kvmd How do I disable the web terminal? # systemctl disable --now kvmd-webterm How do I completely disable authorization in PiKVM? Edit the file /etc/kvmd/override.yaml : kvmd : auth : enabled : false ... then restart kvmd : [root@pikvm ~]# systemctl restart kvmd Can I have different hostnames for each of my PiKVMs? Yes! And it's easy to do! Using a SSH session or the web terminal: * Make sure you are root, run rw then run hostnamectl set-hostname yournewhostname.domain . * Optional: edit /etc/kvmd/meta.yaml to alter the displayed hostname in the web UI. * Run ro and reboot .","title":"First steps"},{"location":"faq/#video-problems","text":"I can see the video but I can't see the WebRTC switch WebRTC is an alternative mode for the default MJPEG and it's only supported on v2+ platforms with the CSI video capture device. See this page to solve any problems with WebRTC. PiKVM does not show the video from the computer at all Double-check that the video capture device is connected correctly. For the CSI bridge , this should be exactly the camera port; for the USB dongle , strictly the port indicated in the picture. Some laptops do not output any signal until you switch the output (usually via the FN + and an F5 key on the keyboard). Your computer may have turned on sleep mode for the monitor. Move the mouse to turn it off. For windows you might need to check for the active signal resolution. To change the active signal resolution you have to go to Settings>System>Display>Advanced display settings>Display adapter properties then, click \"List All Models\" and choose the one you want. Keep trying different Hz settings. The video works in the booted OS, but not in the BIOS/UEFI This problem appears on Intel NUC, GA-H77-DS3H, and some other devices when using a CSI bridge. All you need to do is change the EDID data . This is the information about supported resolutions that the CSI bridge reports to your computer. Glitchy or wrong BIOS/UEFI resolution On some motherboards, the BIOS may be displayed at a lower resolution, or with some rendering issues/glitches, specially on newer ASUS ones. Like this: This can be solved by enabling the Compatibility Support Module (CSM) in your BIOS, usually under the Boot options. If you can't or don't want to enable the CSM, you can try connecting a DisplayPort (DP) monitor, or a dummy plug . If you remove the DP cable/adapter the bug will reappear. If none of this works, try connecting the DP cable first, boot into the BIOS, disable the CSM and shutdown (do not restart) your PC. Then, boot into the BIOS and enable the CSM before shutting down your PC. Then connect the HDMI and turn your PC on again. Why does the CSI bridge does not work with official Raspberry Pi PoE HAT? Details here . The reason is that the official HAT has a built-in fan controller that conflicts with the TC358743 chip of the bridge. The solution is to disable the fan control and connect the fan to the power line so that it works continuously. To turn off the controller you need to add the line disable_poe_fan=1 to /boot/config.txt . The video freezes a few seconds after the start, restarting the Web UI or VNC does not help The story is here . Very very rarely, Raspberry Pi boards can have a hardware defect that causes some of the chip blocks to be unstable under normal power. The solution is to slightly increase the power supply, as you would when overclocking. Add over_voltage=1 (or over_voltage=2 if previous doesn't help) to /boot/config.txt and perform reboot . To make sure that you are facing this particular problem, first perform a diagnostic: Boot the PiKVM without the specified options. Open Web-UI and wait for freezing. Click System -> Reset Stream . Click System -> Open log and make sure that the log contains messages like H264: Can't wait for the VCOS semaphore . Make sure that the last message from ustreamer was H264: Configuring MMAL encoder (not counting messages about connecting and disconnecting stream clients). No image from computer with Linux + Awesome WM Sometimes Awesome WM on Linux can't recognize a video output change on a cable. That is, if the cable was first inserted into the monitor, and then you reconnected it to PiKVM - it may happen that you will not see the image. It seems that the problem is Awesome WM, since for example with KDE, it is not reproducable. If you turn on your workstation with PiKVM already connected, everything will work fine. Windows shows limited Available Resolutions This is due to a driver issue. A possible resolution can be found here .","title":"Video problems"},{"location":"faq/#usb-problems-keyboard-mouse-mass-storage-etc","text":"My computer does not recognize USB of PiKVM v2+ at all Make sure that you have used the correct USB cable with DATA lines to connect the OTG port for the Raspberry to the computer. You may have decided to use a USB hub instead of a Y-cable and it won't work . Use good cables and follow the instructions :) In rare cases, some very buggy BIOSes do not like HID and Mass Storage in one USB device. You can either disable Mass Storage , or use an Arduino HID to physically separate them. BIOS/UEFI does not recognize USB of v2+, but computer does If you are using a USB hub or USB PCI controller, this may not be handled by your BIOS. Try to use another USB port. Some ports may have a built-in hub on the motherboard and a buggy BIOS that can't handle it. My keyboard works in BIOS/UEFI, but my mouse does not The BIOS does not support absolute mouse mode, which is preferred by PiKVM. In this case, you can enable relative or dual positioning mode . I can't wake up suspended computer on v2+ This feature is experimental and requires manual activation. Perform a full system update, edit /etc/kvmd/override.yaml , and reboot. After that, you can use remote wakeup by pressing any keyboard key or mouse button. otg : remote_wakeup : true My mass storage drive works (I can boot an image from PiKVM v2+), but my keyboard/mouse does not In rare cases, some very buggy BIOSes does not like HID and Mass Storage in one USB device. You can either disable Mass Storage , or use an Arduino HID to physically separate them. Buggy absolute mouse on Windows 98 as managed server How to fix: v2+/OTG . Arduino HID . There's big mouse latency on another Raspberry Pi as managed server Unusual case: RPi4 is used as a PiKVM to control RPi3. In this case, the mouse delay may be several seconds. To fix it, append usbhid.mousepoll=0 to the boot line in /boot/cmdline.txt on the managed server (i.e. RPI3 in our case) and reboot it. Source. What speed is the USB OTG port? Per the official RPI documentation, this is a limitation of the SoC. The OTG port is only USB2.0, so is limited to 455 Mbit/s.","title":"USB problems (keyboard, mouse, mass storage, etc)"},{"location":"faq/#web-ui-problems","text":"Chrome reports a Certificate Issue when I try to access the PiKVM web interface The latest versions of Chrome do not allow access to the page with a self signed certificate, so if you see the following screen when loading the PiKVM website: You can proceed by typing thisisunsafe and Chrome will then load the page. Also see Let's Encrypt page. Pressing ESC in full screen mode causes the PiKVM page to close Your browser does not support keyboard lock . Right now (January 2022), only Chromium implements this, so it works on Chrome, Edge, and Opera. I can't use the PiKVM web interface on iOS: the Web UI network indicator flashes yellow Safari on iOS contains an old bug that prevents a web application from connecting over a web socket if you use a self-signed certificate on the server (the default for PiKVM). There are two solutions: Install a valid SSL certificate for PiKVM host to /etc/kvmd/nginx/ssl . Disable HTTPS at all in /etc/kvmd/nginx/nginx.conf . To do this, comment some lines like in this file and restart web server: systemctl restart kvmd-nginx . Danger Don't do this for insecure networks or the Internet. Your passwords and what you type on the keyboard will be transmitted in unencrypted form. The Web UI doesn't work properly in Firefox while it works fine in Chrome This might be related to your specific hardware combination or browser hardware acceleration. Try disabling hardware acceleration in Firefox or updating your GPU and chipset drivers. Unexpected interruption while loading the image for Mass storage drive If problems occur when uploading even a small disk image it may be due to unstable network operation or antivirus software. It is well known that Kaspersky antivirus cuts off PiKVM connections during uploading, so you should add the PiKVM website to Kaspersky's list of exceptions or not filter web requests with the antivirus. Antivirus programs can also affect the performance of certain interface elements, for example the quality slider. For Kaspersky, the steps to add the network address of PiKVM's website to the exclusion list is: Protection -> Private browsing -> Categories and exclusions -> Exclusions .","title":"Web UI problems"},{"location":"faq/#hardware-problems-wi-fi-atx-etc","text":"I can't connect to Wi-Fi on a Raspberry Pi Zero W Some Zeros contain a defective Wi-Fi chip. You can either return the device to the store, or try the software workaround . I can't connect to Wi-Fi at all! If your device is unable to connect to the Wi-Fi network that you have set up, check the 2.4 GHz Wi-Fi channel used by your Wi-Fi access point. If channels 12 to 14 are used (some countries have banned these channels) try to use a channel between 1 and 11. LEDs/Switches do not work in ATX control Double check your wiring as per the documentation . Make sure you placed the relays (G3VM-61A1) in the correct orientation. The relays for switches (Power, Reset) have a different orientation than the ones for LEDs. My PiKVM keeps disconnecting from the Wi-Fi network Try to edit /etc/conf.d/wireless-regdom and look for your region and uncomment it. For example: WIRELESS_REGDOM=\"US\" . PiKVM complains about low power warnings Are you using a \"proper\" power supply? Not one you hacked together? Some USB power bricks advertise 5V 2.1A or higher, but can't deliver consistent 5V. Best to use Raspberry Pi Foundation recommended power supplies. PiKVM complains about a RTC low voltage detected, date/time is not reliable This is mearly a warning that can be ignored however, the following resolves the issue: Leave plugged in for 24+ hours and or Connect to the internet using the eth cable, the internal NTP service will set the time accordlingly Force a time sync: rw && hwclock --systohc\" or \"rw && hwclock -w\" Set date and time manually can be found here.","title":"Hardware problems (Wi-Fi, ATX, etc)"},{"location":"first_steps/","text":"First steps \u00b6 First power on \u00b6 Warning For v2 DIY owners, please follow this first For v3 HAT Users, please follow this first Optional setting up Wi-Fi Please read the following caveats There is nothing more reliable than wired Ethernet, so it's better to use the cable . But who are we to stop you... :) Adding FIRSTBOOT=1 or FIRSTBOOT-1 will erase the msd partition, if used afterwords as a means of switching wifi networks, do not include this option. Instead, use different supplicant files for each wifi SSID, mv files to the supplicant dir as needed and reboot. pikvm.txt will be removed once its been used. You will need to recreate it again if you did not provide the correct info If you want to connect PiKVM to a Wi-Fi network, you need to tell the device ESSID and password before first boot. To do this, mount the first partition of the memory card (FAT32) and edit or make the pikvm.txt file there. Do not remove line FIRSTBOOT=1 or FIRST_BOOT-1 for first time booting, just add your wifi settings like this: FIRSTBOOT=1 WIFI_ESSID=\"mynet\" WIFI_PASSWD=\"p@s$$w0rd\" There is a possibility that, in countries that support CH13, the device will not connect. You will need to configure your router to disable channels 12-14 or disable Auto scan mode so it will connect. Save, unmount and follow the next step. Power up the device. Do not turn off the device until it's fully booted for the first time After turning on the power, PiKVM OS will generate unique SSH keys and certificates and will perform the necessary operations on the memory card. Getting access to PiKVM \u00b6 By default, PiKVM receives a dynamic IP address via DHCP. Finding PiKVM in the network To determine the IP address of your PiKVM, use one of the following methods: Common way: Open the web interface of your router and find the list of issued IP addresses there. It depends on the router model. Linux-only: Use command arp-scan --localnet . Linux, MacOS, Windows: Download and run Angry IP Scanner . Windows PowerShell: Use command arp -a . In order to find your RaspberryPi using the arp commands, you need to look for the following MAC Address's: B827EB, DCA632 or E45F01 For future examples, let's assume that your PiKVM has received the address 192.168.0.100 , which you have successfully detected using the instructions above. Then your device was assigned a hostname: pikvm . Access to PiKVM Web Interface In MOST networks you should be able to reach PiKVM via any browser with the URL https://192.168.0.100/ OR https://pikvm/ . Google Chrome (Chromium), Firefox and Safari work best with 0 extensions enabled, if one works but the others do not, this is a browser/extension issue. Its advised you use Private window or Incog mode. Microsoft Edge and Internet Explorer are not supported. The default user is admin and the password is also admin . After logging in, you will get access to the menu with the main functions. Using the Web terminal, you can change system settings and passwords. The latest versions of Chrome on Mac OS do not allow access to the page with a self signed certificate, which is used in PiKVM by default. You can proceed by typing thisisunsafe and Chrome will then load the page. Access to PiKVM via SSH SSH is the most common remote access method in the Linux world. PiKVM is accessible via SSH. This method is used to manage the device: Linux, MacOS: Open any terminal application and run: ssh root@192.168.0.100 or ssh root@pikvm . Windows: Use PuTTY for this. The default root password is root . OPTIONAL: Update PiKVM software This part is not nessessary for a working OOB experience and should only be performed if you are physically at the PiKVM to recover it, you however, may benifit from performing the below actions. These are the instructions: rw pacman -Syu reboot \u272e \u272e \u272e CHANGE THE PASSWORDS! \u272e \u272e \u272e PiKVM comes with the following default passwords: Linux admin (SSH, etc.): user root , password root . PiKVM Web Interface : user admin , password admin . These are two separate entities with independent accounts. To change passwords, you will need to use the terminal (read below) access via SSH or Web Terminal. If you are using the Web Terminal, use the su - command to get root access (enter the root user password). # rw # passwd root # kvmd-htpasswd set admin # ro If you require additional user changes you can use the following: # kvmd-htpasswd set <user> # Sets a new user # kvmd-htpasswd del <user> # Removes/deletes a user Configuring PiKVM \u00b6 Most of the PiKVM settings are done through configuration files. All configuration changes must be made from under the root user (that is, the administrator). Obtaining root access If you have logged in via SSH, then most likely you are already root . To get root in the Web Terminal, use command su - and enter the root password. The PiKVM memory card is mounted in read-only mode. It protects the filesystem from damage in case of sudden power outage. To edit any files and make changes, it is necessary to remount the file system to the read-write mode. Enabling write mode To enable write-mode, run command rw (under root ). To disable it, run command ro . If you receive the message \"Device is busy\", perform reboot . In this handbook, you will often find instructions for editing configuration files. The simplest and most beginner-friendly text editor is nano , but you can also use vim . Editing files in the Web Terminal $ su - # rw # nano /etc/kvmd/override.yaml # ro Structure of configuration files \u00b6 Most of the PiKVM configuration files are located in the /etc/kvmd directory. The /etc/kvmd/main.yaml file defines the platform config and you should never edit it . To redefine system parameters use the file /etc/kvmd/override.yaml . All other files that are also not recommended for editing have read-only permissions. In the /etc/kvmd/meta.yaml file you can specify some information regarding the host that this PiKVM manages. Tip A complete list of all parameters can be viewed using the kvmd -m command. Files with the suffix *.yaml uses the YAML syntax and describes a parameter tree with key-value pairs of different types. To define the parameters within one section, an indent of 4 spaces is used. Comments starts with the # symbol. Only 4 spaces should be used for indentation Be careful when editing YAML and follow this rule. Invalid indentation or tabs instead of spaces will cause an error when starting the services. Sections under the same keys should be merged Wrong: kvmd : gpio : drivers : ... kvmd : gpio : scheme : ... Correct: kvmd : gpio : drivers : ... scheme : ... What's next? \u00b6 Set up Internet access using port forwarding or Tailscale VPN . Explore PiKVM features using the table of contents on the left. Join our Discord to contact the community and developers. Check out the GitHub - PiKVM is a fully Open Source project! FAQ and Troubleshooting \u00b6 If you have any questions or run into problems, take a look at the FAQ . Seriously, it's really useful! We've probably already found a solution for it :) For any other help and support, you can contact us via the Discord chat .","title":"First steps"},{"location":"first_steps/#first-steps","text":"","title":"First steps"},{"location":"first_steps/#first-power-on","text":"Warning For v2 DIY owners, please follow this first For v3 HAT Users, please follow this first Optional setting up Wi-Fi Please read the following caveats There is nothing more reliable than wired Ethernet, so it's better to use the cable . But who are we to stop you... :) Adding FIRSTBOOT=1 or FIRSTBOOT-1 will erase the msd partition, if used afterwords as a means of switching wifi networks, do not include this option. Instead, use different supplicant files for each wifi SSID, mv files to the supplicant dir as needed and reboot. pikvm.txt will be removed once its been used. You will need to recreate it again if you did not provide the correct info If you want to connect PiKVM to a Wi-Fi network, you need to tell the device ESSID and password before first boot. To do this, mount the first partition of the memory card (FAT32) and edit or make the pikvm.txt file there. Do not remove line FIRSTBOOT=1 or FIRST_BOOT-1 for first time booting, just add your wifi settings like this: FIRSTBOOT=1 WIFI_ESSID=\"mynet\" WIFI_PASSWD=\"p@s$$w0rd\" There is a possibility that, in countries that support CH13, the device will not connect. You will need to configure your router to disable channels 12-14 or disable Auto scan mode so it will connect. Save, unmount and follow the next step. Power up the device. Do not turn off the device until it's fully booted for the first time After turning on the power, PiKVM OS will generate unique SSH keys and certificates and will perform the necessary operations on the memory card.","title":"First power on"},{"location":"first_steps/#getting-access-to-pikvm","text":"By default, PiKVM receives a dynamic IP address via DHCP. Finding PiKVM in the network To determine the IP address of your PiKVM, use one of the following methods: Common way: Open the web interface of your router and find the list of issued IP addresses there. It depends on the router model. Linux-only: Use command arp-scan --localnet . Linux, MacOS, Windows: Download and run Angry IP Scanner . Windows PowerShell: Use command arp -a . In order to find your RaspberryPi using the arp commands, you need to look for the following MAC Address's: B827EB, DCA632 or E45F01 For future examples, let's assume that your PiKVM has received the address 192.168.0.100 , which you have successfully detected using the instructions above. Then your device was assigned a hostname: pikvm . Access to PiKVM Web Interface In MOST networks you should be able to reach PiKVM via any browser with the URL https://192.168.0.100/ OR https://pikvm/ . Google Chrome (Chromium), Firefox and Safari work best with 0 extensions enabled, if one works but the others do not, this is a browser/extension issue. Its advised you use Private window or Incog mode. Microsoft Edge and Internet Explorer are not supported. The default user is admin and the password is also admin . After logging in, you will get access to the menu with the main functions. Using the Web terminal, you can change system settings and passwords. The latest versions of Chrome on Mac OS do not allow access to the page with a self signed certificate, which is used in PiKVM by default. You can proceed by typing thisisunsafe and Chrome will then load the page. Access to PiKVM via SSH SSH is the most common remote access method in the Linux world. PiKVM is accessible via SSH. This method is used to manage the device: Linux, MacOS: Open any terminal application and run: ssh root@192.168.0.100 or ssh root@pikvm . Windows: Use PuTTY for this. The default root password is root . OPTIONAL: Update PiKVM software This part is not nessessary for a working OOB experience and should only be performed if you are physically at the PiKVM to recover it, you however, may benifit from performing the below actions. These are the instructions: rw pacman -Syu reboot \u272e \u272e \u272e CHANGE THE PASSWORDS! \u272e \u272e \u272e PiKVM comes with the following default passwords: Linux admin (SSH, etc.): user root , password root . PiKVM Web Interface : user admin , password admin . These are two separate entities with independent accounts. To change passwords, you will need to use the terminal (read below) access via SSH or Web Terminal. If you are using the Web Terminal, use the su - command to get root access (enter the root user password). # rw # passwd root # kvmd-htpasswd set admin # ro If you require additional user changes you can use the following: # kvmd-htpasswd set <user> # Sets a new user # kvmd-htpasswd del <user> # Removes/deletes a user","title":"Getting access to PiKVM"},{"location":"first_steps/#configuring-pikvm","text":"Most of the PiKVM settings are done through configuration files. All configuration changes must be made from under the root user (that is, the administrator). Obtaining root access If you have logged in via SSH, then most likely you are already root . To get root in the Web Terminal, use command su - and enter the root password. The PiKVM memory card is mounted in read-only mode. It protects the filesystem from damage in case of sudden power outage. To edit any files and make changes, it is necessary to remount the file system to the read-write mode. Enabling write mode To enable write-mode, run command rw (under root ). To disable it, run command ro . If you receive the message \"Device is busy\", perform reboot . In this handbook, you will often find instructions for editing configuration files. The simplest and most beginner-friendly text editor is nano , but you can also use vim . Editing files in the Web Terminal $ su - # rw # nano /etc/kvmd/override.yaml # ro","title":"Configuring PiKVM"},{"location":"first_steps/#structure-of-configuration-files","text":"Most of the PiKVM configuration files are located in the /etc/kvmd directory. The /etc/kvmd/main.yaml file defines the platform config and you should never edit it . To redefine system parameters use the file /etc/kvmd/override.yaml . All other files that are also not recommended for editing have read-only permissions. In the /etc/kvmd/meta.yaml file you can specify some information regarding the host that this PiKVM manages. Tip A complete list of all parameters can be viewed using the kvmd -m command. Files with the suffix *.yaml uses the YAML syntax and describes a parameter tree with key-value pairs of different types. To define the parameters within one section, an indent of 4 spaces is used. Comments starts with the # symbol. Only 4 spaces should be used for indentation Be careful when editing YAML and follow this rule. Invalid indentation or tabs instead of spaces will cause an error when starting the services. Sections under the same keys should be merged Wrong: kvmd : gpio : drivers : ... kvmd : gpio : scheme : ... Correct: kvmd : gpio : drivers : ... scheme : ...","title":"Structure of configuration files"},{"location":"first_steps/#whats-next","text":"Set up Internet access using port forwarding or Tailscale VPN . Explore PiKVM features using the table of contents on the left. Join our Discord to contact the community and developers. Check out the GitHub - PiKVM is a fully Open Source project!","title":"What's next?"},{"location":"first_steps/#faq-and-troubleshooting","text":"If you have any questions or run into problems, take a look at the FAQ . Seriously, it's really useful! We've probably already found a solution for it :) For any other help and support, you can contact us via the Discord chat .","title":"FAQ and Troubleshooting"},{"location":"flashing_hid/","text":"Flashing the Arduino HID \u00b6 TTL Firmware (the default option) \u00b6 This operation can be done using your RPi (except Pi Zero W). Here the common steps: Disconnect the RESET wire from the Arduino board. Connect the Arduino and RPi with a suitable USB cable. Log in to the Raspberry Pi using SSH ( ssh root@<addr> with password root by default) or using keyboard and monitor. The Raspberry Pi obtains the network address over DHCP. Upload the firmware (USB keyboard & mouse is used by default, on this step you can choose PS/2 keyboard ): [ root@pikvm ~ ] # rw [ root@pikvm ~ ] # systemctl stop kvmd [ root@pikvm ~ ] # cp -r /usr/share/kvmd/hid ~ [ root@pikvm ~ ] # cd ~/hid [ root@pikvm hid ] # make [ root@pikvm hid ] # make install [ root@pikvm hid ] # reboot Connect the RESET wire, disconnect the USB cable, and reboot the RPi. With a Pi Zero W, you may consider building the firmware on a faster system and programming using USB or booting from another SD card and following the build steps using a clone of the KVMD repo . SPI Firmware \u00b6 This operation can be done using your Raspberry Pi without disconnecting any wires: Connect the Arduino and RPi with a suitable USB cable. Log in to the Raspberry Pi using SSH ( ssh root@<addr> with password root by default) or using keyboard and monitor. The Raspberry Pi obtains the network address over DHCP. Execute rw , add line dtoverlay=spi0-1cs to /boot/config.txt and perform reboot . Build and upload the firmware (USB keyboard & mouse is used by default) [ root@pikvm ~ ] # rw [ root@pikvm ~ ] # systemctl stop kvmd [ root@pikvm ~ ] # cp -r /usr/share/kvmd/hid ~ [ root@pikvm ~ ] # cd ~/hid [ root@pikvm hid ] # make spi [ root@pikvm hid ] # make install [ root@pikvm hid ] # reboot Common Errors \u00b6 Circuit Issues \u00b6 Common - Reset Wire \u00b6 Different pins are used for the reset wire but serve a similar function. For programming the TTL firmware over USB, the reset wire should be disconnected. When programming using SPI, the reset wire needs to be connected through a transistor circuit and connected to GPIO25 (pin 22 on the GPIO header) SPI-specific Wiring \u00b6 The 3v3, ground, Reset (GPIO25), MISO, MOSI, SCLK, and CS1 need to be connected appropriately. SPIO_CS0 and SPIO_CS1 can both be used but the default configuration uses SPIO_CS1 for the Arduino Microcontroller (CS0 is used for another device on the v3). These generally follow a block as follows: Pin 0 2 4 2 0 0 .........GR.C....... Row # 12345678901234567890 ........3MMS........ Pin 0 1 3 1 7 9 The most common error is an \"off-by-one\" error where pins are shifted by a row. Some cases have non-standard GPIO layouts so please be careful when following these instructions using a case that has a modified pinout. Library Compatibility \u00b6 On make install you may encounter the following error: /root/.platformio/packages/tool-avrdude/avrdude: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory Create a symlink for this library: # ln -s /usr/lib/libtinfo.so.6 /usr/lib/libtinfo.so.5 ... and run make install again. If you have any problems or questions, contact us using Discord . Example SPI build + Flash \u00b6 Here's an end-to-end build and flash of the SPI HID firmware using the default options as described above [root@pikvm ~]# rw [root@pikvm ~]# systemctl stop kvmd [root@pikvm ~]# cp -r /usr/share/kvmd/hid ~ [root@pikvm ~]# cd ~/hid [root@pikvm hid]# make spi make _build E=spi make[1]: Entering directory '/root/hid' rm -f .current platformio run --environment spi ************************************************************************************************************************************ If you like PlatformIO, please: - follow us on Twitter to stay up-to-date on the latest project news > https://twitter.com/PlatformIO_Org - star it on GitHub > https://github.com/platformio/platformio - try PlatformIO IDE for embedded development > https://platformio.org/platformio-ide ************************************************************************************************************************************ Processing spi (platform: atmelavr; board: micro; framework: arduino) ------------------------------------------------------------------------------------------------------------------------------------ Platform Manager: Installing atmelavr Unpacking [####################################] 100% Platform Manager: atmelavr @ 3.1.0 has been installed! The platform 'atmelavr' has been successfully installed! The rest of the packages will be installed later depending on your build environment. Tool Manager: Installing platformio/toolchain-atmelavr @ ~1.50400.0 Downloading [####################################] 100% Unpacking [####################################] 100% Tool Manager: toolchain-atmelavr @ 1.50400.190710 has been installed! Tool Manager: Installing platformio/framework-arduino-avr @ ~5.1.0 Downloading [####################################] 100% Unpacking [####################################] 100% Tool Manager: framework-arduino-avr @ 5.1.0 has been installed! Tool Manager: Installing platformio/tool-avrdude @ * Tool Manager: tool-avrdude @ 1.60300.200527 has been installed! Tool Manager: Installing platformio/tool-scons @ ~4.40001.0 Unpacking [####################################] 100% Tool Manager: tool-scons @ 4.40001.0 has been installed! Verbose mode can be enabled via `-v, --verbose` option patch([], []) patch([], []) CONFIGURATION: https://docs.platformio.org/page/boards/atmelavr/micro.html PLATFORM: Atmel AVR (3.1.0) > Arduino Micro HARDWARE: ATMEGA32U4 16MHz, 2.50KB RAM, 28KB Flash DEBUG: Current (simavr) On-board (simavr) PACKAGES: - framework-arduino-avr 5.1.0 - tool-avrdude 1.60300.200527 (6.3.0) - toolchain-atmelavr 1.50400.190710 (5.4.0) LDF: Library Dependency Finder -> http://bit.ly/configure-pio-ldf LDF Modes: Finder ~ chain, Compatibility ~ soft Library Manager: Installing HID-Project @ 2.6.1 Library Manager: HID-Project @ 2.6.1 has been installed! Library Manager: Installing git+https://github.com/Harvie/ps2dev#v0.0.3 git version 2.30.0 Cloning into '/root/hid/.platformio/.cache/tmp/pkg-installing-84arveu0'... Note: switching to 'a043002178450772d72a58b0c42752a506fd4dea'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -c with the switch command. Example: git switch -c <new-branch-name> Or undo this operation with: git switch - Turn off this advice by setting config variable advice.detachedHead to false Library Manager: ps2dev @ 0.0.3+sha.a043002 has been installed! Library Manager: Installing digitalWriteFast @ 1.0.0 Library Manager: digitalWriteFast @ 1.0.0 has been installed! Found 8 compatible libraries Scanning dependencies... Dependency Graph |-- <HID-Project> 2.6.1 | |-- <HID> 1.0 |-- <ps2dev> 0.0.3+sha.a043002 |-- <digitalWriteFast> 1.0.0 |-- <SPI> 1.0 Building in release mode patch -p1 -d /root/hid/.platformio/packages/framework-arduino-avr < patches/no-main.patch patching file cores/arduino/main.cpp <lambda>([], []) patch -p1 -d /root/hid/.platformio/packages/framework-arduino-avr < patches/optional-usb-serial.patch patching file cores/arduino/PluggableUSB.cpp patching file cores/arduino/USBCore.cpp <lambda>([], []) patch -p1 -d /root/hid/.platformio/packages/framework-arduino-avr < patches/get-plugged-endpoint.patch patching file cores/arduino/PluggableUSB.h <lambda>([], []) patch -p1 -d /root/hid/.pio/libdeps/spi/HID-Project < patches/shut-up.patch patching file src/KeyboardLayouts/ImprovedKeylayouts.h <lambda>([], []) patch -p1 -d /root/hid/.pio/libdeps/spi/HID-Project < patches/no-hid-singletones.patch patching file src/SingleReport/BootKeyboard.cpp patching file src/SingleReport/BootKeyboard.h patching file src/SingleReport/BootMouse.cpp patching file src/SingleReport/BootMouse.h patching file src/SingleReport/SingleAbsoluteMouse.cpp patching file src/SingleReport/SingleAbsoluteMouse.h <lambda>([], []) patch -p1 -d /root/hid/.pio/libdeps/spi/HID-Project < patches/absmouse-win-fix.patch patching file src/SingleReport/SingleAbsoluteMouse.cpp <lambda>([], []) Compiling .pio/build/spi/src/main.cpp.o Compiling .pio/build/spi/src/spi.cpp.o Compiling .pio/build/spi/lib2d3/HID/HID.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/AbsoluteMouse.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/Consumer.cpp.o Archiving .pio/build/spi/lib2d3/libHID.a Indexing .pio/build/spi/lib2d3/libHID.a Compiling .pio/build/spi/libd81/HID-Project/MultiReport/Gamepad.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/ImprovedKeyboard.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/ImprovedMouse.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/NKROKeyboard.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/SurfaceDial.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/System.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/BootKeyboard.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/BootMouse.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/RawHID.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleAbsoluteMouse.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleConsumer.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleGamepad.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleNKROKeyboard.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleSystem.cpp.o Compiling .pio/build/spi/libd81/HID-Project/port/samd.cpp.o Compiling .pio/build/spi/libeaf/ps2dev/ps2dev.cpp.o Archiving .pio/build/spi/lib822/libdigitalWriteFast.a Indexing .pio/build/spi/lib822/libdigitalWriteFast.a Compiling .pio/build/spi/lib519/SPI/SPI.cpp.o .pio/libdeps/spi/ps2dev/src/ps2dev.cpp: In member function 'int PS2dev::keyboard_reply(unsigned char, unsigned char*)': .pio/libdeps/spi/ps2dev/src/ps2dev.cpp:243:17: warning: variable 'enabled' set but not used [-Wunused-but-set-variable] unsigned char enabled; ^ Archiving .pio/build/spi/libd81/libHID-Project.a Archiving .pio/build/spi/libFrameworkArduinoVariant.a Indexing .pio/build/spi/libFrameworkArduinoVariant.a Indexing .pio/build/spi/libd81/libHID-Project.a Compiling .pio/build/spi/FrameworkArduino/CDC.cpp.o Archiving .pio/build/spi/lib519/libSPI.a Archiving .pio/build/spi/libeaf/libps2dev.a Indexing .pio/build/spi/lib519/libSPI.a Indexing .pio/build/spi/libeaf/libps2dev.a Compiling .pio/build/spi/FrameworkArduino/HardwareSerial.cpp.o Compiling .pio/build/spi/FrameworkArduino/HardwareSerial0.cpp.o Compiling .pio/build/spi/FrameworkArduino/HardwareSerial1.cpp.o Compiling .pio/build/spi/FrameworkArduino/HardwareSerial2.cpp.o Compiling .pio/build/spi/FrameworkArduino/HardwareSerial3.cpp.o Compiling .pio/build/spi/FrameworkArduino/IPAddress.cpp.o Compiling .pio/build/spi/FrameworkArduino/PluggableUSB.cpp.o Compiling .pio/build/spi/FrameworkArduino/Print.cpp.o Compiling .pio/build/spi/FrameworkArduino/Stream.cpp.o Compiling .pio/build/spi/FrameworkArduino/Tone.cpp.o Compiling .pio/build/spi/FrameworkArduino/USBCore.cpp.o Compiling .pio/build/spi/FrameworkArduino/WInterrupts.c.o Compiling .pio/build/spi/FrameworkArduino/WMath.cpp.o .platformio/packages/framework-arduino-avr/cores/arduino/USBCore.cpp: In function 'bool ClassInterfaceRequest(USBSetup&)': .platformio/packages/framework-arduino-avr/cores/arduino/USBCore.cpp:378:5: warning: unused variable 'i' [-Wunused-variable] u8 i = setup.wIndex; ^ Compiling .pio/build/spi/FrameworkArduino/WString.cpp.o Compiling .pio/build/spi/FrameworkArduino/abi.cpp.o Compiling .pio/build/spi/FrameworkArduino/hooks.c.o Compiling .pio/build/spi/FrameworkArduino/main.cpp.o Compiling .pio/build/spi/FrameworkArduino/new.cpp.o Compiling .pio/build/spi/FrameworkArduino/wiring.c.o Compiling .pio/build/spi/FrameworkArduino/wiring_analog.c.o Compiling .pio/build/spi/FrameworkArduino/wiring_digital.c.o Compiling .pio/build/spi/FrameworkArduino/wiring_pulse.S.o Compiling .pio/build/spi/FrameworkArduino/wiring_pulse.c.o Compiling .pio/build/spi/FrameworkArduino/wiring_shift.c.o Archiving .pio/build/spi/libFrameworkArduino.a Indexing .pio/build/spi/libFrameworkArduino.a Linking .pio/build/spi/firmware.elf Building .pio/build/spi/firmware.hex Checking size .pio/build/spi/firmware.elf Advanced Memory Usage is available via \"PlatformIO Home > Project Inspect\" RAM: [= ] 9.9% (used 253 bytes from 2560 bytes) Flash: [=== ] 34.7% (used 9952 bytes from 28672 bytes) =================================================== [SUCCESS] Took 56.86 seconds =================================================== Environment Status Duration ------------- -------- ------------ spi SUCCESS 00:00:56.861 =================================================== 1 succeeded in 00:00:56.861 =================================================== ************************************************************************************************************************************ There is a new version 5.1.0 of PlatformIO available. Please upgrade it via `platformio upgrade` or `pip install -U platformio` command. Changes: https://docs.platformio.org/en/latest/history.html ************************************************************************************************************************************ echo -n spi > .current make[1]: Leaving directory '/root/hid' [root@pikvm hid]# make install platformio run --environment spi --target upload Processing spi (platform: atmelavr; board: micro; framework: arduino) ------------------------------------------------------------------------------------------------------------------------------------ Verbose mode can be enabled via `-v, --verbose` option CONFIGURATION: https://docs.platformio.org/page/boards/atmelavr/micro.html PLATFORM: Atmel AVR (3.1.0) > Arduino Micro HARDWARE: ATMEGA32U4 16MHz, 2.50KB RAM, 28KB Flash DEBUG: Current (simavr) On-board (simavr) PACKAGES: - framework-arduino-avr 5.1.0 - tool-avrdude 1.60300.200527 (6.3.0) - toolchain-atmelavr 1.50400.190710 (5.4.0) LDF: Library Dependency Finder -> http://bit.ly/configure-pio-ldf LDF Modes: Finder ~ chain, Compatibility ~ soft Found 8 compatible libraries Scanning dependencies... Dependency Graph |-- <HID-Project> 2.6.1 | |-- <HID> 1.0 |-- <ps2dev> 0.0.3+sha.a043002 |-- <digitalWriteFast> 1.0.0 |-- <SPI> 1.0 Building in release mode Checking size .pio/build/spi/firmware.elf Advanced Memory Usage is available via \"PlatformIO Home > Project Inspect\" RAM: [= ] 9.9% (used 253 bytes from 2560 bytes) Flash: [=== ] 34.7% (used 9952 bytes from 28672 bytes) Configuring upload protocol... AVAILABLE: custom CURRENT: upload_protocol = custom Uploading .pio/build/spi/firmware.hex avrdude: AVR device initialized and ready to accept instructions Reading | ################################################## | 100% 0.00s avrdude: Device signature = 0x1e9587 (probably m32u4) avrdude: NOTE: \"flash\" memory has been specified, an erase cycle will be performed To disable this feature, specify the -D option. avrdude: erasing chip avrdude: reading input file \".pio/build/spi/firmware.hex\" avrdude: writing flash (9952 bytes): Writing | ################################################## | 100% 2.78s avrdude: 9952 bytes of flash written avrdude: verifying flash memory against .pio/build/spi/firmware.hex: avrdude: load data flash data from input file .pio/build/spi/firmware.hex: avrdude: input file .pio/build/spi/firmware.hex contains 9952 bytes avrdude: reading on-chip flash data: Reading | ################################################## | 100% 2.33s avrdude: verifying ... avrdude: 9952 bytes of flash verified avrdude: safemode: Fuses OK (E:CB, H:D8, L:FF) avrdude done. Thank you. =================================================== [SUCCESS] Took 7.54 seconds =================================================== Environment Status Duration ------------- -------- ------------ spi SUCCESS 00:00:07.536 =================================================== 1 succeeded in 00:00:07.536 =================================================== [root@pikvm hid]# reboot","title":"Flashing the Arduino HID"},{"location":"flashing_hid/#flashing-the-arduino-hid","text":"","title":"Flashing the Arduino HID"},{"location":"flashing_hid/#ttl-firmware-the-default-option","text":"This operation can be done using your RPi (except Pi Zero W). Here the common steps: Disconnect the RESET wire from the Arduino board. Connect the Arduino and RPi with a suitable USB cable. Log in to the Raspberry Pi using SSH ( ssh root@<addr> with password root by default) or using keyboard and monitor. The Raspberry Pi obtains the network address over DHCP. Upload the firmware (USB keyboard & mouse is used by default, on this step you can choose PS/2 keyboard ): [ root@pikvm ~ ] # rw [ root@pikvm ~ ] # systemctl stop kvmd [ root@pikvm ~ ] # cp -r /usr/share/kvmd/hid ~ [ root@pikvm ~ ] # cd ~/hid [ root@pikvm hid ] # make [ root@pikvm hid ] # make install [ root@pikvm hid ] # reboot Connect the RESET wire, disconnect the USB cable, and reboot the RPi. With a Pi Zero W, you may consider building the firmware on a faster system and programming using USB or booting from another SD card and following the build steps using a clone of the KVMD repo .","title":"TTL Firmware (the default option)"},{"location":"flashing_hid/#spi-firmware","text":"This operation can be done using your Raspberry Pi without disconnecting any wires: Connect the Arduino and RPi with a suitable USB cable. Log in to the Raspberry Pi using SSH ( ssh root@<addr> with password root by default) or using keyboard and monitor. The Raspberry Pi obtains the network address over DHCP. Execute rw , add line dtoverlay=spi0-1cs to /boot/config.txt and perform reboot . Build and upload the firmware (USB keyboard & mouse is used by default) [ root@pikvm ~ ] # rw [ root@pikvm ~ ] # systemctl stop kvmd [ root@pikvm ~ ] # cp -r /usr/share/kvmd/hid ~ [ root@pikvm ~ ] # cd ~/hid [ root@pikvm hid ] # make spi [ root@pikvm hid ] # make install [ root@pikvm hid ] # reboot","title":"SPI Firmware"},{"location":"flashing_hid/#common-errors","text":"","title":"Common Errors"},{"location":"flashing_hid/#circuit-issues","text":"","title":"Circuit Issues"},{"location":"flashing_hid/#common-reset-wire","text":"Different pins are used for the reset wire but serve a similar function. For programming the TTL firmware over USB, the reset wire should be disconnected. When programming using SPI, the reset wire needs to be connected through a transistor circuit and connected to GPIO25 (pin 22 on the GPIO header)","title":"Common - Reset Wire"},{"location":"flashing_hid/#spi-specific-wiring","text":"The 3v3, ground, Reset (GPIO25), MISO, MOSI, SCLK, and CS1 need to be connected appropriately. SPIO_CS0 and SPIO_CS1 can both be used but the default configuration uses SPIO_CS1 for the Arduino Microcontroller (CS0 is used for another device on the v3). These generally follow a block as follows: Pin 0 2 4 2 0 0 .........GR.C....... Row # 12345678901234567890 ........3MMS........ Pin 0 1 3 1 7 9 The most common error is an \"off-by-one\" error where pins are shifted by a row. Some cases have non-standard GPIO layouts so please be careful when following these instructions using a case that has a modified pinout.","title":"SPI-specific Wiring"},{"location":"flashing_hid/#library-compatibility","text":"On make install you may encounter the following error: /root/.platformio/packages/tool-avrdude/avrdude: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory Create a symlink for this library: # ln -s /usr/lib/libtinfo.so.6 /usr/lib/libtinfo.so.5 ... and run make install again. If you have any problems or questions, contact us using Discord .","title":"Library Compatibility"},{"location":"flashing_hid/#example-spi-build-flash","text":"Here's an end-to-end build and flash of the SPI HID firmware using the default options as described above [root@pikvm ~]# rw [root@pikvm ~]# systemctl stop kvmd [root@pikvm ~]# cp -r /usr/share/kvmd/hid ~ [root@pikvm ~]# cd ~/hid [root@pikvm hid]# make spi make _build E=spi make[1]: Entering directory '/root/hid' rm -f .current platformio run --environment spi ************************************************************************************************************************************ If you like PlatformIO, please: - follow us on Twitter to stay up-to-date on the latest project news > https://twitter.com/PlatformIO_Org - star it on GitHub > https://github.com/platformio/platformio - try PlatformIO IDE for embedded development > https://platformio.org/platformio-ide ************************************************************************************************************************************ Processing spi (platform: atmelavr; board: micro; framework: arduino) ------------------------------------------------------------------------------------------------------------------------------------ Platform Manager: Installing atmelavr Unpacking [####################################] 100% Platform Manager: atmelavr @ 3.1.0 has been installed! The platform 'atmelavr' has been successfully installed! The rest of the packages will be installed later depending on your build environment. Tool Manager: Installing platformio/toolchain-atmelavr @ ~1.50400.0 Downloading [####################################] 100% Unpacking [####################################] 100% Tool Manager: toolchain-atmelavr @ 1.50400.190710 has been installed! Tool Manager: Installing platformio/framework-arduino-avr @ ~5.1.0 Downloading [####################################] 100% Unpacking [####################################] 100% Tool Manager: framework-arduino-avr @ 5.1.0 has been installed! Tool Manager: Installing platformio/tool-avrdude @ * Tool Manager: tool-avrdude @ 1.60300.200527 has been installed! Tool Manager: Installing platformio/tool-scons @ ~4.40001.0 Unpacking [####################################] 100% Tool Manager: tool-scons @ 4.40001.0 has been installed! Verbose mode can be enabled via `-v, --verbose` option patch([], []) patch([], []) CONFIGURATION: https://docs.platformio.org/page/boards/atmelavr/micro.html PLATFORM: Atmel AVR (3.1.0) > Arduino Micro HARDWARE: ATMEGA32U4 16MHz, 2.50KB RAM, 28KB Flash DEBUG: Current (simavr) On-board (simavr) PACKAGES: - framework-arduino-avr 5.1.0 - tool-avrdude 1.60300.200527 (6.3.0) - toolchain-atmelavr 1.50400.190710 (5.4.0) LDF: Library Dependency Finder -> http://bit.ly/configure-pio-ldf LDF Modes: Finder ~ chain, Compatibility ~ soft Library Manager: Installing HID-Project @ 2.6.1 Library Manager: HID-Project @ 2.6.1 has been installed! Library Manager: Installing git+https://github.com/Harvie/ps2dev#v0.0.3 git version 2.30.0 Cloning into '/root/hid/.platformio/.cache/tmp/pkg-installing-84arveu0'... Note: switching to 'a043002178450772d72a58b0c42752a506fd4dea'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -c with the switch command. Example: git switch -c <new-branch-name> Or undo this operation with: git switch - Turn off this advice by setting config variable advice.detachedHead to false Library Manager: ps2dev @ 0.0.3+sha.a043002 has been installed! Library Manager: Installing digitalWriteFast @ 1.0.0 Library Manager: digitalWriteFast @ 1.0.0 has been installed! Found 8 compatible libraries Scanning dependencies... Dependency Graph |-- <HID-Project> 2.6.1 | |-- <HID> 1.0 |-- <ps2dev> 0.0.3+sha.a043002 |-- <digitalWriteFast> 1.0.0 |-- <SPI> 1.0 Building in release mode patch -p1 -d /root/hid/.platformio/packages/framework-arduino-avr < patches/no-main.patch patching file cores/arduino/main.cpp <lambda>([], []) patch -p1 -d /root/hid/.platformio/packages/framework-arduino-avr < patches/optional-usb-serial.patch patching file cores/arduino/PluggableUSB.cpp patching file cores/arduino/USBCore.cpp <lambda>([], []) patch -p1 -d /root/hid/.platformio/packages/framework-arduino-avr < patches/get-plugged-endpoint.patch patching file cores/arduino/PluggableUSB.h <lambda>([], []) patch -p1 -d /root/hid/.pio/libdeps/spi/HID-Project < patches/shut-up.patch patching file src/KeyboardLayouts/ImprovedKeylayouts.h <lambda>([], []) patch -p1 -d /root/hid/.pio/libdeps/spi/HID-Project < patches/no-hid-singletones.patch patching file src/SingleReport/BootKeyboard.cpp patching file src/SingleReport/BootKeyboard.h patching file src/SingleReport/BootMouse.cpp patching file src/SingleReport/BootMouse.h patching file src/SingleReport/SingleAbsoluteMouse.cpp patching file src/SingleReport/SingleAbsoluteMouse.h <lambda>([], []) patch -p1 -d /root/hid/.pio/libdeps/spi/HID-Project < patches/absmouse-win-fix.patch patching file src/SingleReport/SingleAbsoluteMouse.cpp <lambda>([], []) Compiling .pio/build/spi/src/main.cpp.o Compiling .pio/build/spi/src/spi.cpp.o Compiling .pio/build/spi/lib2d3/HID/HID.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/AbsoluteMouse.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/Consumer.cpp.o Archiving .pio/build/spi/lib2d3/libHID.a Indexing .pio/build/spi/lib2d3/libHID.a Compiling .pio/build/spi/libd81/HID-Project/MultiReport/Gamepad.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/ImprovedKeyboard.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/ImprovedMouse.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/NKROKeyboard.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/SurfaceDial.cpp.o Compiling .pio/build/spi/libd81/HID-Project/MultiReport/System.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/BootKeyboard.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/BootMouse.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/RawHID.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleAbsoluteMouse.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleConsumer.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleGamepad.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleNKROKeyboard.cpp.o Compiling .pio/build/spi/libd81/HID-Project/SingleReport/SingleSystem.cpp.o Compiling .pio/build/spi/libd81/HID-Project/port/samd.cpp.o Compiling .pio/build/spi/libeaf/ps2dev/ps2dev.cpp.o Archiving .pio/build/spi/lib822/libdigitalWriteFast.a Indexing .pio/build/spi/lib822/libdigitalWriteFast.a Compiling .pio/build/spi/lib519/SPI/SPI.cpp.o .pio/libdeps/spi/ps2dev/src/ps2dev.cpp: In member function 'int PS2dev::keyboard_reply(unsigned char, unsigned char*)': .pio/libdeps/spi/ps2dev/src/ps2dev.cpp:243:17: warning: variable 'enabled' set but not used [-Wunused-but-set-variable] unsigned char enabled; ^ Archiving .pio/build/spi/libd81/libHID-Project.a Archiving .pio/build/spi/libFrameworkArduinoVariant.a Indexing .pio/build/spi/libFrameworkArduinoVariant.a Indexing .pio/build/spi/libd81/libHID-Project.a Compiling .pio/build/spi/FrameworkArduino/CDC.cpp.o Archiving .pio/build/spi/lib519/libSPI.a Archiving .pio/build/spi/libeaf/libps2dev.a Indexing .pio/build/spi/lib519/libSPI.a Indexing .pio/build/spi/libeaf/libps2dev.a Compiling .pio/build/spi/FrameworkArduino/HardwareSerial.cpp.o Compiling .pio/build/spi/FrameworkArduino/HardwareSerial0.cpp.o Compiling .pio/build/spi/FrameworkArduino/HardwareSerial1.cpp.o Compiling .pio/build/spi/FrameworkArduino/HardwareSerial2.cpp.o Compiling .pio/build/spi/FrameworkArduino/HardwareSerial3.cpp.o Compiling .pio/build/spi/FrameworkArduino/IPAddress.cpp.o Compiling .pio/build/spi/FrameworkArduino/PluggableUSB.cpp.o Compiling .pio/build/spi/FrameworkArduino/Print.cpp.o Compiling .pio/build/spi/FrameworkArduino/Stream.cpp.o Compiling .pio/build/spi/FrameworkArduino/Tone.cpp.o Compiling .pio/build/spi/FrameworkArduino/USBCore.cpp.o Compiling .pio/build/spi/FrameworkArduino/WInterrupts.c.o Compiling .pio/build/spi/FrameworkArduino/WMath.cpp.o .platformio/packages/framework-arduino-avr/cores/arduino/USBCore.cpp: In function 'bool ClassInterfaceRequest(USBSetup&)': .platformio/packages/framework-arduino-avr/cores/arduino/USBCore.cpp:378:5: warning: unused variable 'i' [-Wunused-variable] u8 i = setup.wIndex; ^ Compiling .pio/build/spi/FrameworkArduino/WString.cpp.o Compiling .pio/build/spi/FrameworkArduino/abi.cpp.o Compiling .pio/build/spi/FrameworkArduino/hooks.c.o Compiling .pio/build/spi/FrameworkArduino/main.cpp.o Compiling .pio/build/spi/FrameworkArduino/new.cpp.o Compiling .pio/build/spi/FrameworkArduino/wiring.c.o Compiling .pio/build/spi/FrameworkArduino/wiring_analog.c.o Compiling .pio/build/spi/FrameworkArduino/wiring_digital.c.o Compiling .pio/build/spi/FrameworkArduino/wiring_pulse.S.o Compiling .pio/build/spi/FrameworkArduino/wiring_pulse.c.o Compiling .pio/build/spi/FrameworkArduino/wiring_shift.c.o Archiving .pio/build/spi/libFrameworkArduino.a Indexing .pio/build/spi/libFrameworkArduino.a Linking .pio/build/spi/firmware.elf Building .pio/build/spi/firmware.hex Checking size .pio/build/spi/firmware.elf Advanced Memory Usage is available via \"PlatformIO Home > Project Inspect\" RAM: [= ] 9.9% (used 253 bytes from 2560 bytes) Flash: [=== ] 34.7% (used 9952 bytes from 28672 bytes) =================================================== [SUCCESS] Took 56.86 seconds =================================================== Environment Status Duration ------------- -------- ------------ spi SUCCESS 00:00:56.861 =================================================== 1 succeeded in 00:00:56.861 =================================================== ************************************************************************************************************************************ There is a new version 5.1.0 of PlatformIO available. Please upgrade it via `platformio upgrade` or `pip install -U platformio` command. Changes: https://docs.platformio.org/en/latest/history.html ************************************************************************************************************************************ echo -n spi > .current make[1]: Leaving directory '/root/hid' [root@pikvm hid]# make install platformio run --environment spi --target upload Processing spi (platform: atmelavr; board: micro; framework: arduino) ------------------------------------------------------------------------------------------------------------------------------------ Verbose mode can be enabled via `-v, --verbose` option CONFIGURATION: https://docs.platformio.org/page/boards/atmelavr/micro.html PLATFORM: Atmel AVR (3.1.0) > Arduino Micro HARDWARE: ATMEGA32U4 16MHz, 2.50KB RAM, 28KB Flash DEBUG: Current (simavr) On-board (simavr) PACKAGES: - framework-arduino-avr 5.1.0 - tool-avrdude 1.60300.200527 (6.3.0) - toolchain-atmelavr 1.50400.190710 (5.4.0) LDF: Library Dependency Finder -> http://bit.ly/configure-pio-ldf LDF Modes: Finder ~ chain, Compatibility ~ soft Found 8 compatible libraries Scanning dependencies... Dependency Graph |-- <HID-Project> 2.6.1 | |-- <HID> 1.0 |-- <ps2dev> 0.0.3+sha.a043002 |-- <digitalWriteFast> 1.0.0 |-- <SPI> 1.0 Building in release mode Checking size .pio/build/spi/firmware.elf Advanced Memory Usage is available via \"PlatformIO Home > Project Inspect\" RAM: [= ] 9.9% (used 253 bytes from 2560 bytes) Flash: [=== ] 34.7% (used 9952 bytes from 28672 bytes) Configuring upload protocol... AVAILABLE: custom CURRENT: upload_protocol = custom Uploading .pio/build/spi/firmware.hex avrdude: AVR device initialized and ready to accept instructions Reading | ################################################## | 100% 0.00s avrdude: Device signature = 0x1e9587 (probably m32u4) avrdude: NOTE: \"flash\" memory has been specified, an erase cycle will be performed To disable this feature, specify the -D option. avrdude: erasing chip avrdude: reading input file \".pio/build/spi/firmware.hex\" avrdude: writing flash (9952 bytes): Writing | ################################################## | 100% 2.78s avrdude: 9952 bytes of flash written avrdude: verifying flash memory against .pio/build/spi/firmware.hex: avrdude: load data flash data from input file .pio/build/spi/firmware.hex: avrdude: input file .pio/build/spi/firmware.hex contains 9952 bytes avrdude: reading on-chip flash data: Reading | ################################################## | 100% 2.33s avrdude: verifying ... avrdude: 9952 bytes of flash verified avrdude: safemode: Fuses OK (E:CB, H:D8, L:FF) avrdude done. Thank you. =================================================== [SUCCESS] Took 7.54 seconds =================================================== Environment Status Duration ------------- -------- ------------ spi SUCCESS 00:00:07.536 =================================================== 1 succeeded in 00:00:07.536 =================================================== [root@pikvm hid]# reboot","title":"Example SPI build + Flash"},{"location":"flashing_os/","text":"Flashing the OS image \u00b6 Micro-SD Card Requirements Minimum 16 Gb Class 10 is strongly recommended Download the image \u00b6 Download the appropriate SD card image. Select it based on the board, platform, and the video capture device you are using: V3 HAT (Patron, Kickstarter, and future editions) PiKVM v3 HAT BOX Image (Raspberry Pi 4) OLED/FAN preactivated - sha1 PiKVM v3 HAT DIY Assembly (Raspberry Pi 4) - sha1 DIY - Raspberry Pi 4, v2 platform: For HDMI-CSI bridge - sha1 For HDMI-USB dongle - sha1 DIY - Raspberry Pi Zero 2 W, v2 platform: For HDMI-CSI bridge - sha1 DIY - Raspberry Pi Zero W (legacy), v2 platform: For HDMI-CSI bridge - sha1 Pre-compiled images are only available for the Raspberry Pi 4 and Zero (2) W. For all other cases, you will need to build the operating system yourself. But don't worry, it's very simple . Flash the image \u00b6 Tip Ignore request to format your sd card, this step is not nessessary. Choose the most suitable method for you Using Linux CLI \u00b6 Decompress and flash the image. Be careful when choosing the device path, it may be different on your OS : # xz --decompress v2-hdmi-rpi4-latest.img.xz # dd if=v2-hdmi-rpi4-latest.img of=/dev/mmcblkX You can also use dd_rescue or ddrescue . Check the advanced settings (CTRL+SHIFT+X), make sure they are blank or the flash will fail Using RPi Imager (Linux, MacOS and Windows) \u00b6 Download and install the latest version of RPi Imager . Run RPi Imager: Press CHOOSE OS and select Use custom image at bottom of the list: After clicking on this item, select the image file ( .img.xz ), then click CHOOSE STORAGE : Insert the memory card into the card reader. Choose the card reader from this list. Be careful and choose the right device: After choosing the memory card, press the WRITE button. Confirm the operation when you are asked about it: Wait for the process to finish. Get yourself a coffee or do some stretching :) Tip The process may hang at 99% for a long time, this is okay, just wait for it to complete Remove the memory card after successful completion: Tip If an error occurs during flashing or booting PiKVM, repeat the process. When you have completed these steps, please move to the First Steps doc.","title":"Flashing the OS image"},{"location":"flashing_os/#flashing-the-os-image","text":"Micro-SD Card Requirements Minimum 16 Gb Class 10 is strongly recommended","title":"Flashing the OS image"},{"location":"flashing_os/#download-the-image","text":"Download the appropriate SD card image. Select it based on the board, platform, and the video capture device you are using: V3 HAT (Patron, Kickstarter, and future editions) PiKVM v3 HAT BOX Image (Raspberry Pi 4) OLED/FAN preactivated - sha1 PiKVM v3 HAT DIY Assembly (Raspberry Pi 4) - sha1 DIY - Raspberry Pi 4, v2 platform: For HDMI-CSI bridge - sha1 For HDMI-USB dongle - sha1 DIY - Raspberry Pi Zero 2 W, v2 platform: For HDMI-CSI bridge - sha1 DIY - Raspberry Pi Zero W (legacy), v2 platform: For HDMI-CSI bridge - sha1 Pre-compiled images are only available for the Raspberry Pi 4 and Zero (2) W. For all other cases, you will need to build the operating system yourself. But don't worry, it's very simple .","title":"Download the image"},{"location":"flashing_os/#flash-the-image","text":"Tip Ignore request to format your sd card, this step is not nessessary. Choose the most suitable method for you","title":"Flash the image"},{"location":"flashing_os/#using-linux-cli","text":"Decompress and flash the image. Be careful when choosing the device path, it may be different on your OS : # xz --decompress v2-hdmi-rpi4-latest.img.xz # dd if=v2-hdmi-rpi4-latest.img of=/dev/mmcblkX You can also use dd_rescue or ddrescue . Check the advanced settings (CTRL+SHIFT+X), make sure they are blank or the flash will fail","title":"Using Linux CLI"},{"location":"flashing_os/#using-rpi-imager-linux-macos-and-windows","text":"Download and install the latest version of RPi Imager . Run RPi Imager: Press CHOOSE OS and select Use custom image at bottom of the list: After clicking on this item, select the image file ( .img.xz ), then click CHOOSE STORAGE : Insert the memory card into the card reader. Choose the card reader from this list. Be careful and choose the right device: After choosing the memory card, press the WRITE button. Confirm the operation when you are asked about it: Wait for the process to finish. Get yourself a coffee or do some stretching :) Tip The process may hang at 99% for a long time, this is okay, just wait for it to complete Remove the memory card after successful completion: Tip If an error occurs during flashing or booting PiKVM, repeat the process. When you have completed these steps, please move to the First Steps doc.","title":"Using RPi Imager (Linux, MacOS and Windows)"},{"location":"gpio/","text":"GPIO \u00b6 GPIO (general-purpose input/output) is a series of digital interfaces that can be used to connect relays, LEDs, sensors, and other components. Warning Before using GPIO on PiKVM v3 HAT , carefully study the purpose of its ports . Using GPIO on a PiKVM was designed as a feature for advanced users, so please familiarize yourself with the topic to make sure you understand how to use use it before setting it up. Careless usage of GPIO can damage your Raspberry Pi or components. When talking about PiKVM and GPIO it refers not solely to the physical interface of the Raspberry Pi , but also to various plugins (for example, for USB relays ) that can also be used transparently by emulating an abstract GPIO API. Basics \u00b6 Setting up GPIO is considerably complex. The interface is divided into several layers for flexibility. Any configuration is performed using a file /etc/kvmd/override.yaml which uses the YAML syntax . We will look at each part of the configuration individually with an example for each. Sections should be combined under shared keys. Wrong: kvmd : gpio : drivers : ... kvmd : gpio : scheme : ... Correct: kvmd : gpio : drivers : ... scheme : ... Drivers \u00b6 The first part of the configuration refers to the hardware layer, which defines which IO channels are used (standard GPIO pins of the Raspberry Pi, an USB relay, and so on). If you just want to use GPIO with the default settings you can skip to the next section Scheme . Each hardware input/output requires a individual driver configuration entry. Each driver has a type (which refers to the plugin that handles the communication between PiKVM and the hardware) and a unique name. This allows you to either can add multiple drivers of the same type with different settings or connect multiple USB HID relays. Note Each driver requires a unique name. Names surrounded by double underscore are system reserved and should not be used. The only exception to this is the default GPIO driver with the name __gpio__ , representing the physical GPIO interface of the Raspberry Pi. The configuration section for __gpio__ is only required in your /etc/kvmd/override.yaml if you want to change the default settings. It can be omitted if you are fine with the defaults. kvmd : gpio : drivers : # This example shows how the default __gpio__ driver settings can be changed. It can be omitted if you are fine with the defaults. __gpio__ : # Names surrounded by double underscore are system reserved type : gpio # Refers to the plugin name handling the communication # You can define another gpio driver for some reason my_gpio : type : gpio # Example for a USB HID relay connected to PiKVM relay : type : hidrelay device : /dev/hidraw0 # The path to the linux device Scheme \u00b6 The second part defines how the various driver channels are configured. Each channel has a unique name, a mode ( input or output ), a pin number, and a reference to the driver configured in the previous part. Note Names that starts and ends with two underscores (like __magic__ ) are reserved. Two interaction modes are available for outputs: pulse and switch . In pulse mode, the output quickly switches its state to logical 1 and back (just like pressing a button). In switch mode, it saves (toggles) the state that the user set. When PiKVM is started/rebooted (any time the KVMD daemon is started or stopped) all output channels are reset to 0. This can be changed using the initial parameter. For example, initial=true for logic 1 on startup. If you don't specify a driver for the channel in the scheme the default driver, __gpio__ will be used. Parameter Type Allowed values Default Description led1 , button1 , relay1 , etc. string a-Z , numbers, _ , - A section for the named channel pin integer X >= 0 Refers to a GPIO pin or driver's pin/port mode enum input or output Defines if a channel is used for input or output, may be limited by driver plugin Input only debounce float x >= 0 0.1 Debounce time in seconds. 0 for disable debounce Output only switch bool true or false true Enables or disables the switch mode on the channel (enabled by default). initial nullable bool true , false or null false Defines the initial state of the switch upon boot, null for don't make changes (the last one does not supported by generic GPIO) inverted bool true or false false Inverts the active logical level pulse A section header to define switch pulse configuration delay float X >= 0 0.1 Defines the pulse time in seconds, 0 for disable pulsing min_delay float X >= 0.1 0.1 max_delay float X >= 0.1 0.1 kvmd : gpio : scheme : # A certain device sends signals to the RPi and we want the PiKVM to display this as an led led1 : pin : 19 # GPIO pin number on the RPi mode : input led2 : pin : 16 mode : input # Two outputs of RPi's GPIO button1 : pin : 26 # GPIO pin number on the RPi mode : output switch : false # Disable switching, only pulse available button2 : pin : 20 mode : output switch : false relay1 : # Channel 1 of the relay /dev/hidraw0 pin : 0 # Numerating starts from 0 mode : output # Relays can't be inputs initial : null # Don't reset the state to 0 when initializing and terminating KVMD relay2 : # Channel 2 pin : 1 mode : output initial : null pulse : delay : 2 # Default pulse value max_delay : 2 # The pulse interval can be between min_delay=0.1 (by default) and max_delay=2 View \u00b6 This is the last part of the required configuration. It defines how the previous driver and channel configuration is rendered on the Web interface. Here's an example for the example configuration above: kvmd : gpio : view : header : title : Switches # The menu title table : # The menu items are rendered in the form of a table of text labels and controls - [ \"#Generic GPIO leds\" ] # Text starting with the sharp symbol will be a label - [] # creates a horizontal separator and starts a new table - [ \"#Test 1:\" , led1 , button1 ] # Text label, one input, one button with text \"Click\" - [ \"#Test 2:\" , led2 , button2 ] - [] - [ \"#HID Relays /dev/hidraw0\" ] - [] - [ \"#Relay #1:\" , \"relay1|Boop 0.1\" ] # Text label and button with alternative text - [ \"#Relay #2:\" , \"relay2|Boop 2.0\" ] This will be rendered as: Some rules and customization options: Text starting with the # symbol will be a label. To place a channel in a cell, use the name you defined in the scheme. Inputs are displayed as round LEDs. Outputs are displayed as a switch AND a button. If the switch mode is disabled, only a button will be displayed. If pulse is disabled, only a switch will be shown. To change the LED's color specify it after the channel name like \"led1|red\" . Available: green , yellow and red . To change title of the button, write some its name like \"relay1|My cool relay\" . Buttons and switches can request confirmation on acting. To do this write its name like \"relay1|confirm|My cool relay\" . The third argument with a title is required in this case. Hardware modules and pseudo-drivers \u00b6 Raspberry's GPIO \u00b6 Click to view The driver gpio provides access to regular GPIO pins with input and output modes. It uses /dev/gpiochip0 and the libgpiod library to communicate with the hardware. Does not support saving state between KVMD restarts (meaning initial=null ). You can use the interactive scheme when selecting the pins to use. Please note that when selecting a pin for a channel, you need to use a logical number instead of a physical number. That is, if you want to use a physical pin with the number 40, the channel must have the number 21 corresponding to the logical GPIO21. Channels should not use duplicate pins. You can also not use already used pins. To see which pins are currently used, run the command gpioinfo . USB HID Relay \u00b6 Click to view The driver hidrelay provides access to cheap managed USB HID relays that can be found on AliExpress. This driver does not support input mode, only output. To use it, you need to specify the path to the device file (like /dev/hidraw0 ) using the device parameter. Additionally, we recommend to configure access rights and static device name using UDEV rules . For example, create /etc/udev/rules.d/99-kvmd-extra.rules : KERNEL==\"hidraw[0-9]*\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"16c0\", ATTRS{idProduct}==\"05df\", GROUP=\"kvmd\" Channels should not use duplicate physical numbers. The driver supports saving state between KVMD restarts (meaning initial=null ). ezCoo KVM switch \u00b6 Click to view You can use GPIO to control KVM port switching. This usually requires the use of relays and buttons, but for the ezCoo switch there is a special ezcoo driver that simulates GPIO by sending commands to the switch via serial port. So you can make a menu in PiKVM to control the multiport switch. IPMI \u00b6 Click to view The driver ipmi provides the ability to send IPMI commands (on, off, reset) and show the power status of the remote host. In fact, this is not a hardware driver, but something like a pseudo-GPIO. Each \"pin\" is actually responsible for a specific IPMI operation of ipmitool : Pin Type Command 0 input ipmitool ... power status , can be used to draw the LED in the menu 1 output ipmitool ... power on , sends the on command (and only this), so like all other outputs it should be a button 2 output ipmitool ... power off 3 output ipmitool ... power cycle 4 output ipmitool ... power reset 5 output ipmitool ... power diag 6 output ipmitool ... power soft You are supposed to define one driver per host: kvmd : gpio : drivers : my_server : type : ipmi host : myserver.local user : admin passwd : admin scheme : my_server_status : driver : my_server pin : 0 mode : input my_server_on : driver : my_server pin : 1 mode : output switch : false my_server_off : driver : my_server pin : 2 mode : output switch : false view : table : - [ my_server_status , \"my_server_on|On\" , \"my_server_off|Off\" ] Wake-on-LAN \u00b6 Click to view The driver wol provides a simple generator of Wake-on-LAN packages. One driver and one output are generated for one host if a simplified configuration method is used. However, you can define multiple drivers if you want to manage different hosts. One driver controls one host, and can only be used as an output. Pin numbers are ignored. kvmd : gpio : drivers : wol_server1 : type : wol mac : ff:ff:ff:ff:ff:f1 wol_server2 : type : wol mac : ff:ff:ff:ff:ff:f2 ip : 192.168.0.100 port : 9 scheme : wol_server1 : driver : wol_server1 pin : 0 mode : output switch : false wol_server2 : driver : wol_server2 pin : 0 mode : output switch : false view : table : - [ \"#Server 1\" , \"wol_server1|Send Wake-on-LAN\" ] - [ \"#Server 2\" , \"wol_server2|Send Wake-on-LAN\" ] CMD \u00b6 Click to view The cmd driver allows you to run custom command on PiKVM OS. Note This driver does not support bash operators, that is, it is a direct call to commands with arguments. For more complex cases, write your own shell scripts. Commands are executed from the user kvmd . If you want to run the command as root, then you need to configure sudo . Example of the /etc/sudoers.d/custom_commands : kvmd ALL=(ALL) NOPASSWD: /usr/bin/reboot Example of the /etc/kvmd/override.yaml : kvmd : gpio : drivers : reboot : type : cmd cmd : [ /usr/bin/sudo , reboot ] scheme : reboot_button : driver : reboot pin : 0 mode : output switch : false view : table : - [ \"reboot_button|confirm|Reboot PiKVM\" ] PWM \u00b6 Click to view The pwm driver allows you to use some GPIO pins on the Raspberry Pi for PWM. Here the small example with servo control: Add to /boot/config.txt : dtoverlay=pwm Create /etc/udev/rules.d/99-kvmd-pwm.rules : SUBSYSTEM==\"pwm*\", ACTION==\"add\", RUN+=\"/bin/chgrp -R kvmd /sys%p\", RUN+=\"/bin/chmod -R g=u /sys%p\" SUBSYSTEM==\"pwm*\", ACTION==\"change\", ENV{TRIGGER}!=\"none\", RUN+=\"/bin/chgrp -R kvmd /sys%p\", RUN+=\"/bin/chmod -R g=u /sys%p\" Connect Servo motor like SG90 PWM connection to RPi GPIO18, +5V and GND to a 5V and GND pin on header: Add to /etc/kvmd/override.yaml kvmd : gpio : drivers : servo1 : type : pwm chip : 0 # PWM Chip Number period : 20000000 # Servo Motor SG90 Period in nano-seconds duty_cycle_push : 1500000 # Servo Motor SG90 duty_cycle for pushing button duty_cycle_release : 1000000 # Servo Motor SG90 duty_cycle for releasing button scheme : short_press : driver : servo1 pin : 0 # Pin number is the PWM channel number on the PWM Chip mode : output switch : false pulse : delay : 0.5 max_delay : 2 long_press : driver : servo1 pin : 0 mode : output switch : false pulse : delay : 2 max_delay : 2 extra_long_press : driver : servo1 pin : 0 mode : output switch : false pulse : delay : 10 max_delay : 20 view : header : title : Controls table : - [ \"#Servo - Short Press\" , \"short_press|Press\" ] - [ \"#Servo - Long Press\" , \"long_press|Press\" ] - [ \"#Servo - Extra Long Press\" , \"extra_long_press|Press\" ] Servo \u00b6 Click to view The servo module is built on top of the pwm module and allows user to define angles instead of duty_cyles to control a PWM enabled servo motor like SG90. When the button is pressed the servo motor moves to an angle defined by angle_push and when button is released it moves back to angle_release . In the example configuration for a cheap 5V SG90 Servo , the motor moves to an angle of 45 degrees when button is pressed and moves back to 20 degress when released. To use Servo motors in PiKVM you need to follow steps 1-3 for PWM Module and then use the following configuration. Add to /etc/kvmd/override.yaml : kvmd : gpio : drivers : servo1 : type : servo chip : 0 # PWM Chip Number period : 20000000 # Servo Motor SG90 Period in nano-seconds duty_cycle_min : 350000 # Servo Motor SG90 duty_cycle for -90 degrees duty_cycle_max : 2350000 # Servo Motor SG90 duty_cycle for +90 degrees angle_max : 90 # Servo Motor SG90 angle at duty_cycle_max angle_min : -90 # Servo Motor SG90 angle at duty_cycle_min angle_push : 45 # Servo Motor SG90 angle to push button angle_release : 20 # Servo Motor SG90 angle to release button scheme : short_press : driver : servo1 pin : 0 # Pin number is the PWM channel number on the PWM Chip mode : output switch : false pulse : delay : 0.5 max_delay : 2 long_press : driver : servo1 pin : 0 mode : output switch : false pulse : delay : 2 max_delay : 2 extra_long_press : driver : servo1 pin : 0 mode : output switch : false pulse : delay : 10 max_delay : 20 view : header : title : Controls table : - [ \"#Servo - Short Press\" , \"short_press|Press\" ] - [ \"#Servo - Long Press\" , \"long_press|Press\" ] - [ \"#Servo - Extra Long Press\" , \"extra_long_press|Press\" ] Philips Hue \u00b6 Click to view The hue module can control smartplugs and lamps over Philips Hue Bridge API. In general the plugin can switch any device on/off which is connected to the bridge. To use it you will need API token aka username: Open http://bridge/debug/clip.html . In the URL: Field type /api/ . In the Message Body: Field type: {\"devicetype\": \"pikvm\"} . Hit the Get Button. As the Response you become the Username: {\"success\": {\"username\": \"apiusername\"} . Example: kvmd : gpio : drivers : hue : type : hue url : http://bridge token : YG-xxxxxxxxxxxx scheme : plug_button : driver : hue pin : 32 mode : output initial : null switch : true pulse : delay : 0 plug_led : driver : hue pin : 32 mode : input view : table : - [ \"plug_led\" , \"plug_button\" ]","title":"GPIO (pins, relays, lamps, etc)"},{"location":"gpio/#gpio","text":"GPIO (general-purpose input/output) is a series of digital interfaces that can be used to connect relays, LEDs, sensors, and other components. Warning Before using GPIO on PiKVM v3 HAT , carefully study the purpose of its ports . Using GPIO on a PiKVM was designed as a feature for advanced users, so please familiarize yourself with the topic to make sure you understand how to use use it before setting it up. Careless usage of GPIO can damage your Raspberry Pi or components. When talking about PiKVM and GPIO it refers not solely to the physical interface of the Raspberry Pi , but also to various plugins (for example, for USB relays ) that can also be used transparently by emulating an abstract GPIO API.","title":"GPIO"},{"location":"gpio/#basics","text":"Setting up GPIO is considerably complex. The interface is divided into several layers for flexibility. Any configuration is performed using a file /etc/kvmd/override.yaml which uses the YAML syntax . We will look at each part of the configuration individually with an example for each. Sections should be combined under shared keys. Wrong: kvmd : gpio : drivers : ... kvmd : gpio : scheme : ... Correct: kvmd : gpio : drivers : ... scheme : ...","title":"Basics"},{"location":"gpio/#drivers","text":"The first part of the configuration refers to the hardware layer, which defines which IO channels are used (standard GPIO pins of the Raspberry Pi, an USB relay, and so on). If you just want to use GPIO with the default settings you can skip to the next section Scheme . Each hardware input/output requires a individual driver configuration entry. Each driver has a type (which refers to the plugin that handles the communication between PiKVM and the hardware) and a unique name. This allows you to either can add multiple drivers of the same type with different settings or connect multiple USB HID relays. Note Each driver requires a unique name. Names surrounded by double underscore are system reserved and should not be used. The only exception to this is the default GPIO driver with the name __gpio__ , representing the physical GPIO interface of the Raspberry Pi. The configuration section for __gpio__ is only required in your /etc/kvmd/override.yaml if you want to change the default settings. It can be omitted if you are fine with the defaults. kvmd : gpio : drivers : # This example shows how the default __gpio__ driver settings can be changed. It can be omitted if you are fine with the defaults. __gpio__ : # Names surrounded by double underscore are system reserved type : gpio # Refers to the plugin name handling the communication # You can define another gpio driver for some reason my_gpio : type : gpio # Example for a USB HID relay connected to PiKVM relay : type : hidrelay device : /dev/hidraw0 # The path to the linux device","title":"Drivers"},{"location":"gpio/#scheme","text":"The second part defines how the various driver channels are configured. Each channel has a unique name, a mode ( input or output ), a pin number, and a reference to the driver configured in the previous part. Note Names that starts and ends with two underscores (like __magic__ ) are reserved. Two interaction modes are available for outputs: pulse and switch . In pulse mode, the output quickly switches its state to logical 1 and back (just like pressing a button). In switch mode, it saves (toggles) the state that the user set. When PiKVM is started/rebooted (any time the KVMD daemon is started or stopped) all output channels are reset to 0. This can be changed using the initial parameter. For example, initial=true for logic 1 on startup. If you don't specify a driver for the channel in the scheme the default driver, __gpio__ will be used. Parameter Type Allowed values Default Description led1 , button1 , relay1 , etc. string a-Z , numbers, _ , - A section for the named channel pin integer X >= 0 Refers to a GPIO pin or driver's pin/port mode enum input or output Defines if a channel is used for input or output, may be limited by driver plugin Input only debounce float x >= 0 0.1 Debounce time in seconds. 0 for disable debounce Output only switch bool true or false true Enables or disables the switch mode on the channel (enabled by default). initial nullable bool true , false or null false Defines the initial state of the switch upon boot, null for don't make changes (the last one does not supported by generic GPIO) inverted bool true or false false Inverts the active logical level pulse A section header to define switch pulse configuration delay float X >= 0 0.1 Defines the pulse time in seconds, 0 for disable pulsing min_delay float X >= 0.1 0.1 max_delay float X >= 0.1 0.1 kvmd : gpio : scheme : # A certain device sends signals to the RPi and we want the PiKVM to display this as an led led1 : pin : 19 # GPIO pin number on the RPi mode : input led2 : pin : 16 mode : input # Two outputs of RPi's GPIO button1 : pin : 26 # GPIO pin number on the RPi mode : output switch : false # Disable switching, only pulse available button2 : pin : 20 mode : output switch : false relay1 : # Channel 1 of the relay /dev/hidraw0 pin : 0 # Numerating starts from 0 mode : output # Relays can't be inputs initial : null # Don't reset the state to 0 when initializing and terminating KVMD relay2 : # Channel 2 pin : 1 mode : output initial : null pulse : delay : 2 # Default pulse value max_delay : 2 # The pulse interval can be between min_delay=0.1 (by default) and max_delay=2","title":"Scheme"},{"location":"gpio/#view","text":"This is the last part of the required configuration. It defines how the previous driver and channel configuration is rendered on the Web interface. Here's an example for the example configuration above: kvmd : gpio : view : header : title : Switches # The menu title table : # The menu items are rendered in the form of a table of text labels and controls - [ \"#Generic GPIO leds\" ] # Text starting with the sharp symbol will be a label - [] # creates a horizontal separator and starts a new table - [ \"#Test 1:\" , led1 , button1 ] # Text label, one input, one button with text \"Click\" - [ \"#Test 2:\" , led2 , button2 ] - [] - [ \"#HID Relays /dev/hidraw0\" ] - [] - [ \"#Relay #1:\" , \"relay1|Boop 0.1\" ] # Text label and button with alternative text - [ \"#Relay #2:\" , \"relay2|Boop 2.0\" ] This will be rendered as: Some rules and customization options: Text starting with the # symbol will be a label. To place a channel in a cell, use the name you defined in the scheme. Inputs are displayed as round LEDs. Outputs are displayed as a switch AND a button. If the switch mode is disabled, only a button will be displayed. If pulse is disabled, only a switch will be shown. To change the LED's color specify it after the channel name like \"led1|red\" . Available: green , yellow and red . To change title of the button, write some its name like \"relay1|My cool relay\" . Buttons and switches can request confirmation on acting. To do this write its name like \"relay1|confirm|My cool relay\" . The third argument with a title is required in this case.","title":"View"},{"location":"gpio/#hardware-modules-and-pseudo-drivers","text":"","title":"Hardware modules and pseudo-drivers"},{"location":"gpio/#raspberrys-gpio","text":"Click to view The driver gpio provides access to regular GPIO pins with input and output modes. It uses /dev/gpiochip0 and the libgpiod library to communicate with the hardware. Does not support saving state between KVMD restarts (meaning initial=null ). You can use the interactive scheme when selecting the pins to use. Please note that when selecting a pin for a channel, you need to use a logical number instead of a physical number. That is, if you want to use a physical pin with the number 40, the channel must have the number 21 corresponding to the logical GPIO21. Channels should not use duplicate pins. You can also not use already used pins. To see which pins are currently used, run the command gpioinfo .","title":"Raspberry's GPIO"},{"location":"gpio/#usb-hid-relay","text":"Click to view The driver hidrelay provides access to cheap managed USB HID relays that can be found on AliExpress. This driver does not support input mode, only output. To use it, you need to specify the path to the device file (like /dev/hidraw0 ) using the device parameter. Additionally, we recommend to configure access rights and static device name using UDEV rules . For example, create /etc/udev/rules.d/99-kvmd-extra.rules : KERNEL==\"hidraw[0-9]*\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"16c0\", ATTRS{idProduct}==\"05df\", GROUP=\"kvmd\" Channels should not use duplicate physical numbers. The driver supports saving state between KVMD restarts (meaning initial=null ).","title":"USB HID Relay"},{"location":"gpio/#ezcoo-kvm-switch","text":"Click to view You can use GPIO to control KVM port switching. This usually requires the use of relays and buttons, but for the ezCoo switch there is a special ezcoo driver that simulates GPIO by sending commands to the switch via serial port. So you can make a menu in PiKVM to control the multiport switch.","title":"ezCoo KVM switch"},{"location":"gpio/#ipmi","text":"Click to view The driver ipmi provides the ability to send IPMI commands (on, off, reset) and show the power status of the remote host. In fact, this is not a hardware driver, but something like a pseudo-GPIO. Each \"pin\" is actually responsible for a specific IPMI operation of ipmitool : Pin Type Command 0 input ipmitool ... power status , can be used to draw the LED in the menu 1 output ipmitool ... power on , sends the on command (and only this), so like all other outputs it should be a button 2 output ipmitool ... power off 3 output ipmitool ... power cycle 4 output ipmitool ... power reset 5 output ipmitool ... power diag 6 output ipmitool ... power soft You are supposed to define one driver per host: kvmd : gpio : drivers : my_server : type : ipmi host : myserver.local user : admin passwd : admin scheme : my_server_status : driver : my_server pin : 0 mode : input my_server_on : driver : my_server pin : 1 mode : output switch : false my_server_off : driver : my_server pin : 2 mode : output switch : false view : table : - [ my_server_status , \"my_server_on|On\" , \"my_server_off|Off\" ]","title":"IPMI"},{"location":"gpio/#wake-on-lan","text":"Click to view The driver wol provides a simple generator of Wake-on-LAN packages. One driver and one output are generated for one host if a simplified configuration method is used. However, you can define multiple drivers if you want to manage different hosts. One driver controls one host, and can only be used as an output. Pin numbers are ignored. kvmd : gpio : drivers : wol_server1 : type : wol mac : ff:ff:ff:ff:ff:f1 wol_server2 : type : wol mac : ff:ff:ff:ff:ff:f2 ip : 192.168.0.100 port : 9 scheme : wol_server1 : driver : wol_server1 pin : 0 mode : output switch : false wol_server2 : driver : wol_server2 pin : 0 mode : output switch : false view : table : - [ \"#Server 1\" , \"wol_server1|Send Wake-on-LAN\" ] - [ \"#Server 2\" , \"wol_server2|Send Wake-on-LAN\" ]","title":"Wake-on-LAN"},{"location":"gpio/#cmd","text":"Click to view The cmd driver allows you to run custom command on PiKVM OS. Note This driver does not support bash operators, that is, it is a direct call to commands with arguments. For more complex cases, write your own shell scripts. Commands are executed from the user kvmd . If you want to run the command as root, then you need to configure sudo . Example of the /etc/sudoers.d/custom_commands : kvmd ALL=(ALL) NOPASSWD: /usr/bin/reboot Example of the /etc/kvmd/override.yaml : kvmd : gpio : drivers : reboot : type : cmd cmd : [ /usr/bin/sudo , reboot ] scheme : reboot_button : driver : reboot pin : 0 mode : output switch : false view : table : - [ \"reboot_button|confirm|Reboot PiKVM\" ]","title":"CMD"},{"location":"gpio/#pwm","text":"Click to view The pwm driver allows you to use some GPIO pins on the Raspberry Pi for PWM. Here the small example with servo control: Add to /boot/config.txt : dtoverlay=pwm Create /etc/udev/rules.d/99-kvmd-pwm.rules : SUBSYSTEM==\"pwm*\", ACTION==\"add\", RUN+=\"/bin/chgrp -R kvmd /sys%p\", RUN+=\"/bin/chmod -R g=u /sys%p\" SUBSYSTEM==\"pwm*\", ACTION==\"change\", ENV{TRIGGER}!=\"none\", RUN+=\"/bin/chgrp -R kvmd /sys%p\", RUN+=\"/bin/chmod -R g=u /sys%p\" Connect Servo motor like SG90 PWM connection to RPi GPIO18, +5V and GND to a 5V and GND pin on header: Add to /etc/kvmd/override.yaml kvmd : gpio : drivers : servo1 : type : pwm chip : 0 # PWM Chip Number period : 20000000 # Servo Motor SG90 Period in nano-seconds duty_cycle_push : 1500000 # Servo Motor SG90 duty_cycle for pushing button duty_cycle_release : 1000000 # Servo Motor SG90 duty_cycle for releasing button scheme : short_press : driver : servo1 pin : 0 # Pin number is the PWM channel number on the PWM Chip mode : output switch : false pulse : delay : 0.5 max_delay : 2 long_press : driver : servo1 pin : 0 mode : output switch : false pulse : delay : 2 max_delay : 2 extra_long_press : driver : servo1 pin : 0 mode : output switch : false pulse : delay : 10 max_delay : 20 view : header : title : Controls table : - [ \"#Servo - Short Press\" , \"short_press|Press\" ] - [ \"#Servo - Long Press\" , \"long_press|Press\" ] - [ \"#Servo - Extra Long Press\" , \"extra_long_press|Press\" ]","title":"PWM"},{"location":"gpio/#servo","text":"Click to view The servo module is built on top of the pwm module and allows user to define angles instead of duty_cyles to control a PWM enabled servo motor like SG90. When the button is pressed the servo motor moves to an angle defined by angle_push and when button is released it moves back to angle_release . In the example configuration for a cheap 5V SG90 Servo , the motor moves to an angle of 45 degrees when button is pressed and moves back to 20 degress when released. To use Servo motors in PiKVM you need to follow steps 1-3 for PWM Module and then use the following configuration. Add to /etc/kvmd/override.yaml : kvmd : gpio : drivers : servo1 : type : servo chip : 0 # PWM Chip Number period : 20000000 # Servo Motor SG90 Period in nano-seconds duty_cycle_min : 350000 # Servo Motor SG90 duty_cycle for -90 degrees duty_cycle_max : 2350000 # Servo Motor SG90 duty_cycle for +90 degrees angle_max : 90 # Servo Motor SG90 angle at duty_cycle_max angle_min : -90 # Servo Motor SG90 angle at duty_cycle_min angle_push : 45 # Servo Motor SG90 angle to push button angle_release : 20 # Servo Motor SG90 angle to release button scheme : short_press : driver : servo1 pin : 0 # Pin number is the PWM channel number on the PWM Chip mode : output switch : false pulse : delay : 0.5 max_delay : 2 long_press : driver : servo1 pin : 0 mode : output switch : false pulse : delay : 2 max_delay : 2 extra_long_press : driver : servo1 pin : 0 mode : output switch : false pulse : delay : 10 max_delay : 20 view : header : title : Controls table : - [ \"#Servo - Short Press\" , \"short_press|Press\" ] - [ \"#Servo - Long Press\" , \"long_press|Press\" ] - [ \"#Servo - Extra Long Press\" , \"extra_long_press|Press\" ]","title":"Servo"},{"location":"gpio/#philips-hue","text":"Click to view The hue module can control smartplugs and lamps over Philips Hue Bridge API. In general the plugin can switch any device on/off which is connected to the bridge. To use it you will need API token aka username: Open http://bridge/debug/clip.html . In the URL: Field type /api/ . In the Message Body: Field type: {\"devicetype\": \"pikvm\"} . Hit the Get Button. As the Response you become the Username: {\"success\": {\"username\": \"apiusername\"} . Example: kvmd : gpio : drivers : hue : type : hue url : http://bridge token : YG-xxxxxxxxxxxx scheme : plug_button : driver : hue pin : 32 mode : output initial : null switch : true pulse : delay : 0 plug_led : driver : hue pin : 32 mode : input view : table : - [ \"plug_led\" , \"plug_button\" ]","title":"Philips Hue"},{"location":"ipmi/","text":"IPMI & Redfish \u00b6 Info This page is about the server-side emulation (if you want to manage PiKVM using ipmitool or so). If you want to use the PiKVM Web UI to manage the server using IPMI (that is, as an IPMI client), see GPIO functions with IPMI plugin . IPMI BMC \u00b6 IPMI is an old protocol for remote server management. It can be useful for managing a large number of machines with PiKVM. Its advantage is that it is supported by many enterprise systems. Warning Although PiKVM supports the IPMI protocol, we strongly recommend that you DO NOT USE IT outside of trusted networks due to the protocol's insecurity . Use Redfish or KVMD API instead of it. To enable IPMI BMC follow these steps: Switch the filesystem to the RW-mode: # rw Setup IPMI account in file /etc/kvmd/ipmipasswd . Enable kvmd-ipmi daemon: # systemctl enable --now kvmd-ipmi Switch the filesystem back to the RO: # ro Here some examples (on the remote PC): $ ipmitool -I lanplus -U admin -P admin -H pikvm power status $ ipmitool -I lanplus -U admin -P admin -H pikvm power on IPMI SoL \u00b6 IPMI supports the ability to get console access to the server using Serial-over-LAN. PiKVM can act as a proxy for your server's COM port. Warning Although PiKVM supports the IPMI protocol, we strongly recommend that you DO NOT USE IT outside of trusted networks due to the protocol's insecurity . Use Redfish or KVMD API instead of it. To use this feature, you will need a USB-COM adapter that you need to connect to the PiKVM. The COM port of the adapter need to be connected to the server. As with IPMI BMC, you need to configure kvmd-vnc and add the following configuration to /etc/kvmd/override.yaml : ipmi : sol : device : /dev/ttyUSB0 # Path of your USB-COM adapter speed : 115200 After enabling kvmd-ipmi , all requests that it receives over the network regarding the COM port will be forwarded to your server. For example: $ ipmitool -I lanplus -U admin -P admin -H pikvm sol activate Redfish \u00b6 Redfish is a more modern server management protocol designed to replace IPMI. It is based on HTTP and fixes many security issues. If possible, we recommend using it instead of IPMI, or using the KVMD API . There're not special actions required to use Redfish. In addition, Redfish will use regular PiKVM credentials. But for systems that have been upgraded to KVMD 2.0 (not a clean image installation), you will probably need to edit the /etc/kvmd/nginx/kvmd.ctx-server.conf file to add these lines at the end: location /redfish { proxy_pass http://kvmd ; include /etc/kvmd/nginx/loc-proxy.conf ; auth_request off ; } !!! info Don't be confused by the parameter auth_request off . KVMD performs authorization on its own. The only open HTTP entrypoint is /redfish/v1 , which returns a static document and does not change the state of the PiKVM. It's safe. If there is a file in your system after the update /etc/kvmd/nginx/kvmd.ctx-server.conf.pacnew you can just move it: # mv /etc/kvmd/nginx/kvmd.ctx-server.conf.pacnew /etc/kvmd/nginx/kvmd.ctx-server.conf Warning Be careful not to lose your local changes if you have done anything with this file before. To access the Redfish API, use HTTP Basic Auth. Also you can use the redfishtool : $ redfishtool -S Never -r pikvm root $ redfishtool -S Never -u admin -p admin -r pikvm Systems $ redfishtool -S Never -u admin -p admin -r pikvm Systems reset ForceOff","title":"IPMI & Redfish integration"},{"location":"ipmi/#ipmi-redfish","text":"Info This page is about the server-side emulation (if you want to manage PiKVM using ipmitool or so). If you want to use the PiKVM Web UI to manage the server using IPMI (that is, as an IPMI client), see GPIO functions with IPMI plugin .","title":"IPMI &amp; Redfish"},{"location":"ipmi/#ipmi-bmc","text":"IPMI is an old protocol for remote server management. It can be useful for managing a large number of machines with PiKVM. Its advantage is that it is supported by many enterprise systems. Warning Although PiKVM supports the IPMI protocol, we strongly recommend that you DO NOT USE IT outside of trusted networks due to the protocol's insecurity . Use Redfish or KVMD API instead of it. To enable IPMI BMC follow these steps: Switch the filesystem to the RW-mode: # rw Setup IPMI account in file /etc/kvmd/ipmipasswd . Enable kvmd-ipmi daemon: # systemctl enable --now kvmd-ipmi Switch the filesystem back to the RO: # ro Here some examples (on the remote PC): $ ipmitool -I lanplus -U admin -P admin -H pikvm power status $ ipmitool -I lanplus -U admin -P admin -H pikvm power on","title":"IPMI BMC"},{"location":"ipmi/#ipmi-sol","text":"IPMI supports the ability to get console access to the server using Serial-over-LAN. PiKVM can act as a proxy for your server's COM port. Warning Although PiKVM supports the IPMI protocol, we strongly recommend that you DO NOT USE IT outside of trusted networks due to the protocol's insecurity . Use Redfish or KVMD API instead of it. To use this feature, you will need a USB-COM adapter that you need to connect to the PiKVM. The COM port of the adapter need to be connected to the server. As with IPMI BMC, you need to configure kvmd-vnc and add the following configuration to /etc/kvmd/override.yaml : ipmi : sol : device : /dev/ttyUSB0 # Path of your USB-COM adapter speed : 115200 After enabling kvmd-ipmi , all requests that it receives over the network regarding the COM port will be forwarded to your server. For example: $ ipmitool -I lanplus -U admin -P admin -H pikvm sol activate","title":"IPMI SoL"},{"location":"ipmi/#redfish","text":"Redfish is a more modern server management protocol designed to replace IPMI. It is based on HTTP and fixes many security issues. If possible, we recommend using it instead of IPMI, or using the KVMD API . There're not special actions required to use Redfish. In addition, Redfish will use regular PiKVM credentials. But for systems that have been upgraded to KVMD 2.0 (not a clean image installation), you will probably need to edit the /etc/kvmd/nginx/kvmd.ctx-server.conf file to add these lines at the end: location /redfish { proxy_pass http://kvmd ; include /etc/kvmd/nginx/loc-proxy.conf ; auth_request off ; } !!! info Don't be confused by the parameter auth_request off . KVMD performs authorization on its own. The only open HTTP entrypoint is /redfish/v1 , which returns a static document and does not change the state of the PiKVM. It's safe. If there is a file in your system after the update /etc/kvmd/nginx/kvmd.ctx-server.conf.pacnew you can just move it: # mv /etc/kvmd/nginx/kvmd.ctx-server.conf.pacnew /etc/kvmd/nginx/kvmd.ctx-server.conf Warning Be careful not to lose your local changes if you have done anything with this file before. To access the Redfish API, use HTTP Basic Auth. Also you can use the redfishtool : $ redfishtool -S Never -r pikvm root $ redfishtool -S Never -u admin -p admin -r pikvm Systems $ redfishtool -S Never -u admin -p admin -r pikvm Systems reset ForceOff","title":"Redfish"},{"location":"letsencrypt/","text":"Let's Encrypt certificates \u00b6 PiKVM uses self-signed SSL certificates out of the box. If you have a domain name, you can use Let's Encrypt certificates. Usually Let's Encrypt certificates are issued and updated automatically using Certbot, however, since PiKVM uses a read-only file system, special tools around Certbot are required to work with certificates. KVMD 3.117 provides them. Note This feature is available on images as old as 2022.06.19 since it requires PST storage partition on SD card . Ports 80+443 need to be opened if you are port forwarding for this to work properly. Basic setup \u00b6 Update the OS and make sure that you are using a new image with PST storage . # rw # pacman -Syu # reboot ... # kvmd-pstrun -- true If the storage is not available, you need to reflash the OS image to the latest one from our official website. Switch filesystem to RW and obtain the certificate (for example, pikvm.example.com . The method depends on the network configuration. In the simplest case, if PiKVM is open for access from the Internet, it is recommended to use the webroot. Another examples will be described below. # rw # kvmd-certbot certonly_webroot --agree-tos -n --email user@example.com -d pikvm.example.com Install the certificate for KVMD-Nginx and (optionally) KVMD-VNC . Running services will be restarted/reloaded automatically. Switch filesystem to RO. # kvmd-certbot install_nginx pikvm.example.com # kvmd-certbot install_vnc pikvm.example.com # ro Check the renewal immediately, just for testing: # kvmd-certbot renew --force-renewal Enable automatic certificate renewal: # systemctl enable --now kvmd-certbot.timer Cloudflare DNS \u00b6 This example shows that PiKVM may not be accessible from the internet, but you can still get a certificate if you use Cloudflare DNS. Switch filesystem to RW and install the Cloudflare DNS plugin: # rw # pacman -S certbot-dns-cloudflare Prepare the environment for the DNS plugin (place the auth data): # kvmd-pstrun -- mkdir -p /var/lib/kvmd/pst/data/certbot/runroot # kvmd-pstrun -- nano /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth # kvmd-pstrun -- chmod 600 /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth Obtain the certificate: # kvmd-certbot certonly \\ --dns-cloudflare \\ --dns-cloudflare-propagation-seconds 60 \\ --dns-cloudflare-credentials /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth \\ --agree-tos \\ -n \\ --email user@example.com \\ -d pikvm.example.com Next follow the basic guide. Route53 DNS \u00b6 This example shows that PiKVM may not be accessible from the internet, but you can still get a certificate if you use AWS Route53 DNS. Make sure you are running an image newer than 2022.06.20 and kvmd version 3.119-1 or greater. Switch filesystem to RW and install the Route53 DNS plugin: # rw # pacman -S certbot-dns-route53 Configure Your AWS User For the certbot_dns_route53 plugin to work it needs to be able to connect to AWS using an access key with the correct permissions. To do this securely you\u2019ll want to create a new AWS user that only has the necessary permissions it needs to work. You can find instructions for creating a user here . The basics of it is you\u2019ll want a user with Programmatic access (not console), add it to a group (I created a new one just for this user and any future certbot users I might need). The user will need specific permissions that are required to allow the certbot plugin to create the necessary CNAME records. These can be added by manually selecting them from a very long list or you can use the json view to give it the following permissions. { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"route53:ListHostedZones\" , \"route53:GetChange\" ], \"Resource\" : [ \"*\" ] }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"route53:ChangeResourceRecordSets\" ], \"Resource\" : [ \"arn:aws:route53:::hostedzone/YOURHOSTEDZONEID\" ] } ] } Make sure you replace YOURHOSTEDZONEID with the instance ID of your hosted zone. Once the user is created don\u2019t forget to download and save your access key and secret access key (somewhere secure, these are as sensitive as your passwords). Setup credentials: We now need to put the AWS credentials on the PiKVM so the certbot can use them. kvmd-pstrun -- mkdir -p /var/lib/kvmd/pst/data/certbot/runroot Copy and paste your AWS credentials into the nano editor and save the file. # kvmd-pstrun -- nano /var/lib/kvmd/pst/data/certbot/runroot/.route53.auth Here is an example .route53.auth file. Replace the placeholders with the access key and secret access key that you just saved from AWS and fill them in. [default] aws_access_key_id = XXXXXX aws_secret_access_key = XXXX/XXXXX Update permissions: # kvmd-pstrun -- chmod 600 /var/lib/kvmd/pst/data/certbot/runroot/.route53.auth Obtain the certificate: # export AWS_SHARED_CREDENTIALS_FILE=\"/var/lib/kvmd/pst/data/certbot/runroot/.route53.auth\" # kvmd-certbot certonly \\ --dns-route53 \\ --agree-tos \\ -n \\ --email user@example.com \\ -d pikvm.example.com Enable automatic certificate renewal: Create the file: /etc/conf.d/kvmd-certbot with the following contents so the renewall service can find the authentication file containing the AWS credentials: AWS_SHARED_CREDENTIALS_FILE=\"/var/lib/kvmd/pst/data/certbot/runroot/.route53.auth\" Now enable the renewal service: # systemctl enable --now kvmd-certbot.timer","title":"Let's Encrypt certificates"},{"location":"letsencrypt/#lets-encrypt-certificates","text":"PiKVM uses self-signed SSL certificates out of the box. If you have a domain name, you can use Let's Encrypt certificates. Usually Let's Encrypt certificates are issued and updated automatically using Certbot, however, since PiKVM uses a read-only file system, special tools around Certbot are required to work with certificates. KVMD 3.117 provides them. Note This feature is available on images as old as 2022.06.19 since it requires PST storage partition on SD card . Ports 80+443 need to be opened if you are port forwarding for this to work properly.","title":"Let's Encrypt certificates"},{"location":"letsencrypt/#basic-setup","text":"Update the OS and make sure that you are using a new image with PST storage . # rw # pacman -Syu # reboot ... # kvmd-pstrun -- true If the storage is not available, you need to reflash the OS image to the latest one from our official website. Switch filesystem to RW and obtain the certificate (for example, pikvm.example.com . The method depends on the network configuration. In the simplest case, if PiKVM is open for access from the Internet, it is recommended to use the webroot. Another examples will be described below. # rw # kvmd-certbot certonly_webroot --agree-tos -n --email user@example.com -d pikvm.example.com Install the certificate for KVMD-Nginx and (optionally) KVMD-VNC . Running services will be restarted/reloaded automatically. Switch filesystem to RO. # kvmd-certbot install_nginx pikvm.example.com # kvmd-certbot install_vnc pikvm.example.com # ro Check the renewal immediately, just for testing: # kvmd-certbot renew --force-renewal Enable automatic certificate renewal: # systemctl enable --now kvmd-certbot.timer","title":"Basic setup"},{"location":"letsencrypt/#cloudflare-dns","text":"This example shows that PiKVM may not be accessible from the internet, but you can still get a certificate if you use Cloudflare DNS. Switch filesystem to RW and install the Cloudflare DNS plugin: # rw # pacman -S certbot-dns-cloudflare Prepare the environment for the DNS plugin (place the auth data): # kvmd-pstrun -- mkdir -p /var/lib/kvmd/pst/data/certbot/runroot # kvmd-pstrun -- nano /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth # kvmd-pstrun -- chmod 600 /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth Obtain the certificate: # kvmd-certbot certonly \\ --dns-cloudflare \\ --dns-cloudflare-propagation-seconds 60 \\ --dns-cloudflare-credentials /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth \\ --agree-tos \\ -n \\ --email user@example.com \\ -d pikvm.example.com Next follow the basic guide.","title":"Cloudflare DNS"},{"location":"letsencrypt/#route53-dns","text":"This example shows that PiKVM may not be accessible from the internet, but you can still get a certificate if you use AWS Route53 DNS. Make sure you are running an image newer than 2022.06.20 and kvmd version 3.119-1 or greater. Switch filesystem to RW and install the Route53 DNS plugin: # rw # pacman -S certbot-dns-route53 Configure Your AWS User For the certbot_dns_route53 plugin to work it needs to be able to connect to AWS using an access key with the correct permissions. To do this securely you\u2019ll want to create a new AWS user that only has the necessary permissions it needs to work. You can find instructions for creating a user here . The basics of it is you\u2019ll want a user with Programmatic access (not console), add it to a group (I created a new one just for this user and any future certbot users I might need). The user will need specific permissions that are required to allow the certbot plugin to create the necessary CNAME records. These can be added by manually selecting them from a very long list or you can use the json view to give it the following permissions. { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"route53:ListHostedZones\" , \"route53:GetChange\" ], \"Resource\" : [ \"*\" ] }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"route53:ChangeResourceRecordSets\" ], \"Resource\" : [ \"arn:aws:route53:::hostedzone/YOURHOSTEDZONEID\" ] } ] } Make sure you replace YOURHOSTEDZONEID with the instance ID of your hosted zone. Once the user is created don\u2019t forget to download and save your access key and secret access key (somewhere secure, these are as sensitive as your passwords). Setup credentials: We now need to put the AWS credentials on the PiKVM so the certbot can use them. kvmd-pstrun -- mkdir -p /var/lib/kvmd/pst/data/certbot/runroot Copy and paste your AWS credentials into the nano editor and save the file. # kvmd-pstrun -- nano /var/lib/kvmd/pst/data/certbot/runroot/.route53.auth Here is an example .route53.auth file. Replace the placeholders with the access key and secret access key that you just saved from AWS and fill them in. [default] aws_access_key_id = XXXXXX aws_secret_access_key = XXXX/XXXXX Update permissions: # kvmd-pstrun -- chmod 600 /var/lib/kvmd/pst/data/certbot/runroot/.route53.auth Obtain the certificate: # export AWS_SHARED_CREDENTIALS_FILE=\"/var/lib/kvmd/pst/data/certbot/runroot/.route53.auth\" # kvmd-certbot certonly \\ --dns-route53 \\ --agree-tos \\ -n \\ --email user@example.com \\ -d pikvm.example.com Enable automatic certificate renewal: Create the file: /etc/conf.d/kvmd-certbot with the following contents so the renewall service can find the authentication file containing the AWS credentials: AWS_SHARED_CREDENTIALS_FILE=\"/var/lib/kvmd/pst/data/certbot/runroot/.route53.auth\" Now enable the renewal service: # systemctl enable --now kvmd-certbot.timer","title":"Route53 DNS"},{"location":"mouse/","text":"Mouse \u00b6 There are two modes of pointer device: absolute and relative. In absolute mode, the input device transmits the exact coordinates (X,Y) where the cursor should be moved. This is how touchscreens or drawing tablets work. In relative mode, only the relative offset (dX,dY) to the current position is transmitted, which is unknown to the input device itself. This is a regular mouse. By default, PiKVM uses absolute positioning mode as the most convenient for the user and software. However, this is not always supported by the BIOS/UEFI. For such cases, support is provided for the relative mode of operation, which can be enabled in the config. When using relative mode, the browser will exclusively capture your mouse when you click on the stream window in PiKVM once. When you press Esc , the browser releases the mouse. Important notes \u00b6 The relative mouse generates a huge number of events that can be poorly transmitted over the network or very slowly perceived by the BIOS/UEFI driver. To solve this problem, mouse events are optimized using a vector sum. This mode is enabled by activating the below first and is available in the web menu System -> Squash mouse moves . You can try disabling this if you have problems with mouse acceleration. This is the best and most reasonable compromise right now. Also currently the relative mouse mode is not supported by PiKVM VNC server yet. The reason is that none of the recommended clients support the QEMU Pointer Motion Change extension. We expect to implement this in TigerVNC . The relative mode is also not supported by mobile browsers. Relative mouse on v2+ platform (OTG HID) \u00b6 Dual mode \u00b6 Using dual mouse mode you can switch between the absolute and relative mouse in the System menu without reloading. This is more convenient, but for compatibility reasons it is disabled by default. To enable it, do the following: Switch filesystem to RW-mode using command rw . Edit /etc/kvmd/override.yaml and add these lines: kvmd : hid : mouse_alt : device : /dev/kvmd-hid-mouse-alt Perform reboot . After that reboot your PC. Single relative mode \u00b6 Switch filesystem to RW-mode using command rw . Edit /etc/kvmd/override.yaml and add these lines: kvmd : hid : mouse : absolute : false Perform reboot . After that reboot your PC. If the mouse is still not detected by the BIOS/UEFI, try disabling horizontal scrolling to achieve the maximum compatibility: kvmd : hid : mouse : absolute : false horizontal_wheel : false Don't forget to perform reboot . Relative mouse on v0 platform (Arduino HID) \u00b6 Mode switching for Arduino HID can be performed on-the-fly starting with KVMD 2.6 and the corresponding firmware. No additional actions are required. Fixing the absolute mouse on Windows 98 \u00b6 Due to an ancient buggy driver, the absolute mouse on Windows 98 moves only within the upper-left quarter of the screen. To fix this, you need to activate some magic workaround in /etc/kvmd/override.yaml : kvmd : hid : mouse : absolute_win98_fix : true ... and run systemctl restart kvmd .","title":"Mouse modes"},{"location":"mouse/#mouse","text":"There are two modes of pointer device: absolute and relative. In absolute mode, the input device transmits the exact coordinates (X,Y) where the cursor should be moved. This is how touchscreens or drawing tablets work. In relative mode, only the relative offset (dX,dY) to the current position is transmitted, which is unknown to the input device itself. This is a regular mouse. By default, PiKVM uses absolute positioning mode as the most convenient for the user and software. However, this is not always supported by the BIOS/UEFI. For such cases, support is provided for the relative mode of operation, which can be enabled in the config. When using relative mode, the browser will exclusively capture your mouse when you click on the stream window in PiKVM once. When you press Esc , the browser releases the mouse.","title":"Mouse"},{"location":"mouse/#important-notes","text":"The relative mouse generates a huge number of events that can be poorly transmitted over the network or very slowly perceived by the BIOS/UEFI driver. To solve this problem, mouse events are optimized using a vector sum. This mode is enabled by activating the below first and is available in the web menu System -> Squash mouse moves . You can try disabling this if you have problems with mouse acceleration. This is the best and most reasonable compromise right now. Also currently the relative mouse mode is not supported by PiKVM VNC server yet. The reason is that none of the recommended clients support the QEMU Pointer Motion Change extension. We expect to implement this in TigerVNC . The relative mode is also not supported by mobile browsers.","title":"Important notes"},{"location":"mouse/#relative-mouse-on-v2-platform-otg-hid","text":"","title":"Relative mouse on v2+ platform (OTG HID)"},{"location":"mouse/#dual-mode","text":"Using dual mouse mode you can switch between the absolute and relative mouse in the System menu without reloading. This is more convenient, but for compatibility reasons it is disabled by default. To enable it, do the following: Switch filesystem to RW-mode using command rw . Edit /etc/kvmd/override.yaml and add these lines: kvmd : hid : mouse_alt : device : /dev/kvmd-hid-mouse-alt Perform reboot . After that reboot your PC.","title":"Dual mode"},{"location":"mouse/#single-relative-mode","text":"Switch filesystem to RW-mode using command rw . Edit /etc/kvmd/override.yaml and add these lines: kvmd : hid : mouse : absolute : false Perform reboot . After that reboot your PC. If the mouse is still not detected by the BIOS/UEFI, try disabling horizontal scrolling to achieve the maximum compatibility: kvmd : hid : mouse : absolute : false horizontal_wheel : false Don't forget to perform reboot .","title":"Single relative mode"},{"location":"mouse/#relative-mouse-on-v0-platform-arduino-hid","text":"Mode switching for Arduino HID can be performed on-the-fly starting with KVMD 2.6 and the corresponding firmware. No additional actions are required.","title":"Relative mouse on v0 platform (Arduino HID)"},{"location":"mouse/#fixing-the-absolute-mouse-on-windows-98","text":"Due to an ancient buggy driver, the absolute mouse on Windows 98 moves only within the upper-left quarter of the screen. To fix this, you need to activate some magic workaround in /etc/kvmd/override.yaml : kvmd : hid : mouse : absolute_win98_fix : true ... and run systemctl restart kvmd .","title":"Fixing the absolute mouse on Windows 98"},{"location":"msd/","text":"Mass Storage Drive \u00b6 Basics \u00b6 This is a feature available on PiKVM v2+ that allows you to emulate a CD-ROM or Flash Drive. There are some subtleties that you should know: The size of the CD-ROM image is limited to 2.2 GB This is a limitation of the Linux kernel, which currently cannot emulate a DVD. To use a larger boot image, use Flash emulation. If this is not possible (the image does not support Flash, for example, for Windows), use this recipe. Changing the media type between CD-ROM and Flash is possible only when the device is reconnected For PiKVM v3 HAT, this can be done using the switch System -> Connect main USB . In this case, the media type is determined at the time of connecting the image, and not by clicking on the switch . The switch affects the settings of the future connection. For non-v3 devices, you need to either reboot your server or otherwise reinitialize the connection. Advanced Linux knowledge is necessary for some advanced aspects that are not part of the normal use case. IE: making larger flash files will need a different file location and those instructions will need to be modified. The following instructions are for you to have something to start with. Disable MSD \u00b6 To disable mass storage emulation altogether, you can place the following piece of configuration into /etc/kvmd/override.yaml : kvmd : msd : type : disabled Upload images manually (without Web UI) \u00b6 Remount internal storage to rw (read-write): # kvmd-helper-otgmsd-remount rw Upload the .ISO image(s) to /var/lib/kvmd/msd/images via scp or similar. Create an empty file in /var/lib/kvmd/msd/meta/ with the exact name (case sensitive!) of the uploaded image. This will indicate PiKVM that the uploaded image is okay and can be used. For example: /var/lib/kvmd/msd/meta/ubuntu-18.04.4-desktop-amd64.iso.complete Remount internal storage back to ro (read-only): # kvmd-helper-otgmsd-remount ro Multiple and writable drives \u00b6 Unless explicitly disabled by default, PiKVM creates only one drive for Mass Storage emulation. However, you can create additional drives and manage them manually via the terminal. This is useful if you want to boot the server from a ISO CD (specified in the web interface), then connect a virtual flash drive to the server and download some files from to PiKVM from it. Info The presence of an additional Mass Storage Drive should not interfere with the boot, but for reasons of compatibility paranoia, this is disabled by default. We recommend setting up the drives in advance, making sure that booting from the ISO CD is still working, and then using the drives as needed. How to enable extra drives \u00b6 Switch the root filesystem to rw mode. Edit /etc/kvmd/override.yaml and add these lines: otg : devices : drives : enabled : true # Set it to true to enable count : 1 # +1 drive, default value default : # Default configuration for the all extra drives cdrom : false # Default value (false for the generic flash drive) rw : false # Read-only by default If you specify count: N , you will create N additional drives configured the same way, as described in the default section. Perform reboot . How to create RW flash drive \u00b6 Switch the root filesystem to rw mode: # rw Create the empty image file of the desire size (1Gb in this example). # dd if=/dev/zero of=/root/flash.img bs=1M count=1000 status=progress Connect it to the drive 1: # kvmd-otgmsd -i 1 --set-rw=1 --set-cdrom=0 --set-image=/root/flash.img After that you will have access to the flash drive from the target server. Drive 0 represents a drive that is controlled via a web interface and API. Don't use it with kvmd-otgmsd if you don't know exactly what you're doing. View the driver state: # kvmd-otgmsd -i 1 Image file: /root/flash.img CD-ROM flag: no RW flag: yes To disable the flash drive and view the files on it from the KVM, run: # kvmd-otgmsd -i 1 --unlock --eject This command will interrupt the current IO operation on ALL DRIVES including the one that is managed via the web interface. The same result is achieved by clicking the disable media button in the web interface. Right now, the Linux kernel does not allow to distinguish between internal threads that manage different drives. It is recommended to eject the media when you know that this will not cause problems for the other media. Don't forget to remount the root filesystem to read-only mode: # ro You can download the resulting image via SCP or mount it as a loop device on the PiKVM. Create a Windows based Flash disk image \u00b6 An alternative version of this can be found below that does not require a physical usb flash This procedure will create a disk image of a USB stick. This is mostly required for Windows based images since they are larger than the CDROM based limit of 2.2GB. You can create a bootable USB stick with the normal Microsoft tools, e.g. Media Creation Tool. Creating a bootable USB stick can also be made from an ISO file with other tools like Rufus. Without resizing, the full size of the USB stick will be used, so keep the stick as small as possible (e.g. 4GB or 8GB) but still large enough for all Windows files. The Media Creation tool will tell you what the minimum size is. Before creating the image file, you can use a tool like \"EaseUS Partition Master Free\" or \"GParted\" to resize the main FAT32 partition on the USB stick. This will save space on PiKVM. You can also perform these steps on a separate unix machine and transfer the image over to pikvm with e.g. SCP. Or, on Windows you could use a program like PassMark ImageUSB (only for full USB size images) or 'dd' for Windows to create the image. Then use WinSCP to transfer the image over to PiKVM. Once you have the desired USB stick perform the following on the RPi to create the image directly to the PiKVM image storage folder. Insert Windows based USB stick into Pi4, generated with Microsoft USB creation tool. SSH to PiKVM as root. # dmesg [ 3025.025401] usb-storage 2-1:1.0: USB Mass Storage device detected [ 3025.038911] scsi host0: usb-storage 2-1:1.0 [ 3026.132248] scsi 0:0:0:0: Direct-Access Kingston DataTraveler 3.0 PMAP PQ: 0 ANSI: 6 [ 3026.771425] sd 0:0:0:0: [sda] 15360000 512-byte logical blocks: (7.86 GB/7.32 GiB) [ 3026.790276] sd 0:0:0:0: [sda] Write Protect is off [ 3026.802530] sd 0:0:0:0: [sda] Mode Sense: 23 00 00 00 [ 3026.804450] sd 0:0:0:0: [sda] No Caching mode page found [ 3026.814082] sd 0:0:0:0: [sda] Assuming drive cache: write through [ 3026.908712] sda: sda1 [ 3026.922794] sd 0:0:0:0: [sda] Attached SCSI removable disk [root@pikvm ~]# USB devices shows as sda . We will use sda1 as the Windows partition. mount msd folder as read/write # kvmd-helper-otgmsd-remount rw Create image of USB data PARTITION to an image file, this will take some time, in this case about 12 minutes (RPi4). # dd if=/dev/sda1 of=/var/lib/kvmd/msd/images/windows10-2004.bin bs=8M status=progress 4458545152 bytes (4.5 GB, 4.2 GiB) copied, 736 s, 6.1 MB/s 531+1 records in 531+1 records out 4458545152 bytes (4.5 GB, 4.2 GiB) copied, 736.213 s, 6.1 MB/s Correct ownership of new image and make sure the website reports the file as complete (pay attention to the different folder). # chown kvmd:kvmd /var/lib/kvmd/msd/images/windows10-2004.bin # touch /var/lib/kvmd/msd/meta/windows10-2004.bin.complete Remount msd folder as read only # kvmd-helper-otgmsd-remount ro On PiKVM webpage, under Storage select the new image and connect it in Drive Mode: Flash to the server. Boot the server and select boot device like you normally would. E.g. in a AMI BIOS the boot device is called \"Linux File-CD Gadget 0504\". Create a drive image on macOS \u00b6 Open Disk Utility. File > New Image > Blank Image . Save As: pikvm-image.dmg . Name: pikvm-image . Size: 100 MB (or whatever size you want). Format: MS-DOS (FAT) . Partitions: Single partition - GUID Partition Map . Image Format: read/write disk image . Click Save. The drive will automatically be mounted. Copy files (such as BIOS updates) onto the new image (via terminal or drag and drop in Finder). Eject image. Rename file to .img Upload image to PiKVM interface under \"Drive\". Select Drive Mode: Flash and then Connect drive to Server . You should be able to then mount it locally on the server, or reboot the device to do things like BIOS updates. An alternative to making a Windows boot image that does not require a physical usb flash drive \u00b6 Physical USB is not needed but external system is mandatory. Create Ventoy image (on Ubuntu x86 machine) (Unaware of a windows version). There is an assumption that you know basic linux to understand that not all dev devices are named exactly like the below dd if=/dev/zero of=ventoy.img bs=1M count=4700 status=progress This makes a ventoy.img file, I would name this what it is EG: ventoy_win10.img At the same time, download Media Creation Tool and select iso On the Ubuntu machine At the time of this, it was 1.0.51, change to latest version wget https://github.com/ventoy/Ventoy/releases/download/v1.0.51/ventoy-1.0.51-linux.tar.gz tar zxvf ventoy-1.0.51-linux.tar.gz sudo losetup -f ventoy.img sudo losetup -l | grep ventoy (To locate which loop device was used) sudo sh ~/ventoy-1.0.51/Ventoy2Disk.sh -i /dev/loopXX (This will make a loopXXp1 and a loopXXp2 and will format both partitions cd /media/XXX (Usually your login) mkdir ventoy sudo mount /dev/loopXXp1 /media/XXX/ventoy Either cp/scp over the .iso you downloaded from the Media tool or use a NFS mount sudo cp windows.iso /media/XXX/ventoy sudo umount /dev/loopXX # This is going to be different for everyone, please choose the same one you mounted earlier sudo losetup -d /dev/loopXX # This may or may not work for everyone, if it doesnt work, skip and move forward# ssh into the Ubuntu system (Or whatever OS you are using) On PiKVM cd /var/lib/kvmd/msd mount -o remount,rw . On Ubuntu scp ventoy.img root@pikvm:/var/lib/kvmd/msd/images On PiKVM touch /var/lib/kvmd/msd/meta/ventoy.img.complete Mount ventoy.img as normal flash and select the PiKVM boot device, it should popup with the VenToy logo with the window.iso as a selection","title":"Mass Storage Drive"},{"location":"msd/#mass-storage-drive","text":"","title":"Mass Storage Drive"},{"location":"msd/#basics","text":"This is a feature available on PiKVM v2+ that allows you to emulate a CD-ROM or Flash Drive. There are some subtleties that you should know: The size of the CD-ROM image is limited to 2.2 GB This is a limitation of the Linux kernel, which currently cannot emulate a DVD. To use a larger boot image, use Flash emulation. If this is not possible (the image does not support Flash, for example, for Windows), use this recipe. Changing the media type between CD-ROM and Flash is possible only when the device is reconnected For PiKVM v3 HAT, this can be done using the switch System -> Connect main USB . In this case, the media type is determined at the time of connecting the image, and not by clicking on the switch . The switch affects the settings of the future connection. For non-v3 devices, you need to either reboot your server or otherwise reinitialize the connection. Advanced Linux knowledge is necessary for some advanced aspects that are not part of the normal use case. IE: making larger flash files will need a different file location and those instructions will need to be modified. The following instructions are for you to have something to start with.","title":"Basics"},{"location":"msd/#disable-msd","text":"To disable mass storage emulation altogether, you can place the following piece of configuration into /etc/kvmd/override.yaml : kvmd : msd : type : disabled","title":"Disable MSD"},{"location":"msd/#upload-images-manually-without-web-ui","text":"Remount internal storage to rw (read-write): # kvmd-helper-otgmsd-remount rw Upload the .ISO image(s) to /var/lib/kvmd/msd/images via scp or similar. Create an empty file in /var/lib/kvmd/msd/meta/ with the exact name (case sensitive!) of the uploaded image. This will indicate PiKVM that the uploaded image is okay and can be used. For example: /var/lib/kvmd/msd/meta/ubuntu-18.04.4-desktop-amd64.iso.complete Remount internal storage back to ro (read-only): # kvmd-helper-otgmsd-remount ro","title":"Upload images manually (without Web UI)"},{"location":"msd/#multiple-and-writable-drives","text":"Unless explicitly disabled by default, PiKVM creates only one drive for Mass Storage emulation. However, you can create additional drives and manage them manually via the terminal. This is useful if you want to boot the server from a ISO CD (specified in the web interface), then connect a virtual flash drive to the server and download some files from to PiKVM from it. Info The presence of an additional Mass Storage Drive should not interfere with the boot, but for reasons of compatibility paranoia, this is disabled by default. We recommend setting up the drives in advance, making sure that booting from the ISO CD is still working, and then using the drives as needed.","title":"Multiple and writable drives"},{"location":"msd/#how-to-enable-extra-drives","text":"Switch the root filesystem to rw mode. Edit /etc/kvmd/override.yaml and add these lines: otg : devices : drives : enabled : true # Set it to true to enable count : 1 # +1 drive, default value default : # Default configuration for the all extra drives cdrom : false # Default value (false for the generic flash drive) rw : false # Read-only by default If you specify count: N , you will create N additional drives configured the same way, as described in the default section. Perform reboot .","title":"How to enable extra drives"},{"location":"msd/#how-to-create-rw-flash-drive","text":"Switch the root filesystem to rw mode: # rw Create the empty image file of the desire size (1Gb in this example). # dd if=/dev/zero of=/root/flash.img bs=1M count=1000 status=progress Connect it to the drive 1: # kvmd-otgmsd -i 1 --set-rw=1 --set-cdrom=0 --set-image=/root/flash.img After that you will have access to the flash drive from the target server. Drive 0 represents a drive that is controlled via a web interface and API. Don't use it with kvmd-otgmsd if you don't know exactly what you're doing. View the driver state: # kvmd-otgmsd -i 1 Image file: /root/flash.img CD-ROM flag: no RW flag: yes To disable the flash drive and view the files on it from the KVM, run: # kvmd-otgmsd -i 1 --unlock --eject This command will interrupt the current IO operation on ALL DRIVES including the one that is managed via the web interface. The same result is achieved by clicking the disable media button in the web interface. Right now, the Linux kernel does not allow to distinguish between internal threads that manage different drives. It is recommended to eject the media when you know that this will not cause problems for the other media. Don't forget to remount the root filesystem to read-only mode: # ro You can download the resulting image via SCP or mount it as a loop device on the PiKVM.","title":"How to create RW flash drive"},{"location":"msd/#create-a-windows-based-flash-disk-image","text":"An alternative version of this can be found below that does not require a physical usb flash This procedure will create a disk image of a USB stick. This is mostly required for Windows based images since they are larger than the CDROM based limit of 2.2GB. You can create a bootable USB stick with the normal Microsoft tools, e.g. Media Creation Tool. Creating a bootable USB stick can also be made from an ISO file with other tools like Rufus. Without resizing, the full size of the USB stick will be used, so keep the stick as small as possible (e.g. 4GB or 8GB) but still large enough for all Windows files. The Media Creation tool will tell you what the minimum size is. Before creating the image file, you can use a tool like \"EaseUS Partition Master Free\" or \"GParted\" to resize the main FAT32 partition on the USB stick. This will save space on PiKVM. You can also perform these steps on a separate unix machine and transfer the image over to pikvm with e.g. SCP. Or, on Windows you could use a program like PassMark ImageUSB (only for full USB size images) or 'dd' for Windows to create the image. Then use WinSCP to transfer the image over to PiKVM. Once you have the desired USB stick perform the following on the RPi to create the image directly to the PiKVM image storage folder. Insert Windows based USB stick into Pi4, generated with Microsoft USB creation tool. SSH to PiKVM as root. # dmesg [ 3025.025401] usb-storage 2-1:1.0: USB Mass Storage device detected [ 3025.038911] scsi host0: usb-storage 2-1:1.0 [ 3026.132248] scsi 0:0:0:0: Direct-Access Kingston DataTraveler 3.0 PMAP PQ: 0 ANSI: 6 [ 3026.771425] sd 0:0:0:0: [sda] 15360000 512-byte logical blocks: (7.86 GB/7.32 GiB) [ 3026.790276] sd 0:0:0:0: [sda] Write Protect is off [ 3026.802530] sd 0:0:0:0: [sda] Mode Sense: 23 00 00 00 [ 3026.804450] sd 0:0:0:0: [sda] No Caching mode page found [ 3026.814082] sd 0:0:0:0: [sda] Assuming drive cache: write through [ 3026.908712] sda: sda1 [ 3026.922794] sd 0:0:0:0: [sda] Attached SCSI removable disk [root@pikvm ~]# USB devices shows as sda . We will use sda1 as the Windows partition. mount msd folder as read/write # kvmd-helper-otgmsd-remount rw Create image of USB data PARTITION to an image file, this will take some time, in this case about 12 minutes (RPi4). # dd if=/dev/sda1 of=/var/lib/kvmd/msd/images/windows10-2004.bin bs=8M status=progress 4458545152 bytes (4.5 GB, 4.2 GiB) copied, 736 s, 6.1 MB/s 531+1 records in 531+1 records out 4458545152 bytes (4.5 GB, 4.2 GiB) copied, 736.213 s, 6.1 MB/s Correct ownership of new image and make sure the website reports the file as complete (pay attention to the different folder). # chown kvmd:kvmd /var/lib/kvmd/msd/images/windows10-2004.bin # touch /var/lib/kvmd/msd/meta/windows10-2004.bin.complete Remount msd folder as read only # kvmd-helper-otgmsd-remount ro On PiKVM webpage, under Storage select the new image and connect it in Drive Mode: Flash to the server. Boot the server and select boot device like you normally would. E.g. in a AMI BIOS the boot device is called \"Linux File-CD Gadget 0504\".","title":"Create a Windows based Flash disk image"},{"location":"msd/#create-a-drive-image-on-macos","text":"Open Disk Utility. File > New Image > Blank Image . Save As: pikvm-image.dmg . Name: pikvm-image . Size: 100 MB (or whatever size you want). Format: MS-DOS (FAT) . Partitions: Single partition - GUID Partition Map . Image Format: read/write disk image . Click Save. The drive will automatically be mounted. Copy files (such as BIOS updates) onto the new image (via terminal or drag and drop in Finder). Eject image. Rename file to .img Upload image to PiKVM interface under \"Drive\". Select Drive Mode: Flash and then Connect drive to Server . You should be able to then mount it locally on the server, or reboot the device to do things like BIOS updates.","title":"Create a drive image on macOS"},{"location":"msd/#an-alternative-to-making-a-windows-boot-image-that-does-not-require-a-physical-usb-flash-drive","text":"Physical USB is not needed but external system is mandatory. Create Ventoy image (on Ubuntu x86 machine) (Unaware of a windows version). There is an assumption that you know basic linux to understand that not all dev devices are named exactly like the below dd if=/dev/zero of=ventoy.img bs=1M count=4700 status=progress This makes a ventoy.img file, I would name this what it is EG: ventoy_win10.img At the same time, download Media Creation Tool and select iso On the Ubuntu machine At the time of this, it was 1.0.51, change to latest version wget https://github.com/ventoy/Ventoy/releases/download/v1.0.51/ventoy-1.0.51-linux.tar.gz tar zxvf ventoy-1.0.51-linux.tar.gz sudo losetup -f ventoy.img sudo losetup -l | grep ventoy (To locate which loop device was used) sudo sh ~/ventoy-1.0.51/Ventoy2Disk.sh -i /dev/loopXX (This will make a loopXXp1 and a loopXXp2 and will format both partitions cd /media/XXX (Usually your login) mkdir ventoy sudo mount /dev/loopXXp1 /media/XXX/ventoy Either cp/scp over the .iso you downloaded from the Media tool or use a NFS mount sudo cp windows.iso /media/XXX/ventoy sudo umount /dev/loopXX # This is going to be different for everyone, please choose the same one you mounted earlier sudo losetup -d /dev/loopXX # This may or may not work for everyone, if it doesnt work, skip and move forward# ssh into the Ubuntu system (Or whatever OS you are using) On PiKVM cd /var/lib/kvmd/msd mount -o remount,rw . On Ubuntu scp ventoy.img root@pikvm:/var/lib/kvmd/msd/images On PiKVM touch /var/lib/kvmd/msd/meta/ventoy.img.complete Mount ventoy.img as normal flash and select the PiKVM boot device, it should popup with the VenToy logo with the window.iso as a selection","title":"An alternative to making a Windows boot image that does not require a physical usb flash drive"},{"location":"multiport/","text":"Multiport KVM over IP \u00b6 There are many ways to do this, but the best and most documented one right now is to use the ezCoo KVM switch . Also, PiKVM can be connected to a multi-port HDMI/USB switch and the switch's buttons can be connected via optocouplers to the Pi's GPIO to switch channels . If your KVM switches channels using keyboard shortcuts, there is a chance that it will not be able to work with OTG (v2+ platform, see below), since it does not fully implement the USB stack. In this case, you will have to use an Arduino board to emulate the keyboard & mouse (PiKVM supports this configuration). Warning If you choose AIMOS, be aware that it has a back powering issue that you need to use work arounds for. Limitations are are listed below. Also please be aware that Arduino's will not work with the AIMOS KVM's. List of tested KVMs \u00b6 Here the status is: \u2714 - Everything is working as expected. There may be some subtleties. \u2639 - Not everything works. Additional work is needed for some functions to work, like MSD. \u2718 - The keyboard or mouse does not work at all, the switch loses the image, etc. Model Status Notes ezCoo EZ-SW41HA-KVMU3L 4x1 switch ezCoo SW41HA HDMI 4x1 switch (legacy) \u2714 Using with PiKVM - 4 Port is the ONLY supported KVM, 2 Port does not work the same and is not supported ezcoo EZ-SW41H21-KVMU3P 8K 4x1 switch \u2714 Does NOT have a control port. MSD Works. Can be managed through key combo (ctrl+ctrl+#) TESmart 8 PORT - HDMI KVM SWITCH \u2714 Use OTG with USB 2.0 Hub only, no hotkey support. Switching available with serial or IP-to-serial interface using fixed IP (/31 peer-to-peer addressing supported). Can be managed via WebUI or CLI tool XH-HK4401 4-port HDMI USB KVM Switch \u2714 Using with PiKVM - USB MSD works, requires the HDMI backpower solutions found below Ali's noname \u2714 Limitations are listed below AIMOS 8-port HDMI USB-C KVM Switch \u2639 Similar to Ali's noname model, available in 4/8port editions, has same HDMI bridge boot problem/solution using a Marmitek 312 UHD HDMI splitter. ONLY supports HotKey switching. Limitations are are listed below Aten CS1758 8-port PS/2 / USB VGA KVM switch \u2639 Older Aten switches can be had for cheap and can be a viable alternative. Devices are connected via PS/2 so USB media support does not work. The setup relies on a VGA-> HDMI adapter to make the video signal work and there can be issues with unsupported VGA resolutions with some adapters. KVM hotkeys and switching all work and so does mouse and keyboard. Limitations: HDMI backpower solutions: See here See here - Advanced soldering required This loop capture device v3 HAT v3.3 (Kickstarter model and later) also takes care of the back power issue MSD workaround (will not work OOB) RPi4 OTG needs to be in the KB port for mouse and KB funtionality, ZeroW is required and needs to be connected to the HUB port for HK switching and MSD functionality - \u2714 KNOWN WORKING \u2714 See here - Advanced soldering required - allows use of GPIO menu to change input","title":"Multiport KVM-over-IP"},{"location":"multiport/#multiport-kvm-over-ip","text":"There are many ways to do this, but the best and most documented one right now is to use the ezCoo KVM switch . Also, PiKVM can be connected to a multi-port HDMI/USB switch and the switch's buttons can be connected via optocouplers to the Pi's GPIO to switch channels . If your KVM switches channels using keyboard shortcuts, there is a chance that it will not be able to work with OTG (v2+ platform, see below), since it does not fully implement the USB stack. In this case, you will have to use an Arduino board to emulate the keyboard & mouse (PiKVM supports this configuration). Warning If you choose AIMOS, be aware that it has a back powering issue that you need to use work arounds for. Limitations are are listed below. Also please be aware that Arduino's will not work with the AIMOS KVM's.","title":"Multiport KVM over IP"},{"location":"multiport/#list-of-tested-kvms","text":"Here the status is: \u2714 - Everything is working as expected. There may be some subtleties. \u2639 - Not everything works. Additional work is needed for some functions to work, like MSD. \u2718 - The keyboard or mouse does not work at all, the switch loses the image, etc. Model Status Notes ezCoo EZ-SW41HA-KVMU3L 4x1 switch ezCoo SW41HA HDMI 4x1 switch (legacy) \u2714 Using with PiKVM - 4 Port is the ONLY supported KVM, 2 Port does not work the same and is not supported ezcoo EZ-SW41H21-KVMU3P 8K 4x1 switch \u2714 Does NOT have a control port. MSD Works. Can be managed through key combo (ctrl+ctrl+#) TESmart 8 PORT - HDMI KVM SWITCH \u2714 Use OTG with USB 2.0 Hub only, no hotkey support. Switching available with serial or IP-to-serial interface using fixed IP (/31 peer-to-peer addressing supported). Can be managed via WebUI or CLI tool XH-HK4401 4-port HDMI USB KVM Switch \u2714 Using with PiKVM - USB MSD works, requires the HDMI backpower solutions found below Ali's noname \u2714 Limitations are listed below AIMOS 8-port HDMI USB-C KVM Switch \u2639 Similar to Ali's noname model, available in 4/8port editions, has same HDMI bridge boot problem/solution using a Marmitek 312 UHD HDMI splitter. ONLY supports HotKey switching. Limitations are are listed below Aten CS1758 8-port PS/2 / USB VGA KVM switch \u2639 Older Aten switches can be had for cheap and can be a viable alternative. Devices are connected via PS/2 so USB media support does not work. The setup relies on a VGA-> HDMI adapter to make the video signal work and there can be issues with unsupported VGA resolutions with some adapters. KVM hotkeys and switching all work and so does mouse and keyboard. Limitations: HDMI backpower solutions: See here See here - Advanced soldering required This loop capture device v3 HAT v3.3 (Kickstarter model and later) also takes care of the back power issue MSD workaround (will not work OOB) RPi4 OTG needs to be in the KB port for mouse and KB funtionality, ZeroW is required and needs to be connected to the HUB port for HK switching and MSD functionality - \u2714 KNOWN WORKING \u2714 See here - Advanced soldering required - allows use of GPIO menu to change input","title":"List of tested KVMs"},{"location":"ocr/","text":"OCR \u00b6 This feature allows you to select a screen region, recognize it as text and copy this text to the clipboard. Recognition works locally on your PiKVM and does not use any cloud services. It uses the Tesseract OCR library . Tesseract does not see your image until you explicitly give the recognition command. The evil AI is not watching your screen. Language support \u00b6 For any language, you will have to install its support. It is very easy to do this (English language for example): # rw # pacman --assume-installed tessdata -S tesseract-data-eng # ro List all available languages in the repository: # pacman -Ss tesseract-data Disabling OCR \u00b6 If you want to get rid of this feature completely, you need to delete Tesseract and all its data: # rw # pacman -R tesseract # reboot","title":"OCR"},{"location":"ocr/#ocr","text":"This feature allows you to select a screen region, recognize it as text and copy this text to the clipboard. Recognition works locally on your PiKVM and does not use any cloud services. It uses the Tesseract OCR library . Tesseract does not see your image until you explicitly give the recognition command. The evil AI is not watching your screen.","title":"OCR"},{"location":"ocr/#language-support","text":"For any language, you will have to install its support. It is very easy to do this (English language for example): # rw # pacman --assume-installed tessdata -S tesseract-data-eng # ro List all available languages in the repository: # pacman -Ss tesseract-data","title":"Language support"},{"location":"ocr/#disabling-ocr","text":"If you want to get rid of this feature completely, you need to delete Tesseract and all its data: # rw # pacman -R tesseract # reboot","title":"Disabling OCR"},{"location":"port_forwarding/","text":"Port forwarding \u00b6 If your ISP has provided you with an external IP address for the router, you can configure port forwarding to access PiKVM. Warning Change passwords before opening access to PiKVM from the outside Internet The Web UI runs on port 80 and 443 . VNC (if you use it) runs on port 5900 . If you don't have an external IP address, then we recommend trying Tailscale VPN .","title":"Port forwarding"},{"location":"port_forwarding/#port-forwarding","text":"If your ISP has provided you with an external IP address for the router, you can configure port forwarding to access PiKVM. Warning Change passwords before opening access to PiKVM from the outside Internet The Web UI runs on port 80 and 443 . VNC (if you use it) runs on port 5900 . If you don't have an external IP address, then we recommend trying Tailscale VPN .","title":"Port forwarding"},{"location":"prometheus/","text":"Prometheus metrics \u00b6 Prometheus is one of the popular monitoring systems. It pulls service's endpoint to get metrics in a simple text format . PiKVM has the ability to export some information to this system such as the server's ATX state, Pi's temperature, GPIO state and some other things. Configure Prometheus \u00b6 To enable Prometheus getting metrics from pikvm following config could be used: scrape_configs : - job_name : \"pikvm\" metrics_path : \"/api/export/prometheus/metrics\" basic_auth : username : admin password : admin scheme : https static_configs : - targets : [ \"pikvm\" ] tls_config : insecure_skip_verify : true # For self-signed certificate Output example \u00b6 This example includes the GPIO from the PiKVM's test config . $ curl -k -HX-KVMD-User:admin -HX-KVMD-Passwd:admin https://pikvm/api/export/prometheus/metrics # TYPE pikvm_atx_enabled gauge pikvm_atx_enabled 1 # TYPE pikvm_atx_power gauge pikvm_atx_power 0 # TYPE pikvm_gpio_input_online_led1 gauge pikvm_gpio_input_online_led1 0 # TYPE pikvm_gpio_input_state_led1 gauge pikvm_gpio_input_state_led1 0 # TYPE pikvm_gpio_input_online_led2 gauge pikvm_gpio_input_online_led2 0 # TYPE pikvm_gpio_input_state_led2 gauge pikvm_gpio_input_state_led2 0 # TYPE pikvm_gpio_output_online_button1 gauge pikvm_gpio_output_online_button1 0 # TYPE pikvm_gpio_output_state_button1 gauge pikvm_gpio_output_state_button1 0 # TYPE pikvm_gpio_output_online_button2 gauge pikvm_gpio_output_online_button2 0 # TYPE pikvm_gpio_output_state_button2 gauge pikvm_gpio_output_state_button2 0 # TYPE pikvm_gpio_output_online_relay1 gauge pikvm_gpio_output_online_relay1 0 # TYPE pikvm_gpio_output_state_relay1 gauge pikvm_gpio_output_state_relay1 0 # TYPE pikvm_gpio_output_online_relay2 gauge pikvm_gpio_output_online_relay2 0 # TYPE pikvm_gpio_output_state_relay2 gauge pikvm_gpio_output_state_relay2 0 # TYPE pikvm_hw_temp_cpu gauge pikvm_hw_temp_cpu 36 .511 # TYPE pikvm_hw_temp_gpu gauge pikvm_hw_temp_gpu 35 .0 # TYPE pikvm_hw_throttling_freq_capped_now gauge pikvm_hw_throttling_freq_capped_now 0 # TYPE pikvm_hw_throttling_freq_capped_past gauge pikvm_hw_throttling_freq_capped_past 0 # TYPE pikvm_hw_throttling_throttled_now gauge pikvm_hw_throttling_throttled_now 0 # TYPE pikvm_hw_throttling_throttled_past gauge pikvm_hw_throttling_throttled_past 0 # TYPE pikvm_hw_throttling_undervoltage_now gauge pikvm_hw_throttling_undervoltage_now 0 # TYPE pikvm_hw_throttling_undervoltage_past gauge pikvm_hw_throttling_undervoltage_past 0 # TYPE pikvm_hw_throttling_raw_flags gauge pikvm_hw_throttling_raw_flags 0 * Connection #0 to host localhost left intact","title":"Prometheus monitoring"},{"location":"prometheus/#prometheus-metrics","text":"Prometheus is one of the popular monitoring systems. It pulls service's endpoint to get metrics in a simple text format . PiKVM has the ability to export some information to this system such as the server's ATX state, Pi's temperature, GPIO state and some other things.","title":"Prometheus metrics"},{"location":"prometheus/#configure-prometheus","text":"To enable Prometheus getting metrics from pikvm following config could be used: scrape_configs : - job_name : \"pikvm\" metrics_path : \"/api/export/prometheus/metrics\" basic_auth : username : admin password : admin scheme : https static_configs : - targets : [ \"pikvm\" ] tls_config : insecure_skip_verify : true # For self-signed certificate","title":"Configure Prometheus"},{"location":"prometheus/#output-example","text":"This example includes the GPIO from the PiKVM's test config . $ curl -k -HX-KVMD-User:admin -HX-KVMD-Passwd:admin https://pikvm/api/export/prometheus/metrics # TYPE pikvm_atx_enabled gauge pikvm_atx_enabled 1 # TYPE pikvm_atx_power gauge pikvm_atx_power 0 # TYPE pikvm_gpio_input_online_led1 gauge pikvm_gpio_input_online_led1 0 # TYPE pikvm_gpio_input_state_led1 gauge pikvm_gpio_input_state_led1 0 # TYPE pikvm_gpio_input_online_led2 gauge pikvm_gpio_input_online_led2 0 # TYPE pikvm_gpio_input_state_led2 gauge pikvm_gpio_input_state_led2 0 # TYPE pikvm_gpio_output_online_button1 gauge pikvm_gpio_output_online_button1 0 # TYPE pikvm_gpio_output_state_button1 gauge pikvm_gpio_output_state_button1 0 # TYPE pikvm_gpio_output_online_button2 gauge pikvm_gpio_output_online_button2 0 # TYPE pikvm_gpio_output_state_button2 gauge pikvm_gpio_output_state_button2 0 # TYPE pikvm_gpio_output_online_relay1 gauge pikvm_gpio_output_online_relay1 0 # TYPE pikvm_gpio_output_state_relay1 gauge pikvm_gpio_output_state_relay1 0 # TYPE pikvm_gpio_output_online_relay2 gauge pikvm_gpio_output_online_relay2 0 # TYPE pikvm_gpio_output_state_relay2 gauge pikvm_gpio_output_state_relay2 0 # TYPE pikvm_hw_temp_cpu gauge pikvm_hw_temp_cpu 36 .511 # TYPE pikvm_hw_temp_gpu gauge pikvm_hw_temp_gpu 35 .0 # TYPE pikvm_hw_throttling_freq_capped_now gauge pikvm_hw_throttling_freq_capped_now 0 # TYPE pikvm_hw_throttling_freq_capped_past gauge pikvm_hw_throttling_freq_capped_past 0 # TYPE pikvm_hw_throttling_throttled_now gauge pikvm_hw_throttling_throttled_now 0 # TYPE pikvm_hw_throttling_throttled_past gauge pikvm_hw_throttling_throttled_past 0 # TYPE pikvm_hw_throttling_undervoltage_now gauge pikvm_hw_throttling_undervoltage_now 0 # TYPE pikvm_hw_throttling_undervoltage_past gauge pikvm_hw_throttling_undervoltage_past 0 # TYPE pikvm_hw_throttling_raw_flags gauge pikvm_hw_throttling_raw_flags 0 * Connection #0 to host localhost left intact","title":"Output example"},{"location":"pst/","text":"Persistent storage \u00b6 Note This feature is available on images newer than 2022.06.20 Sometimes advanced use of PiKVM requires storing some data on disk like API keys, config files, or something like that. For example, you want to have a script that will update SSL certificates once a week. However, the root file system is in a read-only state and does not involve remounting automatically by user scripts. To solve this problem, new versions of PiKVM have a small 256MiB storage partition that can be used to store that data. A special kvmd-pst daemon makes sure that this partition is mounted in read-only all the time, and remounts it to RW only when some user script requires it. This also solves the problems of simultaneous access, so the RW mode will be keeped as long as at least one client is working with the storage. Usage \u00b6 Below is an example of a script /root/test.sh that wants to save a certain file in PST: #!/bin/bash echo ` date ` + $@ > $KVMD_PST_DATA /foo cat $KVMD_PST_DATA /foo To run it use: # kvmd-pstrun -- /root/test.sh --some --script --args -- INFO -- Opening PST session ... -- INFO -- PST write is allowed: /var/lib/kvmd/pst/data -- INFO -- Running the process ... Mon Jun 20 04:23:14 MSK 2022 + --some --script --args -- INFO -- Process finished: returncode=0 So, what's going on here: kvmd-pstrun connects to the kvmd-pst daemon, which manages the mounting of the storage. If everything is fine, the daemon will remount the storage to RW mode and report the data root to kvmd-pstrun . kvmd-pstrun runs the script and pass the data root path using the environment variable KVMD_PST_DATA ( /var/lib/kvmd/pst/data ). If the kvmd-pst daemon stops or any other daemon error occurs, the script will be killed. After the script is finished, the daemon will remount the storage to RO mode. To be able to write to the storage, the user must be a member of kvmd-pst group, or have to be root . The return code will be equal to the script code if it was run, or 1 if a remount error occurred.","title":"Persistent storage"},{"location":"pst/#persistent-storage","text":"Note This feature is available on images newer than 2022.06.20 Sometimes advanced use of PiKVM requires storing some data on disk like API keys, config files, or something like that. For example, you want to have a script that will update SSL certificates once a week. However, the root file system is in a read-only state and does not involve remounting automatically by user scripts. To solve this problem, new versions of PiKVM have a small 256MiB storage partition that can be used to store that data. A special kvmd-pst daemon makes sure that this partition is mounted in read-only all the time, and remounts it to RW only when some user script requires it. This also solves the problems of simultaneous access, so the RW mode will be keeped as long as at least one client is working with the storage.","title":"Persistent storage"},{"location":"pst/#usage","text":"Below is an example of a script /root/test.sh that wants to save a certain file in PST: #!/bin/bash echo ` date ` + $@ > $KVMD_PST_DATA /foo cat $KVMD_PST_DATA /foo To run it use: # kvmd-pstrun -- /root/test.sh --some --script --args -- INFO -- Opening PST session ... -- INFO -- PST write is allowed: /var/lib/kvmd/pst/data -- INFO -- Running the process ... Mon Jun 20 04:23:14 MSK 2022 + --some --script --args -- INFO -- Process finished: returncode=0 So, what's going on here: kvmd-pstrun connects to the kvmd-pst daemon, which manages the mounting of the storage. If everything is fine, the daemon will remount the storage to RW mode and report the data root to kvmd-pstrun . kvmd-pstrun runs the script and pass the data root path using the environment variable KVMD_PST_DATA ( /var/lib/kvmd/pst/data ). If the kvmd-pst daemon stops or any other daemon error occurs, the script will be killed. After the script is finished, the daemon will remount the storage to RO mode. To be able to write to the storage, the user must be a member of kvmd-pst group, or have to be root . The return code will be equal to the script code if it was run, or 1 if a remount error occurred.","title":"Usage"},{"location":"tailscale/","text":"Tailscale VPN \u00b6 Tailscale can be used to access PiKVM on the internal network. This is a convenient and free (for private use) tool for organizing a small VPN network. This document is provided as an example for accessing your pikvm over the inet but you can also use zerotier or remote.it. Basic support like whats shown below is provided as an example, any other setting or functionality needs to be redirected to the appropriate community. Installation \u00b6 On the PiKVM side \u00b6 Use these commands: # rw # pacman -Syy # pacman -S tailscale-pikvm # systemctl enable --now tailscaled # tailscale up Follow the link to authorize this installation. After success, perform soft reboot using reboot command to make sure that everything will work correctly. Perform command ip addr show tailscale0 to view the Tailscale IP address. For each device you wish to access pikvm \u00b6 Download and install tailscale for your OS to the system you are using, not to the system you want to control. Check the admin page to view your VPN network. Follow the URL in the web browser: https://<tailscale_kvm_ip> and you will see PiKVM web interface.","title":"Tailscale VPN"},{"location":"tailscale/#tailscale-vpn","text":"Tailscale can be used to access PiKVM on the internal network. This is a convenient and free (for private use) tool for organizing a small VPN network. This document is provided as an example for accessing your pikvm over the inet but you can also use zerotier or remote.it. Basic support like whats shown below is provided as an example, any other setting or functionality needs to be redirected to the appropriate community.","title":"Tailscale VPN"},{"location":"tailscale/#installation","text":"","title":"Installation"},{"location":"tailscale/#on-the-pikvm-side","text":"Use these commands: # rw # pacman -Syy # pacman -S tailscale-pikvm # systemctl enable --now tailscaled # tailscale up Follow the link to authorize this installation. After success, perform soft reboot using reboot command to make sure that everything will work correctly. Perform command ip addr show tailscale0 to view the Tailscale IP address.","title":"On the PiKVM side"},{"location":"tailscale/#for-each-device-you-wish-to-access-pikvm","text":"Download and install tailscale for your OS to the system you are using, not to the system you want to control. Check the admin page to view your VPN network. Follow the URL in the web browser: https://<tailscale_kvm_ip> and you will see PiKVM web interface.","title":"For each device you wish to access pikvm"},{"location":"tesmart/","text":"TESMART managed multiport KVM switch \u00b6 The TESMART managed switch can be controlled by PiKVM to allow it to connect to multiple hosts. A typical scenario is a single PiKVM device which can control and switch between multiple hosts or servers using the TESMART switch. UI elements can be added to the GPIO dropdown to allow switching between hosts from the PiKVM webpage. The instructions here were tested with the TESMART HKS1601A10 HDMI 16x1 switch . This should work with any of the other TESMART variants which have a LAN port - there is both a 8x1 and 4x1 variant. This was tested with an RPI4, but as this is executed over a network protocol, this should with almost anything. Connections \u00b6 From a high level, the TESMART switch uses standard connections to the host machines (USB-A to USB-B and HDMI). The Raspberry Pi OTG connector (the one coming from the USB-C port on a Pi 4 via the custom splitter cable or device) should be connected to one of the USB 2 output ports on the TESMART switch (not the keyboard/mouse port). Based on your specific devices, and to get boot images to mount, you may need to connect this through a USB 2 hub. Connect the USB-A cable from the Raspberry Pi OTG port to one of the TESMART switch USB 2 output ports on the back of the switch (not the keyboard/mouse ports). Connect the HDMI out from the TESMART switch to the Raspberry Pi CSI-2 to HMDI input. Connect the LAN port on the front of the switch using standard ethernet cable into one of your network switches. Connect host USB and HDMI cables from the TESMART switch to the machines to be managed per the switch instructions. Warning There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi CSI2-HDMI encoder. These limitations apply equally when using the TESMART KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the TESMART switch before powering the hosts on. Setting the IP Address of the TESMART switch \u00b6 In some ways, this is the most complex part of this. The default IP address of the TESMART switch is 192.168.1.10. If that happens to work with your IP addressing scheme and current set of addresses, then you may be all set. This IP address is not configurable via DHCP or other standard mechanisms. The only way to change it is with a Windows utility available on the TESMART Downloads Page . If you need to change it, you will first need to connect to the switch with a Windows machine, most easily directly through an ethernet cord, with your Windows laptop (or VM) up and assigned to a fixed IP address, such as 192.168.1.5. Once you've launched the utility you will see this screen: On this screen, ensure you are on the \"General\" tab. Click the radio button for \"Network control\". Change the IP address to the default for the switch (may already be this -- 192.168.1.10). Press the \"Connect\" button. Should make the status light go green, as well as the selected port. If you do not get a connection here, you cannot proceed to change the IP address. To change the IP address, change to the \"Settings\" tab at the top. You will then see this screen: On this screen, change to your desired IP address, gateway, mask, and port. Then press apply. Watch the box on the right to see if it applied OK. Press Query again to double-check. The actual IP address will not be changed until you power off/power on the switch. Make sure you have these settings correct, because if you get them wrong you would have to connect over RS232/serial and not the network. There may be alternatives other than changing the IP address in this manner if you don't have access to a Windows machine or if this address doesn't work for you. See this README for other options (Images and concepts from the bash file were borrowed for creation of this plugin). This also contains a summary of the protocol, which is also available on the TESMART downloads page. Adding UI elements to control the KVM switch \u00b6 The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected. The instructions below will make these available in the PiKVM UI after clicking the \"Switches\" menu button in the KVM view. Enable read-write mode on the SD card via rw Edit the /etc/kvmd/override.yaml file and include the following: kvmd : gpio : drivers : tes : type : tesmart host : 10.10.1.10 port : 5000 scheme : server0_led : driver : tes pin : 0 mode : input server0_switch : driver : tes pin : 0 mode : output switch : false server1_led : driver : tes pin : 1 mode : input server1_switch : driver : tes pin : 1 mode : output switch : false server2_led : driver : tes pin : 2 mode : input server2_switch : driver : tes pin : 2 mode : output switch : false server3_led : driver : tes pin : 3 mode : input server3_switch : driver : tes pin : 3 mode : output switch : false view : table : - [ \"TESMART Switch\" ] - [] - [ \"#Server 1\" , server0_led , server0_switch|Switch ] - [ \"#Server 2\" , server1_led , server1_switch|Switch ] - [ \"#Server 3\" , server2_led , server2_switch|Switch ] - [ \"#Server 4\" , server3_led , server3_switch|Switch ] Return to read-only mode for the sd card via ro Restart the kvmd service: systemctl restart kvmd Switching between hosts in the UI \u00b6 To switch between hosts, enter the KVM UI and click the \"Switches\" menu. You should see your inputs, one of which will have a green circle indicating it is currently selected. Click the other inputs to change the selected host.","title":"TESMART managed multiport KVM switch"},{"location":"tesmart/#tesmart-managed-multiport-kvm-switch","text":"The TESMART managed switch can be controlled by PiKVM to allow it to connect to multiple hosts. A typical scenario is a single PiKVM device which can control and switch between multiple hosts or servers using the TESMART switch. UI elements can be added to the GPIO dropdown to allow switching between hosts from the PiKVM webpage. The instructions here were tested with the TESMART HKS1601A10 HDMI 16x1 switch . This should work with any of the other TESMART variants which have a LAN port - there is both a 8x1 and 4x1 variant. This was tested with an RPI4, but as this is executed over a network protocol, this should with almost anything.","title":"TESMART managed multiport KVM switch"},{"location":"tesmart/#connections","text":"From a high level, the TESMART switch uses standard connections to the host machines (USB-A to USB-B and HDMI). The Raspberry Pi OTG connector (the one coming from the USB-C port on a Pi 4 via the custom splitter cable or device) should be connected to one of the USB 2 output ports on the TESMART switch (not the keyboard/mouse port). Based on your specific devices, and to get boot images to mount, you may need to connect this through a USB 2 hub. Connect the USB-A cable from the Raspberry Pi OTG port to one of the TESMART switch USB 2 output ports on the back of the switch (not the keyboard/mouse ports). Connect the HDMI out from the TESMART switch to the Raspberry Pi CSI-2 to HMDI input. Connect the LAN port on the front of the switch using standard ethernet cable into one of your network switches. Connect host USB and HDMI cables from the TESMART switch to the machines to be managed per the switch instructions. Warning There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi CSI2-HDMI encoder. These limitations apply equally when using the TESMART KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the TESMART switch before powering the hosts on.","title":"Connections"},{"location":"tesmart/#setting-the-ip-address-of-the-tesmart-switch","text":"In some ways, this is the most complex part of this. The default IP address of the TESMART switch is 192.168.1.10. If that happens to work with your IP addressing scheme and current set of addresses, then you may be all set. This IP address is not configurable via DHCP or other standard mechanisms. The only way to change it is with a Windows utility available on the TESMART Downloads Page . If you need to change it, you will first need to connect to the switch with a Windows machine, most easily directly through an ethernet cord, with your Windows laptop (or VM) up and assigned to a fixed IP address, such as 192.168.1.5. Once you've launched the utility you will see this screen: On this screen, ensure you are on the \"General\" tab. Click the radio button for \"Network control\". Change the IP address to the default for the switch (may already be this -- 192.168.1.10). Press the \"Connect\" button. Should make the status light go green, as well as the selected port. If you do not get a connection here, you cannot proceed to change the IP address. To change the IP address, change to the \"Settings\" tab at the top. You will then see this screen: On this screen, change to your desired IP address, gateway, mask, and port. Then press apply. Watch the box on the right to see if it applied OK. Press Query again to double-check. The actual IP address will not be changed until you power off/power on the switch. Make sure you have these settings correct, because if you get them wrong you would have to connect over RS232/serial and not the network. There may be alternatives other than changing the IP address in this manner if you don't have access to a Windows machine or if this address doesn't work for you. See this README for other options (Images and concepts from the bash file were borrowed for creation of this plugin). This also contains a summary of the protocol, which is also available on the TESMART downloads page.","title":"Setting the IP Address of the TESMART switch"},{"location":"tesmart/#adding-ui-elements-to-control-the-kvm-switch","text":"The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected. The instructions below will make these available in the PiKVM UI after clicking the \"Switches\" menu button in the KVM view. Enable read-write mode on the SD card via rw Edit the /etc/kvmd/override.yaml file and include the following: kvmd : gpio : drivers : tes : type : tesmart host : 10.10.1.10 port : 5000 scheme : server0_led : driver : tes pin : 0 mode : input server0_switch : driver : tes pin : 0 mode : output switch : false server1_led : driver : tes pin : 1 mode : input server1_switch : driver : tes pin : 1 mode : output switch : false server2_led : driver : tes pin : 2 mode : input server2_switch : driver : tes pin : 2 mode : output switch : false server3_led : driver : tes pin : 3 mode : input server3_switch : driver : tes pin : 3 mode : output switch : false view : table : - [ \"TESMART Switch\" ] - [] - [ \"#Server 1\" , server0_led , server0_switch|Switch ] - [ \"#Server 2\" , server1_led , server1_switch|Switch ] - [ \"#Server 3\" , server2_led , server2_switch|Switch ] - [ \"#Server 4\" , server3_led , server3_switch|Switch ] Return to read-only mode for the sd card via ro Restart the kvmd service: systemctl restart kvmd","title":"Adding UI elements to control the KVM switch"},{"location":"tesmart/#switching-between-hosts-in-the-ui","text":"To switch between hosts, enter the KVM UI and click the \"Switches\" menu. You should see your inputs, one of which will have a green circle indicating it is currently selected. Click the other inputs to change the selected host.","title":"Switching between hosts in the UI"},{"location":"usb_ethernet/","text":"Ethernet-over-USB network \u00b6 Basic configuration \u00b6 Specifically to v2+. When combined with configuring a DNS server, FTP, or SMB (for example), this is a powerful way to extend the capabilities of PiKVM. Edit /etc/kvmd/override.yaml and add these lines: otg : devices : ethernet : enabled : true driver : ecm host_mac : 48:6f:73:74:50:43 kvm_mac : 42:61:64:55:53:42 The host_mac address will be used on the server's network interface. The kvm_mac means the address that will be assigned to the local interface on the PiKVM. The KVM interface will be called usb0 network interface. If the host_mac or kvm_mac is not specified, a random value will be used. The driver parameter means the protocol that will be used for the USB network. The default value is ecm so it can be passed it this example. Other possible values are eem , ncm , rndis and rndis5 . Driver compatibility: Driver Operating System ecm Linux eem Linux rndis5 Windows XP to Windows 7 1 Linux > 2.6.13 rndis Windows 7 and later 2 Linux > 2.6.13 ncm Windows 10 and later Linux > 2.6.37 1 : Manual driver installation is required. Download RNDIS 5 Windows 2 : Automatic driver installation since kvmd-3.53 To automatically configure the USB network on the server recommended using the service kvmd-otgnet . It configures the firewall, assigns an address to the local PiKVM interface usb0 and starts DHCP so the managed server can get the IPv4 address. By default, the address 169.254.0.1/28 to interface usb0 will be assigned. One of the other addresses from the network 169.254.0.0./28 will be assigned to the server when it requests it via DHCP. For security reasons, all incoming connections from the server to the PiKVM side are blocked (except for ICMP and UDP port 67 which is used for DHCP). If you want to allow access from the server to the PiKVM interface, then you need to add ports 80 and 443 to the whitelist using /etc/kvmd/override.yaml file like this: otgnet : firewall : allow_tcp : [ 80 , 443 ] To view other available configuration parameters, use the command kvmd -m . To enable the service, use the command systemctl enable kvmd-otgnet . Perform reboot . Routing via PiKVM \u00b6 By default, kvmd-otgnet will configure network connection between PiKVM and the server host only. The server host will not be able to reach other hosts beyond PiKVM. If the full network access is required from the server host through the USB-Ethernet feature (access all hosts PiKVM can access), additional settings are needed in /etc/kvmd/override.yaml . Run echo \"net.ipv4.ip_forward = 1\" > /etc/sysctl.d/99-kvmd-extra.conf . Add network interface to forward requests to (default gateway) by adding a line forward_iface: <interface name> under firewall: . Typically it would be eth0 if the built-in ethernet port is used:: otgnet : firewall : forward_iface : eth0 Add DNS server to provide host name resolution service. For example, adding 8.8.8.8 as DNS server requires addition of dnsmasq dhcp options. This can be done by adding following lines to /etc/kvmd/override.yaml : otgnet : commands : post_start_cmd_append : - \"--dhcp-option=6,8.8.8.8\" Combining above two together:: otgnet : firewall : forward_iface : eth0 commands : post_start_cmd_append : - \"--dhcp-option=6,8.8.8.8\" Don't forget to reboot . ======= An example of what the config would look like if you wanted the target to have inet access (Please edit to suit your needs): otgnet: firewall: allow_tcp: [80, 443] forward_iface: wlan0 commands: post_start_cmd_append: - \"--dhcp-option=6,1.1.1.1,1.0.0.1\" iface: ip_cmd: - /usr/bin/ip net: 10.65.0.0/28 ======= Working with Windows Computers \u00b6 This has been proven to work with Windows: 1. Set the driver type to rndis (see above) 2. Download this driver on the Windows machine and unzip it somewhere: [ https://modclouddownloadprod.blob.core.windows.net/shared/mod-rndis-driver-windows.zip ] 3. Open the devices manager \\ 4. Select Properties of the Composite KVM Device \\ 5. Select the RNDIS Device and click properties \\ 6. Switch to the \"Driver\" Tab and then click \"Update driver\" 7. Click \"Browse my computer for driver software\" \\ 8. Click \"Let me pick from a list of available drivers on my Computer\" \\ 9. From the list of available hardware types, scroll down and select \"Network adapters\", then click next \\ 10. Click \"Have disk\" \\ 11. Click Browse, navigate to the folder where you've stored the driver and select the RNDIS.inf , press Open and then OK \\ 12. Select \"Acer Netchip RNDIS/Ethernet Gadget\" and click Next \\ 13. Dismiss the warning about non-compatible drivers by clicking \"Yes\" \\ 14. You're done - the device should now be recognized. \\ 15. Verify the card is working by pinging your piKVM in a console: ping 169.254.0.1 \\","title":"Ethernet-over-USB"},{"location":"usb_ethernet/#ethernet-over-usb-network","text":"","title":"Ethernet-over-USB network"},{"location":"usb_ethernet/#basic-configuration","text":"Specifically to v2+. When combined with configuring a DNS server, FTP, or SMB (for example), this is a powerful way to extend the capabilities of PiKVM. Edit /etc/kvmd/override.yaml and add these lines: otg : devices : ethernet : enabled : true driver : ecm host_mac : 48:6f:73:74:50:43 kvm_mac : 42:61:64:55:53:42 The host_mac address will be used on the server's network interface. The kvm_mac means the address that will be assigned to the local interface on the PiKVM. The KVM interface will be called usb0 network interface. If the host_mac or kvm_mac is not specified, a random value will be used. The driver parameter means the protocol that will be used for the USB network. The default value is ecm so it can be passed it this example. Other possible values are eem , ncm , rndis and rndis5 . Driver compatibility: Driver Operating System ecm Linux eem Linux rndis5 Windows XP to Windows 7 1 Linux > 2.6.13 rndis Windows 7 and later 2 Linux > 2.6.13 ncm Windows 10 and later Linux > 2.6.37 1 : Manual driver installation is required. Download RNDIS 5 Windows 2 : Automatic driver installation since kvmd-3.53 To automatically configure the USB network on the server recommended using the service kvmd-otgnet . It configures the firewall, assigns an address to the local PiKVM interface usb0 and starts DHCP so the managed server can get the IPv4 address. By default, the address 169.254.0.1/28 to interface usb0 will be assigned. One of the other addresses from the network 169.254.0.0./28 will be assigned to the server when it requests it via DHCP. For security reasons, all incoming connections from the server to the PiKVM side are blocked (except for ICMP and UDP port 67 which is used for DHCP). If you want to allow access from the server to the PiKVM interface, then you need to add ports 80 and 443 to the whitelist using /etc/kvmd/override.yaml file like this: otgnet : firewall : allow_tcp : [ 80 , 443 ] To view other available configuration parameters, use the command kvmd -m . To enable the service, use the command systemctl enable kvmd-otgnet . Perform reboot .","title":"Basic configuration"},{"location":"usb_ethernet/#routing-via-pikvm","text":"By default, kvmd-otgnet will configure network connection between PiKVM and the server host only. The server host will not be able to reach other hosts beyond PiKVM. If the full network access is required from the server host through the USB-Ethernet feature (access all hosts PiKVM can access), additional settings are needed in /etc/kvmd/override.yaml . Run echo \"net.ipv4.ip_forward = 1\" > /etc/sysctl.d/99-kvmd-extra.conf . Add network interface to forward requests to (default gateway) by adding a line forward_iface: <interface name> under firewall: . Typically it would be eth0 if the built-in ethernet port is used:: otgnet : firewall : forward_iface : eth0 Add DNS server to provide host name resolution service. For example, adding 8.8.8.8 as DNS server requires addition of dnsmasq dhcp options. This can be done by adding following lines to /etc/kvmd/override.yaml : otgnet : commands : post_start_cmd_append : - \"--dhcp-option=6,8.8.8.8\" Combining above two together:: otgnet : firewall : forward_iface : eth0 commands : post_start_cmd_append : - \"--dhcp-option=6,8.8.8.8\" Don't forget to reboot . ======= An example of what the config would look like if you wanted the target to have inet access (Please edit to suit your needs): otgnet: firewall: allow_tcp: [80, 443] forward_iface: wlan0 commands: post_start_cmd_append: - \"--dhcp-option=6,1.1.1.1,1.0.0.1\" iface: ip_cmd: - /usr/bin/ip net: 10.65.0.0/28 =======","title":"Routing via PiKVM"},{"location":"usb_ethernet/#working-with-windows-computers","text":"This has been proven to work with Windows: 1. Set the driver type to rndis (see above) 2. Download this driver on the Windows machine and unzip it somewhere: [ https://modclouddownloadprod.blob.core.windows.net/shared/mod-rndis-driver-windows.zip ] 3. Open the devices manager \\ 4. Select Properties of the Composite KVM Device \\ 5. Select the RNDIS Device and click properties \\ 6. Switch to the \"Driver\" Tab and then click \"Update driver\" 7. Click \"Browse my computer for driver software\" \\ 8. Click \"Let me pick from a list of available drivers on my Computer\" \\ 9. From the list of available hardware types, scroll down and select \"Network adapters\", then click next \\ 10. Click \"Have disk\" \\ 11. Click Browse, navigate to the folder where you've stored the driver and select the RNDIS.inf , press Open and then OK \\ 12. Select \"Acer Netchip RNDIS/Ethernet Gadget\" and click Next \\ 13. Dismiss the warning about non-compatible drivers by clicking \"Yes\" \\ 14. You're done - the device should now be recognized. \\ 15. Verify the card is working by pinging your piKVM in a console: ping 169.254.0.1 \\","title":"Working with Windows Computers"},{"location":"usb_serial/","text":"Serial-over-USB connection \u00b6 Specifically to v2+. This can be used for terminal access from the managed server to the PiKVM, or for any other purpose that requires a serial connection. In the last case, you only need to perform step 1 and reboot. Edit /etc/kvmd/override.yaml and add these lines: otg : devices : serial : enabled : true Run the following command: # echo ttyGS0 >> /etc/securetty Create the directory /etc/systemd/system/getty@ttyGS0.service.d and add a file file named override.conf into it. Afterwards edit the file and copy this into it: [Service] TTYReset = no TTYVHangup = no TTYVTDisallocate = no Run these comands: # systemctl enable getty@ttyGS0.service # reboot Once PiKVM is rebooted you will have access to a virtual serial port on the server that the USB is connected to. Use mingetty, screen, putty, or something like this to access the kvm from the server. The port is called /dev/ttyAMA0 .","title":"Serial-over-USB"},{"location":"usb_serial/#serial-over-usb-connection","text":"Specifically to v2+. This can be used for terminal access from the managed server to the PiKVM, or for any other purpose that requires a serial connection. In the last case, you only need to perform step 1 and reboot. Edit /etc/kvmd/override.yaml and add these lines: otg : devices : serial : enabled : true Run the following command: # echo ttyGS0 >> /etc/securetty Create the directory /etc/systemd/system/getty@ttyGS0.service.d and add a file file named override.conf into it. Afterwards edit the file and copy this into it: [Service] TTYReset = no TTYVHangup = no TTYVTDisallocate = no Run these comands: # systemctl enable getty@ttyGS0.service # reboot Once PiKVM is rebooted you will have access to a virtual serial port on the server that the USB is connected to. Use mingetty, screen, putty, or something like this to access the kvm from the server. The port is called /dev/ttyAMA0 .","title":"Serial-over-USB connection"},{"location":"v3/","text":"PiKVM v3 HAT \u00b6 Installation requirements \u00b6 If you have an assembly kit, you will need the following things Raspberry Pi 4 with 1Gb RAM or more. Heat sinks (Optional) MicroSD card (at least 16Gb, class 10 recommended). USB-C to USB-A cable. HDMI cable. Straight Ethernet cable (for the ATX board connection). Power supply unit (5.1V 3A USB-C, recommended by the Raspberry Pi). Before assembling Please review the back of the box. All parts are required before hat is fully functional. The USB-C Bridge is located in with the ATX end which includes a pink foam spacer. Please assemble hat onto the rpi and test all of the parts before installing in the case, it's easier to install in the case than to dissasemble it. If going from a v2 to a v3, the splitter is no longer needed . Basic setup \u00b6 If you have a kit without a metal case, you can use our free 3D printing case drawing: v3.3 for the Kickstarter/Store model, v3.2 for the pre-release. Please use the v3 image, V2 image is not compatible Flash the memory card. Build PiKVM according to the video instruction or review the illustrated instructions : Video Guide: Metal case step by step NOTE: OLED will not light up till step 5 is performed, video was performed after it was already configured, heat sinks NOT included. Video Guide: Step by step with HAT Device with or without the 3D-printed case OLED glass can crack if force is used to install it, please handle with care and rock back and forth on the pins side to install. Connect PiKVM to the computer according to the diagram below: Back side Front side HDMI input and USB emulation port must be connected to the computer. ATX too, but it's optional, read below . There should be no USB hub between PiKVM and the computer, as some UEFI/BIOS cannot detect them at the boot stage. On the HDMI the HAT, like the CSI bridge, supports 1080p50Hz or 720p60Hz or lower. Connect Ethernet to the network and USB Power to the Raspberry Pi power supply. Carefully read the \"First steps\" guide - how to find a device on the network, how to log in there, change passwords, and so on. Follow the steps described there and come back here . If your kit includes the OLED display and/or the fan, you'll need to turn them on (This is only needed for the v3 image) Log in to PiKVM and run these commands: # rw # systemctl enable --now kvmd-oled kvmd-oled-reboot kvmd-oled-shutdown # systemctl enable --now kvmd-fan # ro If you want the temperature to be displayed in Fahreneit on the OLED and you do not want to update the whole system, then you will need to do this first after going to root: # rw # pacman -Syy # pacman -S kvmd-oled # systemctl enable --now kvmd-oled kvmd-oled-reboot kvmd-oled-shutdown # mkdir -p /etc/systemd/system/kvmd-oled.service.d Create file touch or nano /etc/systemd/system/kvmd-oled.service.d/override.conf : [Service] ExecStart = ExecStart = /usr/bin/kvmd-oled --height=32 --clear-on-exit --fahrenheit And run systemctl restart kvmd-oled . In some cases, if you still do not see Fahrenheit being displayed, reboot the pikvm. Just reminding again: CHANGE THE PASSWORDS! :) How to do this was written in the \"First steps\" guide Try to manage the computer using PiKVM with the Web Interface. Make sure that you see the image, and the keyboard and mouse are working. If something doesn't work, check out our FAQ (it's really useful). If nothing helped, you can get support in our Discord chat . Check the HDMI backpowering problem. ONLY applicable under specific circumstances. NOT Getting NO SIGNAL. Try restarting PiKVM using the reboot command executed in the terminal. If PiKVM hangs during boot (you can't get the Web Interface for a long time), then you are faced with this rare problem. Don't worry, it's easy to fix. Turn off the PiKVM, disconnect all cables from it, take a close look at the diagram of its ports and jumpers , and remove jumper #14 (it is to the right of the CSI connector). Then you can connect and power up PiKVM again. Now everything will be fine. IO ports and other things Before using GPIO pins to control a relay, KVM switch, or anything else, be sure to check the HAT pinout . Many ports are busy with internal functions. Before using them for your own use, you must disable them, otherwise you may damage the device. You can also try the experimental audio forwarding . ATX connection \u00b6 To manage the power of your computer, you will need to install an ATX adapter board inside the case and connect it to the motherboard. Connect the rainbow wires as follows to the board. Optionally print the mounting plate for the PCI slot on a 3D-printer. Assemble everything like on pictures below. Secure wires in any convenient way (we used soft ties). Example Find the pins on the motherboard responsible for connecting the buttons and LEDs of the front panel of the case. Usually wires and connectors on the motherboard have designations. If you're not sure, check the documentation on your motherboard. Example Place the ATX board nearby and, focusing on the signatures, connect the male pins to the female pin of the front panel wires, observing the polarity (the polarity is indicated on the ATX board). Example Repeat the procedure with the female pin of the ATX board by connecting them to the motherboard connector. Check the documentation on your motherboard. Example Install the ATX board into the PCI slot of the case and fix it with a screw, or use a different mounting method at your discretion. Example Arrange the wires in a way that is convenient for you and fix them if necessary. Example Connect the ATX board to PiKVM using a straight Ethernet cable . 2 pair/4 wire will NOT work, must be a 4 pair/8 wire. Example IO ports and jumpers \u00b6 See the diagram ATX controller interface (power on/off, reboot control, PWR and HDD ACT LEDs). HDMI reset jumper. Connects GPIO 17 and RESET pin to HDMI capture chip. Currently not used, don't touch it. SPI and GPIO for the custom extension boards. Audio capture jumpers. Connects I2S pins 18, 19, 20 to HDMI capture chip. UART access jumpers. Connects GPIO 14 and 15 to the RJ-45 and USB console ports. Serial console port (default: /dev/ttyAMA0, RS232 input, outputs +6V/-6V, for the Raspberry Pi or server console access). USB-C console port (shared with #6 above, takes priority over RJ45). Power and activity LEDs . On the left of the LEDs the watchdog jumper is located. Don't touch it. USB-C power input . I2C display connector . Alternate +5V power input/output header pins. RTC clock supercapacitor (rechargeable). FAN connector - PWM controlled. CSI-2 interface and HDMI backpowering jumper, see Step 8 of the Basic Setup . Open: diode will stop current from HDMI input (backpower will be fixed), closed: will allow current from HDMI device. Built-in power splitter port. HDMI capture port (max 1080p @ 50Hz) with sound capture support. USB emulation pins for alternative access. USB-C emulation port - this port is doing the emulation of a USB keyboard, mouse, Virtual CD-ROM or USB Flash Drive, USB-Ethernet, USB-Serial port and a lot of other Linux-supported features. 1-Wire & Neo-pixel interface (under, advanced user feature). GPIO pinout Before proceeding, make sure that the mb you are using has normal ATX headers ATX control power led = GPIO 24 - Used for reading the host power state. hdd led = 22 - Same for the HDD activity. power switch = 23 - Used for pressing the power button of the host. reset switch = 27 - Same for the reset button. These pins can't be used for any other purposes even if ATX function is disabled. I2C bus - GPIO 2, 3 - Can be used as I2C ONLY (OLED/RTC). 1-Wire [19] - GPIO 4 - Also available under ATX RJ-45 port (point [19] on the above) as bi-directional buffered open-drain 5V for regular 1-Wire usage. UART - GPIO 14, 15 - Can be used as UART only for the serial console. When jumpers [5] are removed, you can connect to pins 14 and 15 directly using GPIO header. Also you can remove jumper [5] and disable UART console in the /boot/config.txt and /boot/cmdline.txt to use this pins for any purpose. But it's not recommended. Red activity led on the front [8] - GPIO 13 - Can be disabled in /boot/config.txt and available on the Neo-pixel port [19]. PWM fan controller - GPIO 12 . Can be used for custom purposes if the fan disconnected and kvmd-fan service is stopped. I2S HDMI sound - GPIO 18, 19, 20, 21 . Can be used for custom purposes if the tc358743-audio overlay in /boot/config.txt is disabled AND jumpers [4] are removed. USB breaker - GPIO 5 - Can't be used for any other purposes. ATX RJ-45 pinout The pinout of the RJ-45 connector is the same on the AT and ATX adapter. ATX LED wiring example Known issues and limitations \u00b6 The actual frame rate of the image received via HDMI will depend on the network bandwidth, resolution and the load on the Raspberry Pi. This is usually ~20-24 FPS for 1080p over LAN . There may be compatibility issues with some motherboards (such as HP or DELL ) which are the same as those that exist with PiKVM v2. Not everything is perfect, but if you have already used PiKVM v2 - our new v3 will work perfectly and please you. If there is no image from the BIOS, you can fine-tune the HDMI settings, but it is possible that the Mass Storage devices will not be available in the BIOS. Pre-release v3.2 board (NOT Kickstarter/Store edition) doesn't have HDMI backpowering workaround jumper.","title":"PiKVM v3 HAT guide"},{"location":"v3/#pikvm-v3-hat","text":"","title":"PiKVM v3 HAT"},{"location":"v3/#installation-requirements","text":"If you have an assembly kit, you will need the following things Raspberry Pi 4 with 1Gb RAM or more. Heat sinks (Optional) MicroSD card (at least 16Gb, class 10 recommended). USB-C to USB-A cable. HDMI cable. Straight Ethernet cable (for the ATX board connection). Power supply unit (5.1V 3A USB-C, recommended by the Raspberry Pi). Before assembling Please review the back of the box. All parts are required before hat is fully functional. The USB-C Bridge is located in with the ATX end which includes a pink foam spacer. Please assemble hat onto the rpi and test all of the parts before installing in the case, it's easier to install in the case than to dissasemble it. If going from a v2 to a v3, the splitter is no longer needed .","title":"Installation requirements"},{"location":"v3/#basic-setup","text":"If you have a kit without a metal case, you can use our free 3D printing case drawing: v3.3 for the Kickstarter/Store model, v3.2 for the pre-release. Please use the v3 image, V2 image is not compatible Flash the memory card. Build PiKVM according to the video instruction or review the illustrated instructions : Video Guide: Metal case step by step NOTE: OLED will not light up till step 5 is performed, video was performed after it was already configured, heat sinks NOT included. Video Guide: Step by step with HAT Device with or without the 3D-printed case OLED glass can crack if force is used to install it, please handle with care and rock back and forth on the pins side to install. Connect PiKVM to the computer according to the diagram below: Back side Front side HDMI input and USB emulation port must be connected to the computer. ATX too, but it's optional, read below . There should be no USB hub between PiKVM and the computer, as some UEFI/BIOS cannot detect them at the boot stage. On the HDMI the HAT, like the CSI bridge, supports 1080p50Hz or 720p60Hz or lower. Connect Ethernet to the network and USB Power to the Raspberry Pi power supply. Carefully read the \"First steps\" guide - how to find a device on the network, how to log in there, change passwords, and so on. Follow the steps described there and come back here . If your kit includes the OLED display and/or the fan, you'll need to turn them on (This is only needed for the v3 image) Log in to PiKVM and run these commands: # rw # systemctl enable --now kvmd-oled kvmd-oled-reboot kvmd-oled-shutdown # systemctl enable --now kvmd-fan # ro If you want the temperature to be displayed in Fahreneit on the OLED and you do not want to update the whole system, then you will need to do this first after going to root: # rw # pacman -Syy # pacman -S kvmd-oled # systemctl enable --now kvmd-oled kvmd-oled-reboot kvmd-oled-shutdown # mkdir -p /etc/systemd/system/kvmd-oled.service.d Create file touch or nano /etc/systemd/system/kvmd-oled.service.d/override.conf : [Service] ExecStart = ExecStart = /usr/bin/kvmd-oled --height=32 --clear-on-exit --fahrenheit And run systemctl restart kvmd-oled . In some cases, if you still do not see Fahrenheit being displayed, reboot the pikvm. Just reminding again: CHANGE THE PASSWORDS! :) How to do this was written in the \"First steps\" guide Try to manage the computer using PiKVM with the Web Interface. Make sure that you see the image, and the keyboard and mouse are working. If something doesn't work, check out our FAQ (it's really useful). If nothing helped, you can get support in our Discord chat . Check the HDMI backpowering problem. ONLY applicable under specific circumstances. NOT Getting NO SIGNAL. Try restarting PiKVM using the reboot command executed in the terminal. If PiKVM hangs during boot (you can't get the Web Interface for a long time), then you are faced with this rare problem. Don't worry, it's easy to fix. Turn off the PiKVM, disconnect all cables from it, take a close look at the diagram of its ports and jumpers , and remove jumper #14 (it is to the right of the CSI connector). Then you can connect and power up PiKVM again. Now everything will be fine. IO ports and other things Before using GPIO pins to control a relay, KVM switch, or anything else, be sure to check the HAT pinout . Many ports are busy with internal functions. Before using them for your own use, you must disable them, otherwise you may damage the device. You can also try the experimental audio forwarding .","title":"Basic setup"},{"location":"v3/#atx-connection","text":"To manage the power of your computer, you will need to install an ATX adapter board inside the case and connect it to the motherboard. Connect the rainbow wires as follows to the board. Optionally print the mounting plate for the PCI slot on a 3D-printer. Assemble everything like on pictures below. Secure wires in any convenient way (we used soft ties). Example Find the pins on the motherboard responsible for connecting the buttons and LEDs of the front panel of the case. Usually wires and connectors on the motherboard have designations. If you're not sure, check the documentation on your motherboard. Example Place the ATX board nearby and, focusing on the signatures, connect the male pins to the female pin of the front panel wires, observing the polarity (the polarity is indicated on the ATX board). Example Repeat the procedure with the female pin of the ATX board by connecting them to the motherboard connector. Check the documentation on your motherboard. Example Install the ATX board into the PCI slot of the case and fix it with a screw, or use a different mounting method at your discretion. Example Arrange the wires in a way that is convenient for you and fix them if necessary. Example Connect the ATX board to PiKVM using a straight Ethernet cable . 2 pair/4 wire will NOT work, must be a 4 pair/8 wire. Example","title":"ATX connection"},{"location":"v3/#io-ports-and-jumpers","text":"See the diagram ATX controller interface (power on/off, reboot control, PWR and HDD ACT LEDs). HDMI reset jumper. Connects GPIO 17 and RESET pin to HDMI capture chip. Currently not used, don't touch it. SPI and GPIO for the custom extension boards. Audio capture jumpers. Connects I2S pins 18, 19, 20 to HDMI capture chip. UART access jumpers. Connects GPIO 14 and 15 to the RJ-45 and USB console ports. Serial console port (default: /dev/ttyAMA0, RS232 input, outputs +6V/-6V, for the Raspberry Pi or server console access). USB-C console port (shared with #6 above, takes priority over RJ45). Power and activity LEDs . On the left of the LEDs the watchdog jumper is located. Don't touch it. USB-C power input . I2C display connector . Alternate +5V power input/output header pins. RTC clock supercapacitor (rechargeable). FAN connector - PWM controlled. CSI-2 interface and HDMI backpowering jumper, see Step 8 of the Basic Setup . Open: diode will stop current from HDMI input (backpower will be fixed), closed: will allow current from HDMI device. Built-in power splitter port. HDMI capture port (max 1080p @ 50Hz) with sound capture support. USB emulation pins for alternative access. USB-C emulation port - this port is doing the emulation of a USB keyboard, mouse, Virtual CD-ROM or USB Flash Drive, USB-Ethernet, USB-Serial port and a lot of other Linux-supported features. 1-Wire & Neo-pixel interface (under, advanced user feature). GPIO pinout Before proceeding, make sure that the mb you are using has normal ATX headers ATX control power led = GPIO 24 - Used for reading the host power state. hdd led = 22 - Same for the HDD activity. power switch = 23 - Used for pressing the power button of the host. reset switch = 27 - Same for the reset button. These pins can't be used for any other purposes even if ATX function is disabled. I2C bus - GPIO 2, 3 - Can be used as I2C ONLY (OLED/RTC). 1-Wire [19] - GPIO 4 - Also available under ATX RJ-45 port (point [19] on the above) as bi-directional buffered open-drain 5V for regular 1-Wire usage. UART - GPIO 14, 15 - Can be used as UART only for the serial console. When jumpers [5] are removed, you can connect to pins 14 and 15 directly using GPIO header. Also you can remove jumper [5] and disable UART console in the /boot/config.txt and /boot/cmdline.txt to use this pins for any purpose. But it's not recommended. Red activity led on the front [8] - GPIO 13 - Can be disabled in /boot/config.txt and available on the Neo-pixel port [19]. PWM fan controller - GPIO 12 . Can be used for custom purposes if the fan disconnected and kvmd-fan service is stopped. I2S HDMI sound - GPIO 18, 19, 20, 21 . Can be used for custom purposes if the tc358743-audio overlay in /boot/config.txt is disabled AND jumpers [4] are removed. USB breaker - GPIO 5 - Can't be used for any other purposes. ATX RJ-45 pinout The pinout of the RJ-45 connector is the same on the AT and ATX adapter. ATX LED wiring example","title":"IO ports and jumpers"},{"location":"v3/#known-issues-and-limitations","text":"The actual frame rate of the image received via HDMI will depend on the network bandwidth, resolution and the load on the Raspberry Pi. This is usually ~20-24 FPS for 1080p over LAN . There may be compatibility issues with some motherboards (such as HP or DELL ) which are the same as those that exist with PiKVM v2. Not everything is perfect, but if you have already used PiKVM v2 - our new v3 will work perfectly and please you. If there is no image from the BIOS, you can fine-tune the HDMI settings, but it is possible that the Mass Storage devices will not be available in the BIOS. Pre-release v3.2 board (NOT Kickstarter/Store edition) doesn't have HDMI backpowering workaround jumper.","title":"Known issues and limitations"},{"location":"v3_illustrated_install_instructions/","text":"Step 1 \u00b6 Remove contents from box. Contents: \u00b6 8x M.2 screws for the case 4x screws for the fan 4x bolts for the fan 1x fan 1x case top 1x case bottom 1x OLED display 2x bottom plastic risers 1x plastic top riser 1x plastic OLED holder that is also a front riser 2x small FCC ribbon cables 1x small rubber square that break out to 4x small rubber feet OLED is sensitive to pressure, do NOT push down on the very thin glass as it will crack thereby making the OLED non-functional Step 2 \u00b6 Take bottom part of the case, insert the RPI4 into the bottom case at an angle, you will need to flex the other side ever so slightly to get it to slot in. IF you bought heatsink's (sold seperatly), it's advised to install them now before installing the HAT Step 3 \u00b6 Insert HAT at the same angle, take care to line up the pins on the Rpi with the HAT pin sleeve, the trick to this is to push the Rpi all of the way to the left then all of the way to the right for proper alignment, do NOT force till the pins are aligned. If properly aligned the pins will match up without issue. ALTERNATIVE: As an alternative to the above, you can pre assemble the hat+fcc cable onto the RPI4, then insert them into the bottom portion of the case however you will need to flex the sides more whereby creating a bigger gap when fully assembled. Step 4 \u00b6 There are 2 ways to insert the FCC cable, you can add it when you insert the RPI in Step 2 OR wait till you also have the HAT installed and slide it into the slot. The blue stripes on the ends of the cable will ALWAYS face the side that will be used to tighten the FCC to the camera port or have it positioned towards the power Step 5 \u00b6 Install USB-C bridge. If you do not install this bridge, mouse/kb will not work HAT will still power on without this bridge installed Step 6 \u00b6 Turn the bottom of the case upside down, install the 2 bottom plastic risers, it's best to install in a wing formation. Top first by inserting the top screws then slide the bottom part aligning the plastic to the holes then inserting the screws. At this point its OK to tighten the bottom screws. There is no need to use force, just tighten enough to prohibit movement. Step 7 \u00b6 Take the plastic OLED holder, turn the OLED over where the back side is facing you and insert at an angle so as to create a space between the OLED and holder arm, take a flat head screwdriver (medium normal) and twist it enough so you can clear the electronics on the bottom of the OLED and continue to gently slide in the remaining OLED till its fully inserted. Be careful on handling this display, slight pressure will damage the OLED, however in the event that this does happen, replacements are cheap and can be found in most electronic stores or Amazon, look for any IIC (I2C) .91 inch display for Arduino Step 8 \u00b6 Insert the OLED holder with the OLED display into the plug by gently rocking it back and forth till it's fully inserted. Step 8a \u00b6 Install plastic spacer. Step 9 \u00b6 Install the screws and bolts to secure the fan, it does not matter the orientation of the fan, push or pulling air will result in the same behavior, its personal preference. Step 10 \u00b6 Insert the fan leads and align Red with positive and Black with negative. You can damage the fan if installed incorrectly Step 11 \u00b6 Install the top of the case to the bottom, use the 4 remaining screws to secure the top. Step 12 \u00b6 Please follow the V3 guide and First Steps guide to activate your PiKVM.","title":"Step 1"},{"location":"v3_illustrated_install_instructions/#step-1","text":"Remove contents from box.","title":"Step 1"},{"location":"v3_illustrated_install_instructions/#contents","text":"8x M.2 screws for the case 4x screws for the fan 4x bolts for the fan 1x fan 1x case top 1x case bottom 1x OLED display 2x bottom plastic risers 1x plastic top riser 1x plastic OLED holder that is also a front riser 2x small FCC ribbon cables 1x small rubber square that break out to 4x small rubber feet OLED is sensitive to pressure, do NOT push down on the very thin glass as it will crack thereby making the OLED non-functional","title":"Contents:"},{"location":"v3_illustrated_install_instructions/#step-2","text":"Take bottom part of the case, insert the RPI4 into the bottom case at an angle, you will need to flex the other side ever so slightly to get it to slot in. IF you bought heatsink's (sold seperatly), it's advised to install them now before installing the HAT","title":"Step 2"},{"location":"v3_illustrated_install_instructions/#step-3","text":"Insert HAT at the same angle, take care to line up the pins on the Rpi with the HAT pin sleeve, the trick to this is to push the Rpi all of the way to the left then all of the way to the right for proper alignment, do NOT force till the pins are aligned. If properly aligned the pins will match up without issue. ALTERNATIVE: As an alternative to the above, you can pre assemble the hat+fcc cable onto the RPI4, then insert them into the bottom portion of the case however you will need to flex the sides more whereby creating a bigger gap when fully assembled.","title":"Step 3"},{"location":"v3_illustrated_install_instructions/#step-4","text":"There are 2 ways to insert the FCC cable, you can add it when you insert the RPI in Step 2 OR wait till you also have the HAT installed and slide it into the slot. The blue stripes on the ends of the cable will ALWAYS face the side that will be used to tighten the FCC to the camera port or have it positioned towards the power","title":"Step 4"},{"location":"v3_illustrated_install_instructions/#step-5","text":"Install USB-C bridge. If you do not install this bridge, mouse/kb will not work HAT will still power on without this bridge installed","title":"Step 5"},{"location":"v3_illustrated_install_instructions/#step-6","text":"Turn the bottom of the case upside down, install the 2 bottom plastic risers, it's best to install in a wing formation. Top first by inserting the top screws then slide the bottom part aligning the plastic to the holes then inserting the screws. At this point its OK to tighten the bottom screws. There is no need to use force, just tighten enough to prohibit movement.","title":"Step 6"},{"location":"v3_illustrated_install_instructions/#step-7","text":"Take the plastic OLED holder, turn the OLED over where the back side is facing you and insert at an angle so as to create a space between the OLED and holder arm, take a flat head screwdriver (medium normal) and twist it enough so you can clear the electronics on the bottom of the OLED and continue to gently slide in the remaining OLED till its fully inserted. Be careful on handling this display, slight pressure will damage the OLED, however in the event that this does happen, replacements are cheap and can be found in most electronic stores or Amazon, look for any IIC (I2C) .91 inch display for Arduino","title":"Step 7"},{"location":"v3_illustrated_install_instructions/#step-8","text":"Insert the OLED holder with the OLED display into the plug by gently rocking it back and forth till it's fully inserted.","title":"Step 8"},{"location":"v3_illustrated_install_instructions/#step-8a","text":"Install plastic spacer.","title":"Step 8a"},{"location":"v3_illustrated_install_instructions/#step-9","text":"Install the screws and bolts to secure the fan, it does not matter the orientation of the fan, push or pulling air will result in the same behavior, its personal preference.","title":"Step 9"},{"location":"v3_illustrated_install_instructions/#step-10","text":"Insert the fan leads and align Red with positive and Black with negative. You can damage the fan if installed incorrectly","title":"Step 10"},{"location":"v3_illustrated_install_instructions/#step-11","text":"Install the top of the case to the bottom, use the 4 remaining screws to secure the top.","title":"Step 11"},{"location":"v3_illustrated_install_instructions/#step-12","text":"Please follow the V3 guide and First Steps guide to activate your PiKVM.","title":"Step 12"},{"location":"video/","text":"Working with video \u00b6 Video recording \u00b6 Info H.264 is available on Pi 3 and Pi 4. Older boards won't handle it. Best of all this feature only works for HDMI to CSI bridge. For the USB HDMI dongle, there will be a decrease in FPS to 10-15 for 1080p. Work in progress. Perform full system update to get the latest uStreamer and install ffmpeg: # rw # pacman -Syu # pacman -S ffmpeg For USB dongle only: Add line gpu_mem=256 to /boot/config.txt . Perform reboot command. Run rw after the reboot. To record a video, you need to enable the stream (open the web interface or connect via VNC). Then run something like this in the console: # rw # ustreamer-dump --sink kvmd::ustreamer::h264 --output - | ffmpeg -use_wallclock_as_timestamps 1 -i pipe: -c:v copy test.mp4 Press Ctrl+C to stop recording. Your video will be in the file test.mp4 . After finishing work, do not forget to switch the file system to read-only mode using ro command. Take a screenshot via console on PiKVM \u00b6 Note You must have a stream running # curl --unix-socket /run/kvmd/ustreamer.sock http://localhost/snapshot -o /tmp/screen.jpg","title":"Working with video"},{"location":"video/#working-with-video","text":"","title":"Working with video"},{"location":"video/#video-recording","text":"Info H.264 is available on Pi 3 and Pi 4. Older boards won't handle it. Best of all this feature only works for HDMI to CSI bridge. For the USB HDMI dongle, there will be a decrease in FPS to 10-15 for 1080p. Work in progress. Perform full system update to get the latest uStreamer and install ffmpeg: # rw # pacman -Syu # pacman -S ffmpeg For USB dongle only: Add line gpu_mem=256 to /boot/config.txt . Perform reboot command. Run rw after the reboot. To record a video, you need to enable the stream (open the web interface or connect via VNC). Then run something like this in the console: # rw # ustreamer-dump --sink kvmd::ustreamer::h264 --output - | ffmpeg -use_wallclock_as_timestamps 1 -i pipe: -c:v copy test.mp4 Press Ctrl+C to stop recording. Your video will be in the file test.mp4 . After finishing work, do not forget to switch the file system to read-only mode using ro command.","title":"Video recording"},{"location":"video/#take-a-screenshot-via-console-on-pikvm","text":"Note You must have a stream running # curl --unix-socket /run/kvmd/ustreamer.sock http://localhost/snapshot -o /tmp/screen.jpg","title":"Take a screenshot via console on PiKVM"},{"location":"vnc/","text":"VNC \u00b6 As an alternative to the web interface, you can use VNC with various desktop clients. The main advantage of VNC over the browser is the ability to expand the image to the full screen, as well as complete interception of all keyboard keys. In some cases, VNC will be more responsive than the browser, especially on weak computers. Warning Don't use VNC without X.509 or TLS encryption on untrusted networks! Otherwise your password will be transmitted over the network in plain text. Unfortunately, this is the reality of the VNC protocol. Note VNC and its varients/TeamViewer/RDP to a system uses the target systems framebuffer IE local display, VNC usage for PiKVM accesses the stream, there will still be a 100-200MS latency and cannot be compared with the other software solutions. NORMAL USAGE: VNC/TM/RDP -> Target system PiKVM USAGE: VNC -> PiKVM -> Target system Enabling VNC on the PiKVM side \u00b6 Switch PiKVM filesystem to read-write mode using command rw . Optional: Change client's keyboard layout if you're using an non-US keyboard. To do this edit file /etc/kvmd/override.yaml : vnc : keymap : /usr/share/kvmd/keymaps/ru All available keymaps are located in /usr/share/kvmd/keymaps : Optional: This step is not nessessory if using TigerVNC. Some VNC clients (for example TightVNC) can't use user/password authentication. In this case you can enable passphrases mode in /etc/kvmd/override.yaml : vnc : auth : vncauth : enabled : true To set passphrases edit file /etc/kvmd/vncpasswd . Enable kvmd-vnc daemon. VNC will be available on the port 5900: systemctl enable --now kvmd-vnc . Switch filesystem back to read-only: ro . Configuring the client \u00b6 We recommend TigerVNC for a better experience on desktop. Here are our recommended settings for TigerVNC: Compression tab: Choose Tight encoding as preferred and color-level Full . Disable automatic quality adjust settings Auto Select . Enable Allow JPEG compression . Security tab: Enable None , X.509 TLS and Anonymous TLS encryption (or choose one preferred mode). Enable Username and password authentication. For iOS and Android the recommended application is bVNC: Google Play App Store Unsupported clients \u00b6 RealVNC - Does not support most widely used open VNC protocol extensions. Guacamole - Incorrectly implements vencrypt, no JPEG compression. Vinagre - Incorrectly implements vencrypt.","title":"Using VNC"},{"location":"vnc/#vnc","text":"As an alternative to the web interface, you can use VNC with various desktop clients. The main advantage of VNC over the browser is the ability to expand the image to the full screen, as well as complete interception of all keyboard keys. In some cases, VNC will be more responsive than the browser, especially on weak computers. Warning Don't use VNC without X.509 or TLS encryption on untrusted networks! Otherwise your password will be transmitted over the network in plain text. Unfortunately, this is the reality of the VNC protocol. Note VNC and its varients/TeamViewer/RDP to a system uses the target systems framebuffer IE local display, VNC usage for PiKVM accesses the stream, there will still be a 100-200MS latency and cannot be compared with the other software solutions. NORMAL USAGE: VNC/TM/RDP -> Target system PiKVM USAGE: VNC -> PiKVM -> Target system","title":"VNC"},{"location":"vnc/#enabling-vnc-on-the-pikvm-side","text":"Switch PiKVM filesystem to read-write mode using command rw . Optional: Change client's keyboard layout if you're using an non-US keyboard. To do this edit file /etc/kvmd/override.yaml : vnc : keymap : /usr/share/kvmd/keymaps/ru All available keymaps are located in /usr/share/kvmd/keymaps : Optional: This step is not nessessory if using TigerVNC. Some VNC clients (for example TightVNC) can't use user/password authentication. In this case you can enable passphrases mode in /etc/kvmd/override.yaml : vnc : auth : vncauth : enabled : true To set passphrases edit file /etc/kvmd/vncpasswd . Enable kvmd-vnc daemon. VNC will be available on the port 5900: systemctl enable --now kvmd-vnc . Switch filesystem back to read-only: ro .","title":"Enabling VNC on the PiKVM side"},{"location":"vnc/#configuring-the-client","text":"We recommend TigerVNC for a better experience on desktop. Here are our recommended settings for TigerVNC: Compression tab: Choose Tight encoding as preferred and color-level Full . Disable automatic quality adjust settings Auto Select . Enable Allow JPEG compression . Security tab: Enable None , X.509 TLS and Anonymous TLS encryption (or choose one preferred mode). Enable Username and password authentication. For iOS and Android the recommended application is bVNC: Google Play App Store","title":"Configuring the client"},{"location":"vnc/#unsupported-clients","text":"RealVNC - Does not support most widely used open VNC protocol extensions. Guacamole - Incorrectly implements vencrypt, no JPEG compression. Vinagre - Incorrectly implements vencrypt.","title":"Unsupported clients"},{"location":"webrtc/","text":"H.264 / WebRTC \u00b6 Only main browsers are supported: Chrome, Firefox and Safari This is a new alternative video transfer mode available for Raspberry Pi 4 users with an HDMI-CSI bridge (including PiKVM v3 HAT). It uses H.264 encoding instead of MJPEG and provides significantly less traffic consumption. If you use an OS image built after 2021.06.10, this mode will be available by default. If you are upgrading to an older version of the OS, you will need to manually enable the WebRTC gateway: # systemctl enable --now kvmd-janus Then reload the Web UI and then in the System menu you will see the video mode switch. Note If you don't see the switch, it means that either your browser does not support WebRTC, or the kvmd-janus service was not started. Basics \u00b6 The MJPEG video stream uses the same HTTP connection that you use to get the web interface. This means that for remote access, you just need to forward ports 80 and 443 on your router. In contrast, WebRTC is a completely different way of transmitting video. It uses a P2P connection and UDP. This reduces network load, but makes it difficult to configure - the server needs to know your network configuration in order to use it correctly. To implement this, the PiKVM checks which of the network interfaces is used for the default gateway, and also tries to find out your external address using the Google STUN server. This is necessary when using Tailscale or so that you can connect to your PiKVM from the external Internet, since simply forwarding ports 80 and 443 for WebRTC is not enough - it requires a direct connection. If you don't like using Google (it was chosen as the default for reliability reasons) for this purpose, you can choose any other STUN server at your discretion, or set up your own. Edit /etc/kvmd/override.yaml : janus : stun : host : stun.stunprotocol.org port : 3478 ... and restart kvmd-janus service using systemctl restart kvmd-janus . Custom Janus config \u00b6 Janus is a WebRTC gateway that is used to transmit the uStreamer video. KVMD-Janus is a wrapper around it, configuring and monitoring changes in the network configuration. This is suitable for most users. However, if your PiKVM is not connected to the Internet and/or you want to use a custom Janus configuration, then you should use the kvmd-janus-static service instead. You should first change the Janus configuration yourself. You can find it in /etc/kvmd/janus/janus.jcfg . # systemctl disable --now kvmd-janus ... # systemctl enable --now kvmd-janus-static Troubleshooting \u00b6 In rare cases, WebRTC may not work. The most common reasons are: Tricky IPv6 configuration on the network. IPv6 support for WebRTC in PiKVM is still in its infancy, so if your network has IPv4, it will be easiest to disable IPv6 on PiKVM. To do this, switch the file system to write mode using rw command, add option ipv6.disable_ipv6=1 to /boot/cmdline.txt and perform reboot . Also see here . A paranoid firewall when you try to connect to the PiKVM by forwarding port 443 to the Internet from the internal network. WebRTC is not enough of this, it uses UDP on ports 10000-20000 for a P2P connection. Make sure that the Firewall does not block them. If nothing helps, open the browser's JS console and look at the log, and contact our community via Discord . Developers and/or experienced users will definitely help you. Another option to try is if you have both wifi and eth connected, disable wifi rfkill list wifi then rfkill block X where is a number that shows in the output. Reason: Arch Linux will choose to route all outgoing packets out wifi by default. There are some linux distro's that require more work to be able to use H.264 (WEBRTC MODE), this may include any RedHat variant. For instance: On Fedora you can install the rpmfusion repos, then use the chromium-freeworld package instead of chromium","title":"H.264 / WebRTC"},{"location":"webrtc/#h264-webrtc","text":"Only main browsers are supported: Chrome, Firefox and Safari This is a new alternative video transfer mode available for Raspberry Pi 4 users with an HDMI-CSI bridge (including PiKVM v3 HAT). It uses H.264 encoding instead of MJPEG and provides significantly less traffic consumption. If you use an OS image built after 2021.06.10, this mode will be available by default. If you are upgrading to an older version of the OS, you will need to manually enable the WebRTC gateway: # systemctl enable --now kvmd-janus Then reload the Web UI and then in the System menu you will see the video mode switch. Note If you don't see the switch, it means that either your browser does not support WebRTC, or the kvmd-janus service was not started.","title":"H.264 / WebRTC"},{"location":"webrtc/#basics","text":"The MJPEG video stream uses the same HTTP connection that you use to get the web interface. This means that for remote access, you just need to forward ports 80 and 443 on your router. In contrast, WebRTC is a completely different way of transmitting video. It uses a P2P connection and UDP. This reduces network load, but makes it difficult to configure - the server needs to know your network configuration in order to use it correctly. To implement this, the PiKVM checks which of the network interfaces is used for the default gateway, and also tries to find out your external address using the Google STUN server. This is necessary when using Tailscale or so that you can connect to your PiKVM from the external Internet, since simply forwarding ports 80 and 443 for WebRTC is not enough - it requires a direct connection. If you don't like using Google (it was chosen as the default for reliability reasons) for this purpose, you can choose any other STUN server at your discretion, or set up your own. Edit /etc/kvmd/override.yaml : janus : stun : host : stun.stunprotocol.org port : 3478 ... and restart kvmd-janus service using systemctl restart kvmd-janus .","title":"Basics"},{"location":"webrtc/#custom-janus-config","text":"Janus is a WebRTC gateway that is used to transmit the uStreamer video. KVMD-Janus is a wrapper around it, configuring and monitoring changes in the network configuration. This is suitable for most users. However, if your PiKVM is not connected to the Internet and/or you want to use a custom Janus configuration, then you should use the kvmd-janus-static service instead. You should first change the Janus configuration yourself. You can find it in /etc/kvmd/janus/janus.jcfg . # systemctl disable --now kvmd-janus ... # systemctl enable --now kvmd-janus-static","title":"Custom Janus config"},{"location":"webrtc/#troubleshooting","text":"In rare cases, WebRTC may not work. The most common reasons are: Tricky IPv6 configuration on the network. IPv6 support for WebRTC in PiKVM is still in its infancy, so if your network has IPv4, it will be easiest to disable IPv6 on PiKVM. To do this, switch the file system to write mode using rw command, add option ipv6.disable_ipv6=1 to /boot/cmdline.txt and perform reboot . Also see here . A paranoid firewall when you try to connect to the PiKVM by forwarding port 443 to the Internet from the internal network. WebRTC is not enough of this, it uses UDP on ports 10000-20000 for a P2P connection. Make sure that the Firewall does not block them. If nothing helps, open the browser's JS console and look at the log, and contact our community via Discord . Developers and/or experienced users will definitely help you. Another option to try is if you have both wifi and eth connected, disable wifi rfkill list wifi then rfkill block X where is a number that shows in the output. Reason: Arch Linux will choose to route all outgoing packets out wifi by default. There are some linux distro's that require more work to be able to use H.264 (WEBRTC MODE), this may include any RedHat variant. For instance: On Fedora you can install the rpmfusion repos, then use the chromium-freeworld package instead of chromium","title":"Troubleshooting"},{"location":"wifi/","text":"Setting up Wi-Fi \u00b6 The following describes how to setup a Wi-Fi connection on the default pikvm builds based on Arch Linux. The process might vary for other Linux distros. We recommend to do this while having a display and keyboard connected directly to the Raspberry Pi as you will loose network connectivity once you connect to a Wi-Fi. Alternatively you can connect to the PiKVM via SSH. The built-in Web Terminal (available through the browser) should also work. Warning Please review First Steps if you are setting up wifi for zerow/z2w. Warning There is nothing more reliable than wired Ethernet, so it's better to use it. But who are we to stop you... :) Moving Wi-Fi settings for OS older than 2021.10.19 Starting from 2021.10.19, the old way to configure Wi-Fi using netctl is deprecated. Instead, it is proposed to use a more native path with systemd-networkd , which is already used to configure Ethernet. Follow the guide and then delete the old netctl profile: # rw # systemctl disable netctl-auto@wlan0.service # rm /etc/netctl/wlan0-* # ro Step by step \u00b6 Make filesystem writable using rw command. Create Wi-Fi settings file /etc/systemd/network/wlan0.network with following content: [Match] Name = wlan0 [Network] DHCP = yes DNSSEC = no # Use same IP by forcing to use MAC address for clientID [DHCP] ClientIdentifier = mac Set network ESSID and password: # wpa_passphrase MyNetwork 'P@assw0rd' > /etc/wpa_supplicant/wpa_supplicant-wlan0.conf Using Wi-Fi with hidden ESSID Add option scan_ssid=1 to /etc/wpa_supplicant/wpa_supplicant-wlan0.conf Using 5GHz Wi-Fi in the USA Add option country=US to /etc/wpa_supplicant/wpa_supplicant-wlan0.conf Enable WPA-supplicant service: systemctl enable wpa_supplicant@wlan0.service Make filesystem read-only again using ro command Useful console commands \u00b6 iwconfig - Manipulate the basic wireless parameters. iwlist - Allow's you to initiate scanning and list frequencies, bit-rates, encryption keys, etc. iwspy - Displays per node link quality. iwpriv - Allow's you to manipulate the Wireless Extensions specific to a driver (private). Some examples # iw dev wlan0 scan | egrep \"signal:|SSID:\" | sed -e \"s/\\tsignal: //\" -e \"s/\\tSSID: //\" | awk '{ORS = (NR % 2 == 0)? \"\\n\" : \" \"; print}' | sort # iwlist wlan0 scan | egrep \"Cell|ESSID|Signal|Rates\" # iwlist wlan0 scan # iw wlan0 info Additional resources \u00b6 Arch Linux Wiki for systemd-networkd","title":"Setting up Wi-Fi"},{"location":"wifi/#setting-up-wi-fi","text":"The following describes how to setup a Wi-Fi connection on the default pikvm builds based on Arch Linux. The process might vary for other Linux distros. We recommend to do this while having a display and keyboard connected directly to the Raspberry Pi as you will loose network connectivity once you connect to a Wi-Fi. Alternatively you can connect to the PiKVM via SSH. The built-in Web Terminal (available through the browser) should also work. Warning Please review First Steps if you are setting up wifi for zerow/z2w. Warning There is nothing more reliable than wired Ethernet, so it's better to use it. But who are we to stop you... :) Moving Wi-Fi settings for OS older than 2021.10.19 Starting from 2021.10.19, the old way to configure Wi-Fi using netctl is deprecated. Instead, it is proposed to use a more native path with systemd-networkd , which is already used to configure Ethernet. Follow the guide and then delete the old netctl profile: # rw # systemctl disable netctl-auto@wlan0.service # rm /etc/netctl/wlan0-* # ro","title":"Setting up Wi-Fi"},{"location":"wifi/#step-by-step","text":"Make filesystem writable using rw command. Create Wi-Fi settings file /etc/systemd/network/wlan0.network with following content: [Match] Name = wlan0 [Network] DHCP = yes DNSSEC = no # Use same IP by forcing to use MAC address for clientID [DHCP] ClientIdentifier = mac Set network ESSID and password: # wpa_passphrase MyNetwork 'P@assw0rd' > /etc/wpa_supplicant/wpa_supplicant-wlan0.conf Using Wi-Fi with hidden ESSID Add option scan_ssid=1 to /etc/wpa_supplicant/wpa_supplicant-wlan0.conf Using 5GHz Wi-Fi in the USA Add option country=US to /etc/wpa_supplicant/wpa_supplicant-wlan0.conf Enable WPA-supplicant service: systemctl enable wpa_supplicant@wlan0.service Make filesystem read-only again using ro command","title":"Step by step"},{"location":"wifi/#useful-console-commands","text":"iwconfig - Manipulate the basic wireless parameters. iwlist - Allow's you to initiate scanning and list frequencies, bit-rates, encryption keys, etc. iwspy - Displays per node link quality. iwpriv - Allow's you to manipulate the Wireless Extensions specific to a driver (private). Some examples # iw dev wlan0 scan | egrep \"signal:|SSID:\" | sed -e \"s/\\tsignal: //\" -e \"s/\\tSSID: //\" | awk '{ORS = (NR % 2 == 0)? \"\\n\" : \" \"; print}' | sort # iwlist wlan0 scan | egrep \"Cell|ESSID|Signal|Rates\" # iwlist wlan0 scan # iw wlan0 info","title":"Useful console commands"},{"location":"wifi/#additional-resources","text":"Arch Linux Wiki for systemd-networkd","title":"Additional resources"},{"location":"wiring_examples/","text":"Some example wiring setups \u00b6 CSI (Geekworm) (Any brand will be the same) \u00b6 List of items: (WARNING! Links may dissappear or no longer work, this just gives you an idea) USB-A male to USB-A male (For data) PortaPow USB Power Blocker USB C OTG Splitter Normal HDMI Cable DisplayPort TO HDMI pigtail (Cable) (Pic is displayed wrong) TARGET (Anything you want to control) Another CSI example using the PCB splitter \u00b6 USB \u00b6 Direct connect to target \u00b6 Explanation of pic - USB-C from PI to USB-A onto target which also powers the PI Use case: - Trying to determine if the data cable is truly a data cable and not just a power cable - Testing to see if the splitter or cable is defective - Basic troubleshooting EZCOO wiring example \u00b6","title":"Wiring examples"},{"location":"wiring_examples/#some-example-wiring-setups","text":"","title":"Some example wiring setups"},{"location":"wiring_examples/#csi-geekworm-any-brand-will-be-the-same","text":"List of items: (WARNING! Links may dissappear or no longer work, this just gives you an idea) USB-A male to USB-A male (For data) PortaPow USB Power Blocker USB C OTG Splitter Normal HDMI Cable DisplayPort TO HDMI pigtail (Cable) (Pic is displayed wrong) TARGET (Anything you want to control)","title":"CSI (Geekworm) (Any brand will be the same)"},{"location":"wiring_examples/#another-csi-example-using-the-pcb-splitter","text":"","title":"Another CSI example using the PCB splitter"},{"location":"wiring_examples/#usb","text":"","title":"USB"},{"location":"wiring_examples/#direct-connect-to-target","text":"Explanation of pic - USB-C from PI to USB-A onto target which also powers the PI Use case: - Trying to determine if the data cable is truly a data cable and not just a power cable - Testing to see if the splitter or cable is defective - Basic troubleshooting","title":"Direct connect to target"},{"location":"wiring_examples/#ezcoo-wiring-example","text":"","title":"EZCOO wiring example"},{"location":"wol/","text":"Wake-on-LAN \u00b6 Simplified method (one host) \u00b6 To use Wake-on-LAN with your server you must define some options such as the server's MAC address and (optionally) IP address. Use /etc/kvmd/override.yaml . The format is: kvmd : wol : mac : ff:ff:ff:ff:ff:ff Replace ff:ff:ff:ff:ff:ff with the MAC of your server. By default, a packet is sent via a broadcast request to the entire IPv4 network ( 255.255.255.255 , port 9 ), but you can address it to a specific static address: kvmd : wol : mac : ff:ff:ff:ff:ff:ff ip : 192.168.0.100 # port: 9 # By default ... then restart kvmd using systemctl restart kvmd . It will now show up in the system button in the upper right corner. GPIO method (multiple hosts) \u00b6 Follow the manual for building the GPIO menu and use the wol driver to build a menu with many buttons tied to different hosts.","title":"Wake-on-LAN the server"},{"location":"wol/#wake-on-lan","text":"","title":"Wake-on-LAN"},{"location":"wol/#simplified-method-one-host","text":"To use Wake-on-LAN with your server you must define some options such as the server's MAC address and (optionally) IP address. Use /etc/kvmd/override.yaml . The format is: kvmd : wol : mac : ff:ff:ff:ff:ff:ff Replace ff:ff:ff:ff:ff:ff with the MAC of your server. By default, a packet is sent via a broadcast request to the entire IPv4 network ( 255.255.255.255 , port 9 ), but you can address it to a specific static address: kvmd : wol : mac : ff:ff:ff:ff:ff:ff ip : 192.168.0.100 # port: 9 # By default ... then restart kvmd using systemctl restart kvmd . It will now show up in the system button in the upper right corner.","title":"Simplified method (one host)"},{"location":"wol/#gpio-method-multiple-hosts","text":"Follow the manual for building the GPIO menu and use the wol driver to build a menu with many buttons tied to different hosts.","title":"GPIO method (multiple hosts)"},{"location":"xh_hk4401/","text":"XH-HK4401 4-port HDMI USB KVM Switch \u00b6 This KVM is sold under many names, and comes in two versions. The only way these two versions differ is that one has one of its USB ports replaced with a PS/2 port. The identifying feature is that they come with a small external control unit with 4 buttons. This controller is connected to the main KVM via a micro USB cable, however this is NOT as USB connection. Warning Audio was not tested, it is assumed to be non-functional Connections \u00b6 Connect the USB-A cable from the Raspberry Pi OTG port to to any of the USB ports on the XH-HK4401 switch. All 3/4 USB ports work exactly the same, internally they are just connected to a USB HUB. Connect the HDMI out from the XH-HK4401 switch to the Raspberry Pi CSI-2 to HDMI input. Connect host USB and HDMI cables from the XH-HK4401 switch to the machines to be managed per the switch instructions. Finally see below for details about connecting to the control micro USB port. This it not a normal USB micro port. Warning There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi HDMI-CSI bridge. These limitations apply equally when using the XH-HK4401 KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the XH-HK4401 switch before powering the hosts on. RS-232 control cable \u00b6 The control unit communicates to the KVM using the RS-232 protocol (at 5v) not USB, and one of the following solutions must be used. Inverting USB UART adapter (FT-232) - The easy way \u00b6 Some USB UART adapters have the rare feature to invert the logic level of the RX/TX signals. For example the FTDI FT232 can be configured via the FTDI configuration GUI to do this. With such an adapter, the circuit above is not required. All you need is to connect it to a micro-USB connector. Warning These options will only work on UART adapters with genuine FTDI chips. There are a lot of cheap fakes on the market that either lack this option, or will prevent you from changing the settings. To avoid getting a fake ensure you always purchase from a reputable store and brand (Adafruit, Sparkfun, etc.), Amazon is not a reputable store. Linux Instructions \u00b6 References I used to get my FTDIs working: https://waterpigs.co.uk/articles/ftdi-configure-mac-linux/ https://manpages.debian.org/testing/ftdi-eeprom/ftdi_eeprom.1.en.html https://manpages.ubuntu.com/manpages/bionic/man1/ftdi_eeprom.1.html http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.h http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.c http://developer.intra2net.com/git/?p=libftdi;a=tree;f=ftdi_eeprom http://developer.intra2net.com/git/?p=libftdi;a=blob;f=ftdi_eeprom/example.conf http://developer.intra2net.com/git/?p=libftdi;a=blob;f=ftdi_eeprom/main.c Warning Steps were performed on Debian-like installation (Pop!_OS 21.10) This workflow has worked for a self-described NON-genuine FTDI FT232RL chip. The other MAY be genuine, but it is also working. Neither of the following FTDI UART adapters are recommended. Purchasing both chips was an error (only 1 intended). However, having two (potentially non-genuine) FTDI UART adapters helped to create these instructions. Possibly genuine, but working regardless, (DSD TECH) FTDI Not genuine (HiLetGo) FTDI Warning The HiLetGo UART adapter comes with a USB MINI female connector and necessitates another adapter/cable for interfacing with the Pi. Get info from FTDI Plug the FTDI into a USB port on your Linux device and run lsusb to verify that the device is found lsusb Ensure the device is recognized as FTDI sudo lshw | grep -B 10 ftdi Record hardware information (not sure if needed, but was saved to prevent overwriting critical data in the EEPROM) Blacklist ftdi_sio kernel module The kernel module ==ftdi_sio== is currently enabled (and how you saw the device in the previous step). We need to disable this module to read/write to the EEPROM. The following command creates a file to blacklist the ==ftdi_sio== module. echo \"blacklist ftdi_sio\" | sudo tee /etc/modprobe.d/bl-ftdi.conf > /dev/null Reboot machine We need to reboot into an environment without ftdi_sio active. shutdown -r 0 Install ftdi_eeprom if not already installed Install ==ftdi_eeprom== with the following command. sudo apt install ftdi_eeprom Make a folder to work from and change it to our working directory mkdir ./ftdi_config cd ./ftdi_config Create a valid FTDI configuration file for ftdi_eeprom consumption The below command (copy/paste all lines) will create a valid configuration file. Change parameters as required. tee ./ftdi.conf > /dev/null <<EOF filename=eeprom.bin vendor_id=0x0403 product_id=0x6001 manufacturer=\"FTDI\" product=\"FT232 Serial (UART)\" serial=\"SERIAL\" use_serial=true max_power=500 self_powered=false invert_txd=true invert_rxd=true cha_type=\"UART\" EOF This configuration is trimmed from the example due to size of the EEPROM on the FTDIs used. The example configuration at ==/usr/share/doc/ftdi-eeprom/example.conf== describes possible configuration options for the FTDI and is well-documented. The above configuration worked for the mentioned devices. The ==filename==, ==vendor_id==, ==product_id==, ==invert_txd==, and ==invert_rxd== variables are required. The others might not be, but seemed applicable. If you're using a different FTDI chip than used here, please update that in the above configuration. Ensure that vendor_id and product_id are what was obtained from the output of the initial lsusb command. ==max_power==, ==serial==, and ==product== were updated to reflect the output of the initial lshw . These updates may not be required and were done to avoid overwriting anything important. ==cha_type== was updated to ==UART== where both of the devices were originally designated as FIFO. Test the configuration and read the eeprom initially before flashing Read the EEPROM with the following command sudo ftdi_eeprom --read-eeprom ./ftdi.conf If you get an error here, there's something wrong with your configuration. Check that the device is properly identified and try again. Rename/preserve and review the contents of the binary read from the EEPROM First, rename the output binary file so we don't overwrite it when we flash (flashing writes the flashed binary to the ==filename== path) mv ./eeprom.bin ./original_eeprom.bin Then, display the outputs of the binary hexdump -C original_eeprom.bin You can rename the binary in the configuration file by editing the ==filename== variable. If you can't be bothered to edit the file, rename it as detailed above. Flash the configuration Run the following command to flash the EEPROM of the FTDI sudo ftdi_eeprom --flash-eeprom ./ftdi.conf Optional: compare the flashed configuration to the initial configuration with the below command. If there is no output, the files are the same. You will likely need to re-flash. diff <(xxd original_eeprom.bin) <(xxd eeprom.bin) Alternatively, you can manually compare the files by running hexdump -C original_eeprom.bin and hexdump -C eeprom.bin Your FTDI should be flashed and working to control the KVM! Plug it into one of the Pi's USB slots (if not already), and it's good to go. The KVM will sink power from the FTDI (Pi) if Vcc is connected. If Vcc is disconnected, ensure that grounds between the Pi and KVM are tied. Clean up the ftdi blacklist to reenable the ftdi_sio module Comment out the line but leave the file with the following command: sudo sed -i 's/blacklist ftdi_sio/#blacklist ftdi_sio/g' /etc/modprobe.d/bl-ftdi.conf If you'd need to read/flash FTDI EEPROM in the future, you can use the following command (followed by a reboot) to blacklist the ==ftdi_sio== module again. sudo sed -i 's/#blacklist ftdi_sio/blacklist ftdi_sio/g' /etc/modprobe.d/bl-ftdi.conf If you want to wash your hands of FTDI flashing, then delete the blacklist file with the following command: sudo rm /etc/modprobe.d/bl-ftdi.conf Reboot the machine to reset to initial state (with ftdi_sio loaded) ==ftdi_sio== should reload as the driver, and the FTDI should be able to be seen with lshw / dmesg once again. If you tried to run either command while ==ftdi_sio== was blacklisted, you probably would have come up empty. Windows Instructions \u00b6 In order to invert the RX/TX signals, you can use ft_prog and set the following settings: Once the UART is configured, please fully disconnect it and connect it back to the computer. Relaunch ft_prog and ensure the settings are still set. If they are not, you have a fake FTDI chip. FTDI Terminal Configuration \u00b6 Finally, you will need to connect it to the micro USB port ( This it not a normal USB micro port. ) like so: Signal Colour FT232 Pin Vbus Red 5v (if you want to power the KVM from the Pi's USB) D- White RX D+ Green TX Gnd Black GND An inverter circuit - The cheap way \u00b6 For this you will need: 1x 74HC14 1x USB A socket, or sacrificial micro USB cable Optional 1x Diode - If you want to power the KVM from the Raspberry Pi 1x 5-pin header 5x Female - Female jumper cables Note Please search online for USB pinouts to ensure you connect it properly. Adding UI elements to control the KVM switch \u00b6 The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected. The instructions below will make these available in the PiKVM UI after clicking the \"GPIO\" menu button in the KVM view. SSH into PiKVM Enable read-write mode on the sd card via rw Edit the /etc/kvmd/override.yaml file and include the following. Method Device FT-232 /dev/ttyUSB0 Inverter /dev/ttyAMA0 kvmd : gpio : drivers : hk : type : xh_hk4401 device : /dev/ttyUSB0 scheme : ch0_led : driver : hk pin : 0 mode : input ch1_led : driver : hk pin : 1 mode : input ch2_led : driver : hk pin : 2 mode : input ch3_led : driver : hk pin : 3 mode : input ch0_button : driver : hk pin : 0 mode : output switch : false ch1_button : driver : hk pin : 1 mode : output switch : false ch2_button : driver : hk pin : 2 mode : output switch : false ch3_button : driver : hk pin : 3 mode : output switch : false view : table : - [ \"#Input 1\" , ch0_led , ch0_button ] - [ \"#Input 2\" , ch1_led , ch1_button ] - [ \"#Input 3\" , ch2_led , ch2_button ] - [ \"#Input 4\" , ch3_led , ch3_button ] Return to read-only mode for the sd card via ro Restart the kvmd service: systemctl restart kvmd Switching between hosts in the UI \u00b6 To switch between hosts, enter the KVM UI and click the \"GPIO\" menu. You should see 4 inputs, one of which will have a green circle indicating it is currently selected. Click the other inputs to change the selected host.","title":"XH-HK4401 4-port HDMI USB KVM Switch"},{"location":"xh_hk4401/#xh-hk4401-4-port-hdmi-usb-kvm-switch","text":"This KVM is sold under many names, and comes in two versions. The only way these two versions differ is that one has one of its USB ports replaced with a PS/2 port. The identifying feature is that they come with a small external control unit with 4 buttons. This controller is connected to the main KVM via a micro USB cable, however this is NOT as USB connection. Warning Audio was not tested, it is assumed to be non-functional","title":"XH-HK4401 4-port HDMI USB KVM Switch"},{"location":"xh_hk4401/#connections","text":"Connect the USB-A cable from the Raspberry Pi OTG port to to any of the USB ports on the XH-HK4401 switch. All 3/4 USB ports work exactly the same, internally they are just connected to a USB HUB. Connect the HDMI out from the XH-HK4401 switch to the Raspberry Pi CSI-2 to HDMI input. Connect host USB and HDMI cables from the XH-HK4401 switch to the machines to be managed per the switch instructions. Finally see below for details about connecting to the control micro USB port. This it not a normal USB micro port. Warning There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi HDMI-CSI bridge. These limitations apply equally when using the XH-HK4401 KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the XH-HK4401 switch before powering the hosts on.","title":"Connections"},{"location":"xh_hk4401/#rs-232-control-cable","text":"The control unit communicates to the KVM using the RS-232 protocol (at 5v) not USB, and one of the following solutions must be used.","title":"RS-232 control cable"},{"location":"xh_hk4401/#inverting-usb-uart-adapter-ft-232-the-easy-way","text":"Some USB UART adapters have the rare feature to invert the logic level of the RX/TX signals. For example the FTDI FT232 can be configured via the FTDI configuration GUI to do this. With such an adapter, the circuit above is not required. All you need is to connect it to a micro-USB connector. Warning These options will only work on UART adapters with genuine FTDI chips. There are a lot of cheap fakes on the market that either lack this option, or will prevent you from changing the settings. To avoid getting a fake ensure you always purchase from a reputable store and brand (Adafruit, Sparkfun, etc.), Amazon is not a reputable store.","title":"Inverting USB UART adapter (FT-232) - The easy way"},{"location":"xh_hk4401/#linux-instructions","text":"References I used to get my FTDIs working: https://waterpigs.co.uk/articles/ftdi-configure-mac-linux/ https://manpages.debian.org/testing/ftdi-eeprom/ftdi_eeprom.1.en.html https://manpages.ubuntu.com/manpages/bionic/man1/ftdi_eeprom.1.html http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.h http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.c http://developer.intra2net.com/git/?p=libftdi;a=tree;f=ftdi_eeprom http://developer.intra2net.com/git/?p=libftdi;a=blob;f=ftdi_eeprom/example.conf http://developer.intra2net.com/git/?p=libftdi;a=blob;f=ftdi_eeprom/main.c Warning Steps were performed on Debian-like installation (Pop!_OS 21.10) This workflow has worked for a self-described NON-genuine FTDI FT232RL chip. The other MAY be genuine, but it is also working. Neither of the following FTDI UART adapters are recommended. Purchasing both chips was an error (only 1 intended). However, having two (potentially non-genuine) FTDI UART adapters helped to create these instructions. Possibly genuine, but working regardless, (DSD TECH) FTDI Not genuine (HiLetGo) FTDI Warning The HiLetGo UART adapter comes with a USB MINI female connector and necessitates another adapter/cable for interfacing with the Pi. Get info from FTDI Plug the FTDI into a USB port on your Linux device and run lsusb to verify that the device is found lsusb Ensure the device is recognized as FTDI sudo lshw | grep -B 10 ftdi Record hardware information (not sure if needed, but was saved to prevent overwriting critical data in the EEPROM) Blacklist ftdi_sio kernel module The kernel module ==ftdi_sio== is currently enabled (and how you saw the device in the previous step). We need to disable this module to read/write to the EEPROM. The following command creates a file to blacklist the ==ftdi_sio== module. echo \"blacklist ftdi_sio\" | sudo tee /etc/modprobe.d/bl-ftdi.conf > /dev/null Reboot machine We need to reboot into an environment without ftdi_sio active. shutdown -r 0 Install ftdi_eeprom if not already installed Install ==ftdi_eeprom== with the following command. sudo apt install ftdi_eeprom Make a folder to work from and change it to our working directory mkdir ./ftdi_config cd ./ftdi_config Create a valid FTDI configuration file for ftdi_eeprom consumption The below command (copy/paste all lines) will create a valid configuration file. Change parameters as required. tee ./ftdi.conf > /dev/null <<EOF filename=eeprom.bin vendor_id=0x0403 product_id=0x6001 manufacturer=\"FTDI\" product=\"FT232 Serial (UART)\" serial=\"SERIAL\" use_serial=true max_power=500 self_powered=false invert_txd=true invert_rxd=true cha_type=\"UART\" EOF This configuration is trimmed from the example due to size of the EEPROM on the FTDIs used. The example configuration at ==/usr/share/doc/ftdi-eeprom/example.conf== describes possible configuration options for the FTDI and is well-documented. The above configuration worked for the mentioned devices. The ==filename==, ==vendor_id==, ==product_id==, ==invert_txd==, and ==invert_rxd== variables are required. The others might not be, but seemed applicable. If you're using a different FTDI chip than used here, please update that in the above configuration. Ensure that vendor_id and product_id are what was obtained from the output of the initial lsusb command. ==max_power==, ==serial==, and ==product== were updated to reflect the output of the initial lshw . These updates may not be required and were done to avoid overwriting anything important. ==cha_type== was updated to ==UART== where both of the devices were originally designated as FIFO. Test the configuration and read the eeprom initially before flashing Read the EEPROM with the following command sudo ftdi_eeprom --read-eeprom ./ftdi.conf If you get an error here, there's something wrong with your configuration. Check that the device is properly identified and try again. Rename/preserve and review the contents of the binary read from the EEPROM First, rename the output binary file so we don't overwrite it when we flash (flashing writes the flashed binary to the ==filename== path) mv ./eeprom.bin ./original_eeprom.bin Then, display the outputs of the binary hexdump -C original_eeprom.bin You can rename the binary in the configuration file by editing the ==filename== variable. If you can't be bothered to edit the file, rename it as detailed above. Flash the configuration Run the following command to flash the EEPROM of the FTDI sudo ftdi_eeprom --flash-eeprom ./ftdi.conf Optional: compare the flashed configuration to the initial configuration with the below command. If there is no output, the files are the same. You will likely need to re-flash. diff <(xxd original_eeprom.bin) <(xxd eeprom.bin) Alternatively, you can manually compare the files by running hexdump -C original_eeprom.bin and hexdump -C eeprom.bin Your FTDI should be flashed and working to control the KVM! Plug it into one of the Pi's USB slots (if not already), and it's good to go. The KVM will sink power from the FTDI (Pi) if Vcc is connected. If Vcc is disconnected, ensure that grounds between the Pi and KVM are tied. Clean up the ftdi blacklist to reenable the ftdi_sio module Comment out the line but leave the file with the following command: sudo sed -i 's/blacklist ftdi_sio/#blacklist ftdi_sio/g' /etc/modprobe.d/bl-ftdi.conf If you'd need to read/flash FTDI EEPROM in the future, you can use the following command (followed by a reboot) to blacklist the ==ftdi_sio== module again. sudo sed -i 's/#blacklist ftdi_sio/blacklist ftdi_sio/g' /etc/modprobe.d/bl-ftdi.conf If you want to wash your hands of FTDI flashing, then delete the blacklist file with the following command: sudo rm /etc/modprobe.d/bl-ftdi.conf Reboot the machine to reset to initial state (with ftdi_sio loaded) ==ftdi_sio== should reload as the driver, and the FTDI should be able to be seen with lshw / dmesg once again. If you tried to run either command while ==ftdi_sio== was blacklisted, you probably would have come up empty.","title":"Linux Instructions"},{"location":"xh_hk4401/#windows-instructions","text":"In order to invert the RX/TX signals, you can use ft_prog and set the following settings: Once the UART is configured, please fully disconnect it and connect it back to the computer. Relaunch ft_prog and ensure the settings are still set. If they are not, you have a fake FTDI chip.","title":"Windows Instructions"},{"location":"xh_hk4401/#ftdi-terminal-configuration","text":"Finally, you will need to connect it to the micro USB port ( This it not a normal USB micro port. ) like so: Signal Colour FT232 Pin Vbus Red 5v (if you want to power the KVM from the Pi's USB) D- White RX D+ Green TX Gnd Black GND","title":"FTDI Terminal Configuration"},{"location":"xh_hk4401/#an-inverter-circuit-the-cheap-way","text":"For this you will need: 1x 74HC14 1x USB A socket, or sacrificial micro USB cable Optional 1x Diode - If you want to power the KVM from the Raspberry Pi 1x 5-pin header 5x Female - Female jumper cables Note Please search online for USB pinouts to ensure you connect it properly.","title":"An inverter circuit - The cheap way"},{"location":"xh_hk4401/#adding-ui-elements-to-control-the-kvm-switch","text":"The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected. The instructions below will make these available in the PiKVM UI after clicking the \"GPIO\" menu button in the KVM view. SSH into PiKVM Enable read-write mode on the sd card via rw Edit the /etc/kvmd/override.yaml file and include the following. Method Device FT-232 /dev/ttyUSB0 Inverter /dev/ttyAMA0 kvmd : gpio : drivers : hk : type : xh_hk4401 device : /dev/ttyUSB0 scheme : ch0_led : driver : hk pin : 0 mode : input ch1_led : driver : hk pin : 1 mode : input ch2_led : driver : hk pin : 2 mode : input ch3_led : driver : hk pin : 3 mode : input ch0_button : driver : hk pin : 0 mode : output switch : false ch1_button : driver : hk pin : 1 mode : output switch : false ch2_button : driver : hk pin : 2 mode : output switch : false ch3_button : driver : hk pin : 3 mode : output switch : false view : table : - [ \"#Input 1\" , ch0_led , ch0_button ] - [ \"#Input 2\" , ch1_led , ch1_button ] - [ \"#Input 3\" , ch2_led , ch2_button ] - [ \"#Input 4\" , ch3_led , ch3_button ] Return to read-only mode for the sd card via ro Restart the kvmd service: systemctl restart kvmd","title":"Adding UI elements to control the KVM switch"},{"location":"xh_hk4401/#switching-between-hosts-in-the-ui","text":"To switch between hosts, enter the KVM UI and click the \"GPIO\" menu. You should see 4 inputs, one of which will have a green circle indicating it is currently selected. Click the other inputs to change the selected host.","title":"Switching between hosts in the UI"},{"location":"stl/atx/","text":"PiKVM v3 ATX mounting brackets for 3D printing \u00b6 A good way to mount an ATX adapter in a computer case is to place it in a PCI slot. Here you can get drawings of PCI brackets for 3D printing. Variant Description This is a standard bracket of common length , which will fit most personal computers The short bracket (low profile) , for compact PCs or rack servers","title":"PiKVM v3 ATX mounting brackets for 3D printing"},{"location":"stl/atx/#pikvm-v3-atx-mounting-brackets-for-3d-printing","text":"A good way to mount an ATX adapter in a computer case is to place it in a PCI slot. Here you can get drawings of PCI brackets for 3D printing. Variant Description This is a standard bracket of common length , which will fit most personal computers The short bracket (low profile) , for compact PCs or rack servers","title":"PiKVM v3 ATX mounting brackets for 3D printing"},{"location":"stl/v3.2/","text":"3D printable case for PiKVM v3.2 HAT \u00b6 When printing the case, you can choose the following options: The presence or absence of an OLED screen (used to display the IP address and other information). The presence or absence of holes for the AUM v3.3 (Advanced USB Module, most likely you don't have it). Also take a look at the PCI bracket for ATX adapter board . Buy options \u00b6 Small 5v fan strongly recommended to avoid overheating in the case. I2C OLED screen . Building \u00b6 Parts \u00b6 The front part \u00b6 Choose ONE of them. Variant Description The front part of the case WITHOUT a hole for the OLED The front part of the case with a hole for installing the OLED The back part \u00b6 Choose ONE of them. Variant Description The back part of the case WITHOUT AUM holes The back part of the case for installing the AUM Spacers \u00b6 Type Description 6.2mm spacer , required TWO pieces 2mm spacer required TWO without AUM or ONE for AUM 1mm spacer required ONE for AUM only Low spacer required ONE","title":"3D printable case for PiKVM v3.2 HAT"},{"location":"stl/v3.2/#3d-printable-case-for-pikvm-v32-hat","text":"When printing the case, you can choose the following options: The presence or absence of an OLED screen (used to display the IP address and other information). The presence or absence of holes for the AUM v3.3 (Advanced USB Module, most likely you don't have it). Also take a look at the PCI bracket for ATX adapter board .","title":"3D printable case for PiKVM v3.2 HAT"},{"location":"stl/v3.2/#buy-options","text":"Small 5v fan strongly recommended to avoid overheating in the case. I2C OLED screen .","title":"Buy options"},{"location":"stl/v3.2/#building","text":"","title":"Building"},{"location":"stl/v3.2/#parts","text":"","title":"Parts"},{"location":"stl/v3.2/#the-front-part","text":"Choose ONE of them. Variant Description The front part of the case WITHOUT a hole for the OLED The front part of the case with a hole for installing the OLED","title":"The front part"},{"location":"stl/v3.2/#the-back-part","text":"Choose ONE of them. Variant Description The back part of the case WITHOUT AUM holes The back part of the case for installing the AUM","title":"The back part"},{"location":"stl/v3.2/#spacers","text":"Type Description 6.2mm spacer , required TWO pieces 2mm spacer required TWO without AUM or ONE for AUM 1mm spacer required ONE for AUM only Low spacer required ONE","title":"Spacers"},{"location":"stl/v3.3/","text":"PiKVM v3.3 Plastic Case for 3D printing \u00b6 When printing the case, you can choose the following options: The presence or absence of an OLED screen (used to display the IP address and other information). Also take a look at the PCI bracket for ATX adapter board and great unofficial case mod for Noctua fans Buy options \u00b6 Small 5v fan strongly recommended to avoid overheating in the case. I2C OLED screen . Parts \u00b6 The front part \u00b6 Choose ONE of them. Variant Description The front part of the case WITHOUT a hole for the OLED The front part of the case with a hole for installing the OLED The back part \u00b6 Variant Description The back part of the case Spacers \u00b6 Type Description 6.2mm spacer , required TWO pieces 1mm spacer required TWO pieces Low spacer required ONE piece Fasteners (screws) \u00b6 The official PiKVM v3.3 hat came with eight M2.5 x 12mm screws for countersunk holes. You can use these with the case. Assembly \u00b6 Note: the spacers slide over the (short) hexagonal standoffs included in the official v3.3 hat: To assemble: Ensure the hexagonal standoffs are all attached to the top side of the v3.3 hat. Tip: if you need to remove the case in the future, you don't want these hexagonal standoffs spinning while you loosen the screws - be sure to tighten the standoffs more than you tighten the screws in step 17. You could even use some thread-locking fluid on the standoffs now. Ensure the bottom side of the Pi has no screws present Ensure you have eight M2.5 x 12mm screws free for later use. Slide the two short spacers over the two standoffs on the side of the hat which contains the ATX, keyboard/mouse emulation, and HDMI connector. See Figure 1. Figure 1: 1mm spacer placement Slide the two long spacers over the two standoffs on the opposite side of the HAT - near the LEDs, power input, and console-over-ethernet connector. See Figure 2. Figure 2: Placement of 6.2mm spacers. Attach the fan to the two headers labeled \"fan\" located next to the CSI ribbon cable and large capacitor. Slide the fan into the slot on the front part of the case. The fan should move fan from outside to inside the case. For the fan in Figure 3, this means mounting with the label facing the inside of the case and the black lead connected to the negative (-) terminal on the PCB. Ensure the fan leads don't bind as you slide the fan in. See Figure 3. Figure 3: Fan placement If you still have foam covering the GPI pins on the top side of the hat, now is a good time to remove them. Leaving this in place will restrict airflow. Flip the PiKVM over and set the low spacer bracket you printed on the bottomside of the Pi with the straight edge facing away from the SD card. See Figure 4. Figure 4: Low spacer placement While allowing the low spacer to continue resting on the Pi, gently slide the PiKVM into the front part of the case. Ensure the spacers clear the top of the case (likely facing away from you) and that the fan leads don't bind on anything. The low spacer should remain mostly in place thanks to the solder joints on the Pi. If successful, the low spacer should be fairly close to aligning with the holes in the case. Use a small screwdriver or tweezers to fix the alignment. You may need to insert the screwdriver into the case along the inner face to push the low spacer towards the holes. See video for reference. Insert 4 screws into the holes of the case and tighten enough so things don't fall out, but leave plenty of slack - you might need to push the electronics around slightly to align the holes in the next steps. Now is a good time to power on the PiKVM and ensure the fan spins. It should come on automatically unless you explicitly disabled it yourself. Slide the back part over the PiKVM and align with the front part you assembled in previous steps. Ensure the case seats properly around the connectors. Insert the remaining four screws into the case and tighten. If the holes don't line up, you can hold the case while pushing on some of the PiKVM connectors to shift the electronics inside the case. Tighten all screws. Tip your bartender.","title":"PiKVM v3.3 Plastic Case for 3D printing"},{"location":"stl/v3.3/#pikvm-v33-plastic-case-for-3d-printing","text":"When printing the case, you can choose the following options: The presence or absence of an OLED screen (used to display the IP address and other information). Also take a look at the PCI bracket for ATX adapter board and great unofficial case mod for Noctua fans","title":"PiKVM v3.3 Plastic Case for 3D printing"},{"location":"stl/v3.3/#buy-options","text":"Small 5v fan strongly recommended to avoid overheating in the case. I2C OLED screen .","title":"Buy options"},{"location":"stl/v3.3/#parts","text":"","title":"Parts"},{"location":"stl/v3.3/#the-front-part","text":"Choose ONE of them. Variant Description The front part of the case WITHOUT a hole for the OLED The front part of the case with a hole for installing the OLED","title":"The front part"},{"location":"stl/v3.3/#the-back-part","text":"Variant Description The back part of the case","title":"The back part"},{"location":"stl/v3.3/#spacers","text":"Type Description 6.2mm spacer , required TWO pieces 1mm spacer required TWO pieces Low spacer required ONE piece","title":"Spacers"},{"location":"stl/v3.3/#fasteners-screws","text":"The official PiKVM v3.3 hat came with eight M2.5 x 12mm screws for countersunk holes. You can use these with the case.","title":"Fasteners (screws)"},{"location":"stl/v3.3/#assembly","text":"Note: the spacers slide over the (short) hexagonal standoffs included in the official v3.3 hat: To assemble: Ensure the hexagonal standoffs are all attached to the top side of the v3.3 hat. Tip: if you need to remove the case in the future, you don't want these hexagonal standoffs spinning while you loosen the screws - be sure to tighten the standoffs more than you tighten the screws in step 17. You could even use some thread-locking fluid on the standoffs now. Ensure the bottom side of the Pi has no screws present Ensure you have eight M2.5 x 12mm screws free for later use. Slide the two short spacers over the two standoffs on the side of the hat which contains the ATX, keyboard/mouse emulation, and HDMI connector. See Figure 1. Figure 1: 1mm spacer placement Slide the two long spacers over the two standoffs on the opposite side of the HAT - near the LEDs, power input, and console-over-ethernet connector. See Figure 2. Figure 2: Placement of 6.2mm spacers. Attach the fan to the two headers labeled \"fan\" located next to the CSI ribbon cable and large capacitor. Slide the fan into the slot on the front part of the case. The fan should move fan from outside to inside the case. For the fan in Figure 3, this means mounting with the label facing the inside of the case and the black lead connected to the negative (-) terminal on the PCB. Ensure the fan leads don't bind as you slide the fan in. See Figure 3. Figure 3: Fan placement If you still have foam covering the GPI pins on the top side of the hat, now is a good time to remove them. Leaving this in place will restrict airflow. Flip the PiKVM over and set the low spacer bracket you printed on the bottomside of the Pi with the straight edge facing away from the SD card. See Figure 4. Figure 4: Low spacer placement While allowing the low spacer to continue resting on the Pi, gently slide the PiKVM into the front part of the case. Ensure the spacers clear the top of the case (likely facing away from you) and that the fan leads don't bind on anything. The low spacer should remain mostly in place thanks to the solder joints on the Pi. If successful, the low spacer should be fairly close to aligning with the holes in the case. Use a small screwdriver or tweezers to fix the alignment. You may need to insert the screwdriver into the case along the inner face to push the low spacer towards the holes. See video for reference. Insert 4 screws into the holes of the case and tighten enough so things don't fall out, but leave plenty of slack - you might need to push the electronics around slightly to align the holes in the next steps. Now is a good time to power on the PiKVM and ensure the fan spins. It should come on automatically unless you explicitly disabled it yourself. Slide the back part over the PiKVM and align with the front part you assembled in previous steps. Ensure the case seats properly around the connectors. Insert the remaining four screws into the case and tighten. If the holes don't line up, you can hold the case while pushing on some of the PiKVM connectors to shift the electronics inside the case. Tighten all screws. Tip your bartender.","title":"Assembly"}]}